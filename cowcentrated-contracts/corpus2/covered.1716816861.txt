/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/crytic/CustomActor.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.19;
 3 |     | contract CustomActor {
 4 |     |     function proxy(address target, bytes memory data) public returns (bool success, bytes memory retData) {
 5 |     |         return target.call(data);
 6 |     |     }
 7 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/crytic/EchidnaTest2.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | // import {Test, console} from "forge-std/Test.sol";
  5 |     | import {Setup2} from "./Setup2.sol";
  6 |     | import {CustomActor} from "./CustomActor.sol";
  7 |     | import "./Hevm.sol";
  8 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  9 |     | import "@openzeppelin/contracts/access/Ownable.sol";
 10 |     | import "./VeldromeLiquidityProvider.sol";
 11 |     | import "forge-std/console.sol";
 12 |     | 
 13 |     | // Test ETH/USDT Uniswap Strategy. Large decimal token0 and small decimal token1;
 14 | *   | contract  EchidnaTest2 is Setup2 {
 15 |     | 
 16 |     |     CustomActor normalUser;
 17 |     |     CustomActor attacker;
 18 |     | 
 19 |     |     bool isSetupCompleted;
 20 |     |     VelodromeLiquidityProvider lpProvider;
 21 | *   |     function initialize() public{
 22 | *   |         if (!isSetupCompleted)
 23 |     |         {
 24 | *   |             setUp();
 25 |     |             normalUser = new  CustomActor();
 26 |     |             attacker = new CustomActor();
 27 |     | 
 28 |     |             //assigning some extra tokens to users
 29 |     |             ERC20 token0Token = ERC20(token0);
 30 |     |             ERC20 token1Token = ERC20(token1);
 31 |     |             ERC20 nativeToken = ERC20(native);
 32 |     |             
 33 |     |             address token0Owner  = Ownable(token0).owner();
 34 |     |             address token1Owner  = Ownable(token1).owner();
 35 |     |             address nativeOwner  = Ownable(native).owner();
 36 |     | 
 37 |     |             //giving some extra tokens to our attacker
 38 |     |             hevm.prank(token0Owner);
 39 |     |             token0Token.transfer(address(attacker),1000000*10**token0Token.decimals());
 40 |     |             hevm.prank(token1Owner);
 41 |     |             token1Token.transfer(address(attacker),1000000*10**token1Token.decimals());
 42 |     | 
 43 |     |             //the following transfer is not needed as the native token is the same as token1
 44 |     |             // hevm.prank(nativeOwner);
 45 |     |             // nativeToken.mint(address(attacker),1000000*10**nativeToken.decimals());
 46 |     | 
 47 |     |             
 48 |     | 
 49 |     |             //veldrome lp
 50 |     |             lpProvider = new VelodromeLiquidityProvider(unirouter,token0,token1,false);
 51 |     | 
 52 |     | 
 53 |     |             isSetupCompleted=true;
 54 |     |         }
 55 |     | 
 56 |     |         
 57 |     |     }
 58 | *   |     function testCalmPeriods(uint deposit0,uint deposit1) external {
 59 | *   |         console.log("[+] Testing calm periods. ");
 60 | *   |         if(!isSetupCompleted)setUp();
 61 |     | 
 62 |     |         //get current price
 63 |     |         uint currentPrice = strategy.price();
 64 |     |         console.log("Price before... ",currentPrice);
 65 |     | 
 66 |     |         attacker.proxy(address(lpProvider),abi.encodeWithSelector(lpProvider.deposit.selector,deposit0,deposit1,deposit0,deposit1,address(attacker),block.timestamp));
 67 |     | 
 68 |     |         uint newPrice = strategy.price();
 69 |     |         console.log("Price after... ",newPrice);
 70 |     |         
 71 |     | 
 72 |     |         
 73 |     | 
 74 |     | 
 75 |     | 
 76 |     |     }
 77 |     | 
 78 |     | }
 79 |     |     

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/crytic/Hevm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Add the condition b to the assumption base for the current branch
 12 |     |     // This function is almost identical to require
 13 |     |     function assume(bool b) external;
 14 |     | 
 15 |     |     // Sets the eth balance of usr to amt
 16 |     |     function deal(address usr, uint256 amt) external;
 17 |     | 
 18 |     |     // Loads a storage slot from an address
 19 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 20 |     | 
 21 |     |     // Stores a value to an address' storage slot
 22 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 23 |     | 
 24 |     |     // Signs data (privateKey, digest) => (v, r, s)
 25 |     |     function sign(
 26 |     |         uint256 privateKey,
 27 |     |         bytes32 digest
 28 |     |     ) external returns (uint8 v, bytes32 r, bytes32 s);
 29 |     | 
 30 |     |     // Gets address for a given private key
 31 |     |     function addr(uint256 privateKey) external returns (address addr);
 32 |     | 
 33 |     |     // Performs a foreign function call via terminal
 34 |     |     function ffi(
 35 |     |         string[] calldata inputs
 36 |     |     ) external returns (bytes memory result);
 37 |     | 
 38 |     |     // Performs the next smart contract call with specified `msg.sender`
 39 |     |     function prank(address newSender) external;
 40 |     | 
 41 |     |     // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork
 42 |     |     function createFork(string calldata urlOrAlias) external returns (uint256);
 43 |     | 
 44 |     |     // Takes a fork identifier created by createFork and sets the corresponding forked state as active
 45 |     |     function selectFork(uint256 forkId) external;
 46 |     | 
 47 |     |     // Returns the identifier of the current fork
 48 |     |     function activeFork() external returns (uint256);
 49 |     | 
 50 |     |     // Labels the address in traces
 51 |     |     function label(address addr, string calldata label) external;
 52 |     | }
 53 |     | 
 54 |     | IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 55 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/crytic/Setup2.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | import {IERC20} from "@openzeppelin-4/contracts/token/ERC20/ERC20.sol";
   5 |     | import {SafeERC20} from "@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol";
   6 |     | import {BeefyVaultConcLiq} from "contracts/vault/BeefyVaultConcLiq.sol";
   7 |     | import {BeefyVaultConcLiqFactory} from "contracts/vault/BeefyVaultConcLiqFactory.sol";
   8 |     | import {StrategyPassiveManagerVelodrome} from "contracts/strategies/velodrome/StrategyPassiveManagerVelodrome.sol";
   9 |     | import {StrategyFactory} from "contracts/strategies/StrategyFactory.sol";
  10 |     | import {BeefyRewardPoolFactory} from "contracts/rewardpool/BeefyRewardPoolFactory.sol";
  11 |     | import {BeefyRewardPool} from "contracts/rewardpool/BeefyRewardPool.sol";
  12 |     | import {StratFeeManagerInitializable} from "contracts/strategies/StratFeeManagerInitializable.sol";
  13 |     | import {IStrategyConcLiq} from "contracts/interfaces/beefy/IStrategyConcLiq.sol";
  14 |     | import {VeloSwapUtils} from "contracts/utils/VeloSwapUtils.sol";
  15 |     | import {IVeloPool} from "contracts/interfaces/velodrome/IVeloPool.sol";
  16 |     | import {IVeloRouter} from "contracts/interfaces/velodrome/IVeloRouter.sol";
  17 |     | 
  18 |     | contract Setup2 {
  19 |     |     using SafeERC20 for IERC20;
  20 |     | 
  21 |     |     BeefyVaultConcLiq vault;
  22 |     |     BeefyVaultConcLiqFactory vaultFactory;
  23 |     |     StrategyPassiveManagerVelodrome strategy;
  24 |     |     StrategyPassiveManagerVelodrome implementation;
  25 |     |     BeefyRewardPoolFactory rewardPoolFactory;
  26 |     |     BeefyRewardPool rewardPool;
  27 |     |     StrategyFactory factory;
  28 |     | 
  29 |     | 
  30 | *   |     address constant pool = 0x3241738149B24C9164dA14Fa2040159FFC6Dd237;
  31 | *   |     address constant gauge = 0x8d8d1CdDD5960276A1CDE360e7b5D210C3387948;
  32 | *   |     address constant nftManager = 0xbB5DFE1380333CEE4c2EeBd7202c80dE2256AdF4;
  33 | *   |     address constant token0 = 0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85;
  34 |     |     address constant token1 = 0x4200000000000000000000000000000000000006;
  35 |     |     address constant native = 0x4200000000000000000000000000000000000006;
  36 | *   |     address constant output = 0x9560e827aF36c94D2Ac33a39bCE1Fe78631088Db;
  37 | *   |     address constant strategist = 0xb2e4A61D99cA58fB8aaC58Bb2F8A59d63f552fC0;
  38 | *   |     address constant beefyFeeRecipient = 0x02Ae4716B9D5d48Db1445814b0eDE39f5c28264B;
  39 | *   |     address constant beefyFeeConfig = 0x216EEE15D1e3fAAD34181f66dd0B665f556a638d;
  40 | *   |     address constant unirouter = 0xF132bdb9573867cD72f2585C338B923F973EB817;
  41 | *   |     address constant quoter = 0xA2DEcF05c16537C702779083Fe067e308463CE45;
  42 | *   |     address constant keeper = 0x4fED5491693007f0CD49f4614FFC38Ab6A04B619;
  43 | *   |     int24 constant width = 500;
  44 |     |     address constant user = 0x161D61e30284A33Ab1ed227beDcac6014877B3DE;
  45 |     |     uint token0Size = 4000e6;
  46 |     |     uint token1Size = 1 ether;
  47 |     |     bytes rewardPath;
  48 |     |     bytes tradePath;
  49 |     |     bytes path0;
  50 |     |     bytes path1;
  51 |     | 
  52 |     |     error NotManager();
  53 |     |     error NotCalm();
  54 |     |     error NotVault();
  55 |     |     error StrategyPaused();
  56 |     |     error NoOutputBal();
  57 |     | 
  58 | *   |     function setUp() virtual public {
  59 |     | 
  60 |     | 
  61 |     |         // Deploy Contracts
  62 | *   |         BeefyVaultConcLiq vaultImplementation = new BeefyVaultConcLiq();
  63 | *   |         vaultFactory = new BeefyVaultConcLiqFactory(address(vaultImplementation));
  64 | *   |         vault = vaultFactory.cloneVault();
  65 |     | 
  66 | *   |         implementation = new StrategyPassiveManagerVelodrome();
  67 | *   |         factory = new StrategyFactory(native, keeper, beefyFeeRecipient, beefyFeeConfig);
  68 |     | 
  69 | *   |         BeefyRewardPool rewardPoolImplementation = new BeefyRewardPool();
  70 | *   |         rewardPoolFactory = new BeefyRewardPoolFactory(address(rewardPoolImplementation));
  71 | *   |         rewardPool = rewardPoolFactory.cloneRewardPool();
  72 |     | 
  73 | *   |         rewardPool.initialize(address(vault), "rCowVeloETH-USDC", "rCowVeloETH-USDC");
  74 |     | 
  75 |     |         // Set up routing for trade paths
  76 | *   |         address[] memory lpToken0ToNative = new address[](2);
  77 | *   |         lpToken0ToNative[0] = address(token0);
  78 | *   |         lpToken0ToNative[1] = native;
  79 |     | 
  80 | *   |         address[] memory lpToken1ToNative = new address[](2);
  81 | *   |         lpToken1ToNative[0] = token1;
  82 | *   |         lpToken1ToNative[1] = native;
  83 |     | 
  84 | *   |         address[] memory tradeRoute = new address[](2);
  85 | *   |         tradeRoute[0] = native;
  86 | *   |         tradeRoute[1] = token0;
  87 |     | 
  88 | *   |         address[] memory rewardRoute = new address[](2);
  89 | *   |         rewardRoute[0] = output;
  90 | *   |         rewardRoute[1] = native;
  91 |     | 
  92 | *   |         uint24[] memory spacing = new uint24[](1);
  93 | *   |         spacing[0] = 100;
  94 |     | 
  95 | *   |         uint24[] memory veloSpacing = new uint24[](1);
  96 | *   |         veloSpacing[0] = 200;
  97 |     | 
  98 | *   |         rewardPath = routeToPath(rewardRoute, veloSpacing);
  99 | *   |         path0 = routeToPath(lpToken0ToNative, spacing);
 100 | *   |         path1 = "0x"; //routeToPath(lpToken1ToNative, fees);
 101 | *   |         tradePath = routeToPath(tradeRoute, spacing);
 102 |     | 
 103 |     |         // Init the strategy and vault
 104 | *   |         StratFeeManagerInitializable.CommonAddresses memory commonAddresses = StratFeeManagerInitializable.CommonAddresses(
 105 | *   |             address(vault),
 106 |     |             unirouter,
 107 |     |             strategist,
 108 | *   |             address(factory)
 109 |     |         );
 110 |     | 
 111 | *   |         factory.addStrategy("StrategyPassiveManagerVelodrome_v1", address(implementation));
 112 |     | 
 113 | *   |         bytes[] memory paths = new bytes[](3);
 114 | *   |         paths[0] = rewardPath;
 115 | *   |         paths[1] = path0;
 116 | *   |         paths[2] = path1;
 117 |     | 
 118 | *   |         address _strategy = factory.createStrategy("StrategyPassiveManagerVelodrome_v1");
 119 | *   |         strategy = StrategyPassiveManagerVelodrome(_strategy);
 120 | *r  |         strategy.initialize(pool, quoter, nftManager, gauge, address(rewardPool), output, width, paths, commonAddresses);
 121 |     | 
 122 |     |         rewardPool.setWhitelist(address(strategy), true);
 123 |     | 
 124 |     |         vault.initialize(address(strategy), "Moo Vault", "mooVault");
 125 |     | 
 126 |     |         strategy.setDeviation(100);
 127 |     | 
 128 |     |         address _want = vault.want();
 129 |     |         assert(_want == pool);
 130 |     | 
 131 |     |         address[] memory outputRoute = strategy.outputToNative();
 132 |     |         assert(outputRoute.length == 2);
 133 |     |         assert(outputRoute[0] == output);
 134 |     |         assert(outputRoute[1] == native);
 135 |     |     }
 136 |     | 
 137 | *   |     function routeToPath(address[] memory _route, uint24[] memory _fee) internal pure returns (bytes memory path) {
 138 | *   |         path = abi.encodePacked(_route[0]);
 139 | *   |         uint256 feeLength = _fee.length;
 140 | *   |         for (uint256 i = 0; i < feeLength; i++) {
 141 | *   |             path = abi.encodePacked(path, _fee[i], _route[i + 1]);
 142 |     |         }
 143 |     |     }
 144 |     | }
 145 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/crytic/VeldromeLiquidityProvider.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | // Interface for Velodrome router
  7 |     | interface IVelodromeRouter {
  8 |     |     function addLiquidity(
  9 |     |         address tokenA,
 10 |     |         address tokenB,
 11 |     |         bool stable,
 12 |     |         uint256 amountADesired,
 13 |     |         uint256 amountBDesired,
 14 |     |         uint256 amountAMin,
 15 |     |         uint256 amountBMin,
 16 |     |         address to,
 17 |     |         uint256 deadline
 18 |     |     ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);
 19 |     | }
 20 |     | 
 21 |     | contract VelodromeLiquidityProvider{
 22 |     |     IVelodromeRouter public velodromeRouter;
 23 |     |     IERC20 public tokenA;
 24 |     |     IERC20 public tokenB;
 25 |     |     bool public stable;
 26 |     | 
 27 |     |     constructor(
 28 |     |         address _velodromeRouter,
 29 |     |         address _tokenA,
 30 |     |         address _tokenB,
 31 |     |         bool _stable
 32 |     |     ) {
 33 |     |         velodromeRouter = IVelodromeRouter(_velodromeRouter);
 34 |     |         tokenA = IERC20(_tokenA);
 35 |     |         tokenB = IERC20(_tokenB);
 36 |     |         stable = _stable;
 37 |     |     }
 38 |     | 
 39 |     |     function deposit(
 40 |     |         uint256 amountADesired,
 41 |     |         uint256 amountBDesired,
 42 |     |         uint256 amountAMin,
 43 |     |         uint256 amountBMin,
 44 |     |         address to,
 45 |     |         uint256 deadline
 46 |     |     ) external {
 47 |     |         // Transfer tokens from the owner to this contract
 48 |     |         tokenA.transferFrom(msg.sender, address(this), amountADesired);
 49 |     |         tokenB.transferFrom(msg.sender, address(this), amountBDesired);
 50 |     | 
 51 |     |         // Approve the Velodrome router to spend the tokens
 52 |     |         tokenA.approve(address(velodromeRouter), amountADesired);
 53 |     |         tokenB.approve(address(velodromeRouter), amountBDesired);
 54 |     | 
 55 |     |         // Add liquidity
 56 |     |         velodromeRouter.addLiquidity(
 57 |     |             address(tokenA),
 58 |     |             address(tokenB),
 59 |     |             stable,
 60 |     |             amountADesired,
 61 |     |             amountBDesired,
 62 |     |             amountAMin,
 63 |     |             amountBMin,
 64 |     |             to,
 65 |     |             deadline
 66 |     |         );
 67 |     |     }
 68 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IBeefyVaultConcLiq.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | interface IBeefyVaultConcLiq {
  5 |     |     function previewDeposit(uint256 _amount0, uint256 _amount1) external view returns (uint256 shares);
  6 |     |     function previewWithdraw(uint256 shares) external view returns (uint256 amount0, uint256 amount1);
  7 |     |     function strategy() external view returns (address);
  8 |     |     function totalSupply() external view returns (uint256);
  9 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IFeeConfig.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IFeeConfig {
  5 |     |     struct FeeCategory {
  6 |     |         uint256 total;
  7 |     |         uint256 beefy; //audit-info What is this variable ? @mody. percentage for beefy from the fees
  8 |     |         uint256 call;
  9 |     |         uint256 strategist;
 10 |     |         string label;
 11 |     |         bool active;
 12 |     |     }
 13 |     |     struct AllFees {
 14 |     |         FeeCategory performance;
 15 |     |         uint256 deposit;
 16 |     |         uint256 withdraw;
 17 |     |     }
 18 |     |     function getFees(address strategy) external view returns (FeeCategory memory);
 19 |     |     function stratFeeId(address strategy) external view returns (uint256);
 20 |     |     function setStratFeeId(uint256 feeId) external;
 21 |     | }
 22 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IRewardPool.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity 0.8.23;
 3 |     | 
 4 |     | interface IRewardPool {
 5 |     |     function notifyRewardAmount(address token, uint256 reward, uint256 duration) external;
 6 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IStrategyConcLiq.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | interface IStrategyConcLiq {
  5 |     |     function balances() external view returns (uint256, uint256);
  6 |     |     function beforeAction() external;
  7 |     |     function deposit() external;
  8 |     |     function withdraw(uint256 _amount0, uint256 _amount1) external;
  9 |     |     function pool() external view returns (address);
 10 |     |     function lpToken0() external view returns (address);
 11 |     |     function lpToken1() external view returns (address);
 12 |     |     function isCalm() external view returns (bool);
 13 |     |     
 14 |     |     /// @notice The current price of the pool in token1, encoded with 36 decimals.
 15 |     |     /// @return _price The current price of the pool in token1.
 16 |     |     function price() external view returns (uint256 _price);
 17 |     | 
 18 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IStrategyFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IStrategyFactory {
  5 |     |     function native() external view returns (address);
  6 |     |     function globalPause() external view returns (bool);
  7 |     |     function keeper() external view returns (address);
  8 |     |     function beefyFeeRecipient() external view returns (address); //audit-info What is that ?
  9 |     |     function beefyFeeConfig() external view returns (address);    //audit-info What is that ? 
 10 |     |     function rebalancers(address) external view returns (bool);   //audit-info What is that ?
 11 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IStrategyUniswapV3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | /// @notice Interface for the Uniswap V3 strategy contract.
  5 |     | interface IStrategyUniswapV3 {
  6 |     | 
  7 |     |     /// @notice The sqrt price of the pool.
  8 |     |     function sqrtPrice() external view returns (uint160 sqrtPriceX96);
  9 |     |     
 10 |     |     /// @notice The range covered by the strategy.
 11 |     |     function range() external view returns (uint256 lowerPrice, uint256 upperPrice);
 12 |     | 
 13 |     |     /// @notice Returns the route to swap the first token to the native token for fee harvesting.
 14 |     |     function lpToken0ToNativePath() external view returns (bytes memory);
 15 |     | 
 16 |     |     /// @notice Returns the route to swap the second token to the native token for fee harvesting.
 17 |     |     function lpToken1ToNativePath() external view returns (bytes memory);
 18 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IStrategyVelodrome.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | /// @notice Interface for the Uniswap V3 strategy contract.
  5 |     | interface IStrategyVelodrome {
  6 |     |     /// @notice The sqrt price of the pool.
  7 |     |     function sqrtPrice() external view returns (uint160 sqrtPriceX96);
  8 |     |     
  9 |     |     /// @notice The range covered by the strategy.
 10 |     |     function range() external view returns (uint256 lowerPrice, uint256 upperPrice);
 11 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/uniswap/IQuoter.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.23;
 3 |     | 
 4 |     | interface IQuoter {
 5 |     |     function quoteExactInput(bytes memory path, uint amountIn) external returns (uint amountOut);
 6 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/uniswap/IUniswapRouterV3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | 
  6 |     | interface IUniswapRouterV3 {
  7 |     |     struct ExactInputSingleParams {
  8 |     |         address tokenIn;
  9 |     |         address tokenOut;
 10 |     |         uint24 fee;
 11 |     |         address recipient;
 12 |     |         uint256 amountIn;
 13 |     |         uint256 amountOutMinimum;
 14 |     |         uint160 sqrtPriceLimitX96;
 15 |     |     }
 16 |     | 
 17 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another token
 18 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
 19 |     |     /// @return amountOut The amount of the received token
 20 |     |     function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
 21 |     | 
 22 |     |     struct ExactInputParams {
 23 |     |         bytes path;
 24 |     |         address recipient;
 25 |     |         uint256 amountIn;
 26 |     |         uint256 amountOutMinimum;
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
 30 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
 31 |     |     /// @return amountOut The amount of the received token
 32 |     |     function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
 33 |     | 
 34 |     |     struct ExactOutputSingleParams {
 35 |     |         address tokenIn;
 36 |     |         address tokenOut;
 37 |     |         uint24 fee;
 38 |     |         address recipient;
 39 |     |         uint256 amountOut;
 40 |     |         uint256 amountInMaximum;
 41 |     |         uint160 sqrtPriceLimitX96;
 42 |     |     }
 43 |     | 
 44 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another token
 45 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
 46 |     |     /// @return amountIn The amount of the input token
 47 |     |     function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
 48 |     | 
 49 |     |     struct ExactOutputParams {
 50 |     |         bytes path;
 51 |     |         address recipient;
 52 |     |         uint256 amountOut;
 53 |     |         uint256 amountInMaximum;
 54 |     |     }
 55 |     | 
 56 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
 57 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
 58 |     |     /// @return amountIn The amount of the input token
 59 |     |     function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
 60 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/uniswap/IUniswapV3Pool.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | interface IUniswapV3Pool {
   5 |     |     /// @notice The contract that deployed the pool, which must adhere to the IPancakeV3Factory interface
   6 |     |     /// @return The contract address
   7 |     |     function factory() external view returns (address);
   8 |     | 
   9 |     |     /// @notice The first of the two tokens of the pool, sorted by address
  10 |     |     /// @return The token contract address
  11 |     |     function token0() external view returns (address);
  12 |     | 
  13 |     |     /// @notice The second of the two tokens of the pool, sorted by address
  14 |     |     /// @return The token contract address
  15 |     |     function token1() external view returns (address);
  16 |     | 
  17 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
  18 |     |     /// @return The fee
  19 |     |     function fee() external view returns (uint24);
  20 |     | 
  21 |     |     /// @notice The pool tick spacing
  22 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
  23 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
  24 |     |     /// This value is an int24 to avoid casting even though it is always positive.
  25 |     |     /// @return The tick spacing
  26 |     |     function tickSpacing() external view returns (int24);
  27 |     | 
  28 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
  29 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
  30 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
  31 |     |     /// @return The max amount of liquidity per tick
  32 |     |     function maxLiquidityPerTick() external view returns (uint128);
  33 |     | 
  34 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
  35 |     |     /// when accessed externally.
  36 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  37 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  38 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  39 |     |     /// boundary.
  40 |     |     /// observationIndex The index of the last oracle observation that was written,
  41 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  42 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  43 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  44 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  45 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  46 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  47 |     |     function slot0()
  48 |     |         external
  49 |     |         view
  50 |     |         returns (
  51 |     |             uint160 sqrtPriceX96,
  52 |     |             int24 tick,
  53 |     |             uint16 observationIndex,
  54 |     |             uint16 observationCardinality,
  55 |     |             uint16 observationCardinalityNext,
  56 |     |             uint32 feeProtocol,
  57 |     |             bool unlocked
  58 |     |         );
  59 |     | 
  60 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  61 |     |     /// @dev This value can overflow the uint256
  62 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  63 |     | 
  64 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  65 |     |     /// @dev This value can overflow the uint256
  66 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  67 |     | 
  68 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  69 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  70 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  71 |     | 
  72 |     |     /// @notice The currently in range liquidity available to the pool
  73 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  74 |     |     function liquidity() external view returns (uint128);
  75 |     | 
  76 |     |     /// @notice Look up information about a specific tick in the pool
  77 |     |     /// @param tick The tick to look up
  78 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  79 |     |     /// tick upper,
  80 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  81 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  82 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  83 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  84 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  85 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  86 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  87 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  88 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  89 |     |     /// a specific position.
  90 |     |     function ticks(int24 tick)
  91 |     |         external
  92 |     |         view
  93 |     |         returns (
  94 |     |             uint128 liquidityGross,
  95 |     |             int128 liquidityNet,
  96 |     |             uint256 feeGrowthOutside0X128,
  97 |     |             uint256 feeGrowthOutside1X128,
  98 |     |             int56 tickCumulativeOutside,
  99 |     |             uint160 secondsPerLiquidityOutsideX128,
 100 |     |             uint32 secondsOutside,
 101 |     |             bool initialized
 102 |     |         );
 103 |     | 
 104 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
 105 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
 106 |     | 
 107 |     |     /// @notice Returns the information about a position by the position's key
 108 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
 109 |     |     /// @return _liquidity The amount of liquidity in the position,
 110 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
 111 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
 112 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
 113 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
 114 |     |     function positions(bytes32 key)
 115 |     |         external
 116 |     |         view
 117 |     |         returns (
 118 |     |             uint128 _liquidity,
 119 |     |             uint256 feeGrowthInside0LastX128,
 120 |     |             uint256 feeGrowthInside1LastX128,
 121 |     |             uint128 tokensOwed0,
 122 |     |             uint128 tokensOwed1
 123 |     |         );
 124 |     | 
 125 |     |     /// @notice Returns data about a specific observation index
 126 |     |     /// @param index The element of the observations array to fetch
 127 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 128 |     |     /// ago, rather than at a specific index in the array.
 129 |     |     /// @return blockTimestamp The timestamp of the observation,
 130 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 131 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 132 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 133 |     |     function observations(uint256 index)
 134 |     |         external
 135 |     |         view
 136 |     |         returns (
 137 |     |             uint32 blockTimestamp,
 138 |     |             int56 tickCumulative,
 139 |     |             uint160 secondsPerLiquidityCumulativeX128,
 140 |     |             bool initialized
 141 |     |         );
 142 |     | 
 143 |     |     /// @notice Collects tokens owed to a position
 144 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
 145 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
 146 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
 147 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
 148 |     |     /// @param recipient The address which should receive the fees collected
 149 |     |     /// @param tickLower The lower tick of the position for which to collect fees
 150 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
 151 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
 152 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
 153 |     |     /// @return amount0 The amount of fees collected in token0
 154 |     |     /// @return amount1 The amount of fees collected in token1
 155 |     |     function collect(
 156 |     |         address recipient,
 157 |     |         int24 tickLower,
 158 |     |         int24 tickUpper,
 159 |     |         uint128 amount0Requested,
 160 |     |         uint128 amount1Requested
 161 |     |     ) external returns (uint128 amount0, uint128 amount1);
 162 |     | 
 163 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
 164 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
 165 |     |     /// @dev Fees must be collected separately via a call to #collect
 166 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
 167 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
 168 |     |     /// @param amount How much liquidity to burn
 169 |     |     /// @return amount0 The amount of token0 sent to the recipient
 170 |     |     /// @return amount1 The amount of token1 sent to the recipient
 171 |     |     function burn(
 172 |     |         int24 tickLower,
 173 |     |         int24 tickUpper,
 174 |     |         uint128 amount
 175 |     |     ) external returns (uint256 amount0, uint256 amount1);
 176 |     | 
 177 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
 178 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
 179 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
 180 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
 181 |     |     /// @param recipient The address for which the liquidity will be created
 182 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
 183 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
 184 |     |     /// @param amount The amount of liquidity to mint
 185 |     |     /// @param data Any data that should be passed through to the callback
 186 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
 187 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
 188 |     |     function mint(
 189 |     |         address recipient,
 190 |     |         int24 tickLower,
 191 |     |         int24 tickUpper,
 192 |     |         uint128 amount,
 193 |     |         bytes calldata data
 194 |     |     ) external returns (uint256 amount0, uint256 amount1);
 195 |     | 
 196 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
 197 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 198 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 199 |     |     /// you must call it with secondsAgos = [3600, 0].
 200 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 201 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 202 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 203 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 204 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 205 |     |     /// timestamp
 206 |     |     function observe(uint32[] calldata secondsAgos)
 207 |     |         external
 208 |     |         view
 209 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 210 |     | 
 211 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext)
 212 |     |         external;
 213 |     | 
 214 |     |     
 215 |     | 
 216 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/ICLGauge.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | interface ICLGauge {
   5 |     |     /// @notice NonfungiblePositionManager used to create nfts this gauge accepts
   6 |     |     function nft() external view returns (address);
   7 |     | 
   8 |     |     /// @notice Voter contract gauge receives emissions from
   9 |     |     function voter() external view returns (address);
  10 |     | 
  11 |     |     /// @notice Address of the CL pool linked to the gauge
  12 |     |     function pool() external view returns (address);
  13 |     | 
  14 |     |     /// @notice Address of the factory that created this gauge
  15 |     |     function gaugeFactory() external view returns (address);
  16 |     | 
  17 |     |     /// @notice Address of the FeesVotingReward contract linked to the gauge
  18 |     |     function feesVotingReward() external view returns (address);
  19 |     | 
  20 |     |     /// @notice Timestamp end of current rewards period
  21 |     |     function periodFinish() external view returns (uint256);
  22 |     | 
  23 |     |     /// @notice Current reward rate of rewardToken to distribute per second
  24 |     |     function rewardRate() external view returns (uint256);
  25 |     | 
  26 |     |     /// @notice Claimable rewards by tokenId
  27 |     |     function rewards(uint256 tokenId) external view returns (uint256);
  28 |     | 
  29 |     |     /// @notice Most recent timestamp tokenId called updateRewards
  30 |     |     function lastUpdateTime(uint256 tokenId) external view returns (uint256);
  31 |     | 
  32 |     |     /// @notice View to see the rewardRate given the timestamp of the start of the epoch
  33 |     |     function rewardRateByEpoch(uint256) external view returns (uint256);
  34 |     | 
  35 |     |     /// @notice Cached amount of fees generated from the Pool linked to the Gauge of token0
  36 |     |     function fees0() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice Cached amount of fees generated from the Pool linked to the Gauge of token1
  39 |     |     function fees1() external view returns (uint256);
  40 |     | 
  41 |     |     /// @notice Cached address of token0, corresponding to token0 of the pool
  42 |     |     function token0() external view returns (address);
  43 |     | 
  44 |     |     /// @notice Cached address of token1, corresponding to token1 of the pool
  45 |     |     function token1() external view returns (address);
  46 |     | 
  47 |     |     /// @notice Cached tick spacing of the pool.
  48 |     |     function tickSpacing() external view returns (int24);
  49 |     | 
  50 |     |     /// @notice Total amount of rewardToken to distribute for the current rewards period
  51 |     |     function left() external view returns (uint256 _left);
  52 |     | 
  53 |     |     /// @notice Address of the emissions token
  54 |     |     function rewardToken() external view returns (address);
  55 |     | 
  56 |     |     /// @notice To provide compatibility support with the old voter
  57 |     |     function isPool() external view returns (bool);
  58 |     | 
  59 |     |     /// @notice Returns the rewardGrowthInside of the position at the last user action (deposit, withdraw, getReward)
  60 |     |     /// @param tokenId The tokenId of the position
  61 |     |     /// @return The rewardGrowthInside for the position
  62 |     |     function rewardGrowthInside(uint256 tokenId) external view returns (uint256);
  63 |     | 
  64 |     |     /// @notice Called on gauge creation by CLGaugeFactory
  65 |     |     /// @param _pool The address of the pool
  66 |     |     /// @param _feesVotingReward The address of the feesVotingReward contract
  67 |     |     /// @param _rewardToken The address of the reward token
  68 |     |     /// @param _voter The address of the voter contract
  69 |     |     /// @param _nft The address of the nft position manager contract
  70 |     |     /// @param _token0 The address of token0 of the pool
  71 |     |     /// @param _token1 The address of token1 of the pool
  72 |     |     /// @param _tickSpacing The tick spacing of the pool
  73 |     |     /// @param _isPool Whether the attached pool is a real pool or not
  74 |     |     function initialize(
  75 |     |         address _pool,
  76 |     |         address _feesVotingReward,
  77 |     |         address _rewardToken,
  78 |     |         address _voter,
  79 |     |         address _nft,
  80 |     |         address _token0,
  81 |     |         address _token1,
  82 |     |         int24 _tickSpacing,
  83 |     |         bool _isPool
  84 |     |     ) external;
  85 |     | 
  86 |     |     /// @notice Returns the claimable rewards for a given account and tokenId
  87 |     |     /// @dev Throws if account is not the position owner
  88 |     |     /// @dev pool.updateRewardsGrowthGlobal() needs to be called first, to return the correct claimable rewards
  89 |     |     /// @param account The address of the user
  90 |     |     /// @param tokenId The tokenId of the position
  91 |     |     /// @return The amount of claimable reward
  92 |     |     function earned(address account, uint256 tokenId) external view returns (uint256);
  93 |     | 
  94 |     |     /// @notice Retrieve rewards for all tokens owned by an account
  95 |     |     /// @dev Throws if not called by the voter
  96 |     |     /// @param account The account of the user
  97 |     |     function getReward(address account) external;
  98 |     | 
  99 |     |     /// @notice Retrieve rewards for a tokenId
 100 |     |     /// @dev Throws if not called by the position owner
 101 |     |     /// @param tokenId The tokenId of the position
 102 |     |     function getReward(uint256 tokenId) external;
 103 |     | 
 104 |     |     /// @notice Notifies gauge of gauge rewards.
 105 |     |     /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.
 106 |     |     function notifyRewardAmount(uint256 amount) external;
 107 |     | 
 108 |     |     /// @dev Notifies gauge of gauge rewards without distributing its fees.
 109 |     |     ///      Assumes gauge reward tokens is 18 decimals.
 110 |     |     ///      If not 18 decimals, rewardRate may have rounding issues.
 111 |     |     /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.
 112 |     |     function notifyRewardWithoutClaim(uint256 amount) external;
 113 |     | 
 114 |     |     /// @notice Used to deposit a CL position into the gauge
 115 |     |     /// @notice Allows the user to receive emissions instead of fees
 116 |     |     /// @param tokenId The tokenId of the position
 117 |     |     function deposit(uint256 tokenId) external;
 118 |     | 
 119 |     |     /// @notice Used to withdraw a CL position from the gauge
 120 |     |     /// @notice Allows the user to receive fees instead of emissions
 121 |     |     /// @notice Outstanding emissions will be collected on withdrawal
 122 |     |     /// @param tokenId The tokenId of the position
 123 |     |     function withdraw(uint256 tokenId) external;
 124 |     | 
 125 |     |     /// @notice Used to increase liquidity of a staked position
 126 |     |     /// @param tokenId The tokenId of the position
 127 |     |     /// @param amount0Desired The desired amount of token0 to be staked,
 128 |     |     /// @param amount1Desired The desired amount of token1 to be staked,
 129 |     |     /// @param amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
 130 |     |     /// @param amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
 131 |     |     /// @param deadline The time by which the transaction must be included to effect the change
 132 |     |     /// @return liquidity The new liquidity amount as a result of the increase
 133 |     |     /// @return amount0 The amount of token0 required to obtain new liquidity amount
 134 |     |     /// @return amount1 The amount of token1 required to obtain new liquidity amount
 135 |     |     function increaseStakedLiquidity(
 136 |     |         uint256 tokenId,
 137 |     |         uint256 amount0Desired,
 138 |     |         uint256 amount1Desired,
 139 |     |         uint256 amount0Min,
 140 |     |         uint256 amount1Min,
 141 |     |         uint256 deadline
 142 |     |     ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1);
 143 |     | 
 144 |     |     /// @notice Used to decrease liquidity of a staked position
 145 |     |     /// @param tokenId The tokenId of the position
 146 |     |     /// @param liquidity The amount of liquidity to be unstaked from the gauge
 147 |     |     /// @param amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
 148 |     |     /// @param amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
 149 |     |     /// @param deadline The time by which the transaction must be included to effect the change
 150 |     |     /// @return amount0 The amount of token0 decreased from position
 151 |     |     /// @return amount1 The amount of token1 decreased from position
 152 |     |     function decreaseStakedLiquidity(
 153 |     |         uint256 tokenId,
 154 |     |         uint128 liquidity,
 155 |     |         uint256 amount0Min,
 156 |     |         uint256 amount1Min,
 157 |     |         uint256 deadline
 158 |     |     ) external returns (uint256 amount0, uint256 amount1);
 159 |     | 
 160 |     |     /// @notice Fetch all tokenIds staked by a given account
 161 |     |     /// @param depositor The address of the user
 162 |     |     /// @return The tokenIds of the staked positions
 163 |     |     function stakedValues(address depositor) external view returns (uint256[] memory);
 164 |     | 
 165 |     |     /// @notice Fetch a staked tokenId by index
 166 |     |     /// @param depositor The address of the user
 167 |     |     /// @param index The index of the staked tokenId
 168 |     |     /// @return The tokenId of the staked position
 169 |     |     function stakedByIndex(address depositor, uint256 index) external view returns (uint256);
 170 |     | 
 171 |     |     /// @notice Check whether a position is staked in the gauge by a certain user
 172 |     |     /// @param depositor The address of the user
 173 |     |     /// @param tokenId The tokenId of the position
 174 |     |     /// @return Whether the position is staked in the gauge
 175 |     |     function stakedContains(address depositor, uint256 tokenId) external view returns (bool);
 176 |     | 
 177 |     |     /// @notice The amount of positions staked in the gauge by a certain user
 178 |     |     /// @param depositor The address of the user
 179 |     |     /// @return The amount of positions staked in the gauge
 180 |     |     function stakedLength(address depositor) external view returns (uint256);
 181 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/INftPositionManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | /// @title Non-fungible token for positions
   5 |     | /// @notice Wraps CL positions in a non-fungible token interface which allows for them to be transferred
   6 |     | /// and authorized.
   7 |     | interface INftPositionManager {
   8 |     | 
   9 |     |     /// @notice Returns the position information associated with a given token ID.
  10 |     |     /// @dev Throws if the token ID is not valid.
  11 |     |     /// @param tokenId The ID of the token that represents the position
  12 |     |     /// @return nonce The nonce for permits
  13 |     |     /// @return operator The address that is approved for spending
  14 |     |     /// @return token0 The address of the token0 for a specific pool
  15 |     |     /// @return token1 The address of the token1 for a specific pool
  16 |     |     /// @return tickSpacing The tick spacing associated with the pool
  17 |     |     /// @return tickLower The lower end of the tick range for the position
  18 |     |     /// @return tickUpper The higher end of the tick range for the position
  19 |     |     /// @return liquidity The liquidity of the position
  20 |     |     /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
  21 |     |     /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
  22 |     |     /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
  23 |     |     /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
  24 |     |     function positions(uint256 tokenId)
  25 |     |         external
  26 |     |         view
  27 |     |         returns (
  28 |     |             uint96 nonce,
  29 |     |             address operator,
  30 |     |             address token0,
  31 |     |             address token1,
  32 |     |             int24 tickSpacing,
  33 |     |             int24 tickLower,
  34 |     |             int24 tickUpper,
  35 |     |             uint128 liquidity,
  36 |     |             uint256 feeGrowthInside0LastX128,
  37 |     |             uint256 feeGrowthInside1LastX128,
  38 |     |             uint128 tokensOwed0,
  39 |     |             uint128 tokensOwed1
  40 |     |         );
  41 |     | 
  42 |     |     /// @notice Returns the address of the Token Descriptor, that handles generating token URIs for Positions
  43 |     |     function tokenDescriptor() external view returns (address);
  44 |     | 
  45 |     |     /// @notice Returns the address of the Owner, that is allowed to set a new TokenDescriptor
  46 |     |     function owner() external view returns (address);
  47 |     | 
  48 |     |     struct MintParams {
  49 |     |         address token0;
  50 |     |         address token1;
  51 |     |         int24 tickSpacing;
  52 |     |         int24 tickLower;
  53 |     |         int24 tickUpper;
  54 |     |         uint256 amount0Desired;
  55 |     |         uint256 amount1Desired;
  56 |     |         uint256 amount0Min;
  57 |     |         uint256 amount1Min;
  58 |     |         address recipient;
  59 |     |         uint256 deadline;
  60 |     |         uint160 sqrtPriceX96;
  61 |     |     }
  62 |     | 
  63 |     |     /// @notice Creates a new position wrapped in a NFT
  64 |     |     /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
  65 |     |     /// a method does not exist, i.e. the pool is assumed to be initialized.
  66 |     |     /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
  67 |     |     /// @return tokenId The ID of the token that represents the minted position
  68 |     |     /// @return liquidity The amount of liquidity for this position
  69 |     |     /// @return amount0 The amount of token0
  70 |     |     /// @return amount1 The amount of token1
  71 |     |     function mint(MintParams calldata params)
  72 |     |         external
  73 |     |         payable
  74 |     |         returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
  75 |     | 
  76 |     |     struct IncreaseLiquidityParams {
  77 |     |         uint256 tokenId;
  78 |     |         uint256 amount0Desired;
  79 |     |         uint256 amount1Desired;
  80 |     |         uint256 amount0Min;
  81 |     |         uint256 amount1Min;
  82 |     |         uint256 deadline;
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
  86 |     |     /// @param params tokenId The ID of the token for which liquidity is being increased,
  87 |     |     /// amount0Desired The desired amount of token0 to be spent,
  88 |     |     /// amount1Desired The desired amount of token1 to be spent,
  89 |     |     /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
  90 |     |     /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
  91 |     |     /// deadline The time by which the transaction must be included to effect the change
  92 |     |     /// @return liquidity The new liquidity amount as a result of the increase
  93 |     |     /// @return amount0 The amount of token0 to acheive resulting liquidity
  94 |     |     /// @return amount1 The amount of token1 to acheive resulting liquidity
  95 |     |     function increaseLiquidity(IncreaseLiquidityParams calldata params)
  96 |     |         external
  97 |     |         payable
  98 |     |         returns (uint128 liquidity, uint256 amount0, uint256 amount1);
  99 |     | 
 100 |     |     struct DecreaseLiquidityParams {
 101 |     |         uint256 tokenId;
 102 |     |         uint128 liquidity;
 103 |     |         uint256 amount0Min;
 104 |     |         uint256 amount1Min;
 105 |     |         uint256 deadline;
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Decreases the amount of liquidity in a position and accounts it to the position
 109 |     |     /// @param params tokenId The ID of the token for which liquidity is being decreased,
 110 |     |     /// amount The amount by which liquidity will be decreased,
 111 |     |     /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
 112 |     |     /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
 113 |     |     /// deadline The time by which the transaction must be included to effect the change
 114 |     |     /// @return amount0 The amount of token0 accounted to the position's tokens owed
 115 |     |     /// @return amount1 The amount of token1 accounted to the position's tokens owed
 116 |     |     /// @dev The use of this function can cause a loss to users of the NonfungiblePositionManager
 117 |     |     /// @dev for tokens that have very high decimals.
 118 |     |     /// @dev The amount of tokens necessary for the loss is: 3.4028237e+38.
 119 |     |     /// @dev This is equivalent to 1e20 value with 18 decimals.
 120 |     |     function decreaseLiquidity(DecreaseLiquidityParams calldata params)
 121 |     |         external
 122 |     |         payable
 123 |     |         returns (uint256 amount0, uint256 amount1);
 124 |     | 
 125 |     |     struct CollectParams {
 126 |     |         uint256 tokenId;
 127 |     |         address recipient;
 128 |     |         uint128 amount0Max;
 129 |     |         uint128 amount1Max;
 130 |     |     }
 131 |     | 
 132 |     |     /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
 133 |     |     /// @notice Used to update staked positions before deposit and withdraw
 134 |     |     /// @param params tokenId The ID of the NFT for which tokens are being collected,
 135 |     |     /// recipient The account that should receive the tokens,
 136 |     |     /// amount0Max The maximum amount of token0 to collect,
 137 |     |     /// amount1Max The maximum amount of token1 to collect
 138 |     |     /// @return amount0 The amount of fees collected in token0
 139 |     |     /// @return amount1 The amount of fees collected in token1
 140 |     |     //audit can I collect on another user behalf ? 
 141 |     |     function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);
 142 |     | 
 143 |     |     /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
 144 |     |     /// must be collected first.
 145 |     |     /// @param tokenId The ID of the token that is being burned
 146 |     |     //audit Invariant: liquidity SHOULD be 0 AND collect() SHOULD have been called before.
 147 |     |     function burn(uint256 tokenId) external payable;
 148 |     | 
 149 |     |     /// @notice Sets a new Token Descriptor
 150 |     |     /// @param _tokenDescriptor Address of the new Token Descriptor to be chosen
 151 |     |     function setTokenDescriptor(address _tokenDescriptor) external;
 152 |     | 
 153 |     |     /// @notice Sets a new Owner address
 154 |     |     /// @param _owner Address of the new Owner to be chosen
 155 |     |     function setOwner(address _owner) external;
 156 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/IVeloPool.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | interface IVeloPool {
   5 |     |     /// @notice The contract that deployed the pool, which must adhere to the IPancakeV3Factory interface
   6 |     |     /// @return The contract address
   7 |     |     function factory() external view returns (address);
   8 |     | 
   9 |     |     /// @notice The first of the two tokens of the pool, sorted by address
  10 |     |     /// @return The token contract address
  11 |     |     function token0() external view returns (address);
  12 |     | 
  13 |     |     /// @notice The second of the two tokens of the pool, sorted by address
  14 |     |     /// @return The token contract address
  15 |     |     function token1() external view returns (address);
  16 |     | 
  17 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
  18 |     |     /// @return The fee
  19 |     |     function fee() external view returns (uint24);
  20 |     | 
  21 |     |     /// @notice The pool tick spacing
  22 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
  23 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
  24 |     |     /// This value is an int24 to avoid casting even though it is always positive.
  25 |     |     /// @return The tick spacing
  26 |     |     function tickSpacing() external view returns (int24);
  27 |     | 
  28 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
  29 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
  30 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
  31 |     |     /// @return The max amount of liquidity per tick
  32 |     |     function maxLiquidityPerTick() external view returns (uint128);
  33 |     | 
  34 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
  35 |     |     /// when accessed externally.
  36 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  37 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  38 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  39 |     |     /// boundary.
  40 |     |     /// observationIndex The index of the last oracle observation that was written,
  41 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  42 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  43 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  44 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  45 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  46 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  47 |     |     function slot0()
  48 |     |         external
  49 |     |         view
  50 |     |         returns (
  51 |     |             uint160 sqrtPriceX96,
  52 |     |             int24 tick,
  53 |     |             uint16 observationIndex,
  54 |     |             uint16 observationCardinality,
  55 |     |             uint16 observationCardinalityNext,
  56 |     |             bool unlocked
  57 |     |         );
  58 |     | 
  59 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  60 |     |     /// @dev This value can overflow the uint256
  61 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  62 |     | 
  63 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  64 |     |     /// @dev This value can overflow the uint256
  65 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  66 |     | 
  67 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  68 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  69 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  70 |     | 
  71 |     |     /// @notice The currently in range liquidity available to the pool
  72 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  73 |     |     function liquidity() external view returns (uint128);
  74 |     | 
  75 |     |     /// @notice Look up information about a specific tick in the pool
  76 |     |     /// @param tick The tick to look up
  77 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  78 |     |     /// tick upper,
  79 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  80 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  81 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  82 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  83 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  84 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  85 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  86 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  87 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  88 |     |     /// a specific position.
  89 |     |     function ticks(int24 tick)
  90 |     |         external
  91 |     |         view
  92 |     |         returns (
  93 |     |             uint128 liquidityGross,
  94 |     |             int128 liquidityNet,
  95 |     |             uint256 feeGrowthOutside0X128,
  96 |     |             uint256 feeGrowthOutside1X128,
  97 |     |             int56 tickCumulativeOutside,
  98 |     |             uint160 secondsPerLiquidityOutsideX128,
  99 |     |             uint32 secondsOutside,
 100 |     |             bool initialized
 101 |     |         );
 102 |     | 
 103 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
 104 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
 105 |     | 
 106 |     |     /// @notice Returns the information about a position by the position's key
 107 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
 108 |     |     /// @return _liquidity The amount of liquidity in the position,
 109 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
 110 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
 111 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
 112 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
 113 |     |     function positions(bytes32 key)
 114 |     |         external
 115 |     |         view
 116 |     |         returns (
 117 |     |             uint128 _liquidity,
 118 |     |             uint256 feeGrowthInside0LastX128,
 119 |     |             uint256 feeGrowthInside1LastX128,
 120 |     |             uint128 tokensOwed0,
 121 |     |             uint128 tokensOwed1
 122 |     |         );
 123 |     | 
 124 |     |     /// @notice Returns data about a specific observation index
 125 |     |     /// @param index The element of the observations array to fetch
 126 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 127 |     |     /// ago, rather than at a specific index in the array.
 128 |     |     /// @return blockTimestamp The timestamp of the observation,
 129 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 130 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 131 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 132 |     |     function observations(uint256 index)
 133 |     |         external
 134 |     |         view
 135 |     |         returns (
 136 |     |             uint32 blockTimestamp,
 137 |     |             int56 tickCumulative,
 138 |     |             uint160 secondsPerLiquidityCumulativeX128,
 139 |     |             bool initialized
 140 |     |         );
 141 |     | 
 142 |     |     /// @notice Collects tokens owed to a position
 143 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
 144 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
 145 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
 146 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
 147 |     |     /// @param recipient The address which should receive the fees collected
 148 |     |     /// @param tickLower The lower tick of the position for which to collect fees
 149 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
 150 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
 151 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
 152 |     |     /// @return amount0 The amount of fees collected in token0
 153 |     |     /// @return amount1 The amount of fees collected in token1
 154 |     |     function collect(
 155 |     |         address recipient,
 156 |     |         int24 tickLower,
 157 |     |         int24 tickUpper,
 158 |     |         uint128 amount0Requested,
 159 |     |         uint128 amount1Requested
 160 |     |     ) external returns (uint128 amount0, uint128 amount1);
 161 |     | 
 162 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
 163 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
 164 |     |     /// @dev Fees must be collected separately via a call to #collect
 165 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
 166 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
 167 |     |     /// @param amount How much liquidity to burn
 168 |     |     /// @return amount0 The amount of token0 sent to the recipient
 169 |     |     /// @return amount1 The amount of token1 sent to the recipient
 170 |     |     function burn(
 171 |     |         int24 tickLower,
 172 |     |         int24 tickUpper,
 173 |     |         uint128 amount
 174 |     |     ) external returns (uint256 amount0, uint256 amount1);
 175 |     | 
 176 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
 177 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
 178 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
 179 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
 180 |     |     /// @param recipient The address for which the liquidity will be created
 181 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
 182 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
 183 |     |     /// @param amount The amount of liquidity to mint
 184 |     |     /// @param data Any data that should be passed through to the callback
 185 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
 186 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
 187 |     |     function mint(
 188 |     |         address recipient,
 189 |     |         int24 tickLower,
 190 |     |         int24 tickUpper,
 191 |     |         uint128 amount,
 192 |     |         bytes calldata data
 193 |     |     ) external returns (uint256 amount0, uint256 amount1);
 194 |     | 
 195 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
 196 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 197 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 198 |     |     /// you must call it with secondsAgos = [3600, 0].
 199 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 200 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 201 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 202 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 203 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 204 |     |     /// timestamp
 205 |     |     function observe(uint32[] calldata secondsAgos)
 206 |     |         external
 207 |     |         view
 208 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 209 |     | 
 210 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext)
 211 |     |         external;
 212 |     | 
 213 |     |     
 214 |     | 
 215 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/IVeloRouter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | interface IVeloRouter {
  5 |     |         struct Route {
  6 |     |             address from;
  7 |     |             address to;
  8 |     |             bool stable;
  9 |     |             address factory;
 10 |     |         }
 11 |     |         
 12 |     |         function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external;
 13 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/rewardpool/BeefyRewardPool.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.23;
   4 |     | 
   5 |     | import { ERC20Upgradeable } from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
   6 |     | import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
   7 |     | import { SafeERC20Upgradeable, IERC20Upgradeable, IERC20PermitUpgradeable } from "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
   8 |     | 
   9 |     | /// @title Reward pool for BIFI
  10 |     | /// @author kexley, Beefy
  11 |     | /// @notice Multi-reward staking contract for BIFI
  12 |     | /// @dev Multiple rewards can be added to this contract by the owner. A receipt token is issued for 
  13 |     | /// staking and is used for withdrawing the staked BIFI.
  14 | *   | contract BeefyRewardPool is ERC20Upgradeable, OwnableUpgradeable {
  15 |     |     using SafeERC20Upgradeable for IERC20Upgradeable;
  16 |     | 
  17 |     |     /// @dev Information for a particular reward
  18 |     |     /// @param periodFinish End timestamp of reward distribution
  19 |     |     /// @param duration Distribution length of time in seconds
  20 |     |     /// @param lastUpdateTime Latest timestamp of an update
  21 |     |     /// @param rate Distribution speed in wei per second
  22 |     |     /// @param rewardPerTokenStored Stored reward value per staked token in 18 decimals
  23 |     |     /// @param userRewardPerTokenPaid Stored reward value per staked token in 18 decimals at the 
  24 |     |     /// last time a user was paid the reward
  25 |     |     /// @param earned Value of reward still owed to the user
  26 |     |     struct RewardInfo {
  27 |     |         uint256 periodFinish;
  28 |     |         uint256 duration;
  29 |     |         uint256 lastUpdateTime;
  30 |     |         uint256 rate;
  31 |     |         uint256 rewardPerTokenStored;
  32 |     |         mapping(address => uint256) userRewardPerTokenPaid;
  33 |     |         mapping(address => uint256) earned;
  34 |     |     }
  35 |     | 
  36 |     |     /// @notice BIFI token address
  37 |     |     IERC20Upgradeable public stakedToken;
  38 |     | 
  39 |     |     /// @notice Array of reward addresses
  40 |     |     address[] public rewards;
  41 |     | 
  42 |     |     /// @notice Whitelist of manager addresses
  43 |     |     mapping(address => bool) public whitelisted;
  44 |     | 
  45 |     |     /// @dev Limit to the number of rewards an owner can add
  46 |     |     uint256 private rewardMax;
  47 |     | 
  48 |     |     /// @dev Location of a reward in the reward array
  49 |     |     mapping(address => uint256) private _index;
  50 |     | 
  51 |     |     /// @dev Each reward address has a new unique identifier each time it is initialized. This is 
  52 |     |     /// to prevent old mappings from being reused when removing and re-adding a reward.
  53 |     |     mapping(address => bytes32) private _id;
  54 |     | 
  55 |     |     /// @dev Each identifier relates to reward information
  56 |     |     mapping(bytes32 => RewardInfo) private _rewardInfo;
  57 |     | 
  58 |     |     /// @notice User has staked an amount
  59 |     |     event Staked(address indexed user, uint256 amount);
  60 |     |     /// @notice User has withdrawn an amount
  61 |     |     event Withdrawn(address indexed user, uint256 amount);
  62 |     |     /// @notice A reward has been paid to the user
  63 |     |     event RewardPaid(address indexed user, address indexed reward, uint256 amount);
  64 |     |     /// @notice A new reward has been added to be distributed
  65 |     |     event AddReward(address reward);
  66 |     |     /// @notice More of an existing reward has been added to be distributed
  67 |     |     event NotifyReward(address indexed reward, uint256 amount, uint256 duration);
  68 |     |     /// @notice A reward has been removed from distribution and sent to the recipient
  69 |     |     event RemoveReward(address reward, address recipient);
  70 |     |     /// @notice The owner has removed tokens that are not supported by this contract
  71 |     |     event RescueTokens(address token, address recipient);
  72 |     |     /// @notice An address has been added to or removed from the whitelist
  73 |     |     event SetWhitelist(address manager, bool whitelist);
  74 |     | 
  75 |     |     /// @notice Caller is not a manager
  76 |     |     error NotManager(address caller);
  77 |     |     /// @notice The staked token cannot be added as a reward
  78 |     |     error StakedTokenIsNotAReward();
  79 |     |     /// @notice The duration is too short to be set
  80 |     |     error ShortDuration(uint256 duration);
  81 |     |     /// @notice There are already too many rewards
  82 |     |     error TooManyRewards();
  83 |     |     /// @notice The reward has not been found in the array
  84 |     |     error RewardNotFound(address reward);
  85 |     |     /// @notice The owner cannot withdraw the staked token
  86 |     |     error WithdrawingStakedToken();
  87 |     |     /// @notice the owner cannot withdraw an existing reward without first removing it from the array
  88 |     |     error WithdrawingRewardToken(address reward);
  89 |     | 
  90 |     |     /// @dev Triggers reward updates on every user interaction
  91 |     |     /// @param _user Address of the user making an interaction
  92 |     |     modifier update(address _user) {
  93 |     |         _update(_user);
  94 |     |         _;
  95 |     |     }
  96 |     | 
  97 |     |     /// @dev Only a manager can call these modified functions
  98 |     |     modifier onlyManager {
  99 |     |         if (!whitelisted[msg.sender]) revert NotManager(msg.sender);
 100 |     |         _;
 101 |     |     }
 102 |     | 
 103 |     |     /* ---------------------------------- EXTERNAL FUNCTIONS ---------------------------------- */
 104 |     | 
 105 |     |     /// @notice Initialize the contract, callable only once
 106 |     |     /// @param _stakedToken BIFI token address
 107 | *   |     function initialize(address _stakedToken, string calldata _name, string calldata _symbol) external initializer {
 108 | *   |         __ERC20_init(_name, _symbol);
 109 | *   |         __Ownable_init();
 110 | *   |         stakedToken = IERC20Upgradeable(_stakedToken);
 111 | *   |         rewardMax = 100;
 112 |     |     }
 113 |     | 
 114 |     |     /// @notice Stake BIFI tokens
 115 |     |     /// @dev An equal number of receipt tokens will be minted to the caller
 116 |     |     /// @param _amount Amount of BIFI to stake
 117 |     |     function stake(uint256 _amount) external update(msg.sender) {
 118 |     |         _stake(msg.sender, _amount);
 119 |     |     }
 120 |     | 
 121 |     |     /// @notice Stake BIFI tokens with a permit
 122 |     |     /// @dev An equal number of receipt tokens will be minted to the caller
 123 |     |     /// @param _user User to stake for
 124 |     |     /// @param _amount Amount of BIFI to stake
 125 |     |     /// @param _deadline Timestamp of the deadline after which the permit is invalid
 126 |     |     /// @param _v Part of a signature
 127 |     |     /// @param _r Part of a signature
 128 |     |     /// @param _s Part of a signature
 129 |     |     function stakeWithPermit(
 130 |     |         address _user,
 131 |     |         uint256 _amount,
 132 |     |         uint256 _deadline,
 133 |     |         uint8 _v,
 134 |     |         bytes32 _r,
 135 |     |         bytes32 _s
 136 |     |     ) external update(_user) {
 137 |     |         IERC20PermitUpgradeable(address(stakedToken)).permit(
 138 |     |             _user, address(this), _amount, _deadline, _v, _r, _s
 139 |     |         );
 140 |     |         _stake(_user, _amount);
 141 |     |     }
 142 |     | 
 143 |     |     /// @notice Withdraw BIFI tokens
 144 |     |     /// @dev Burns an equal number of receipt tokens from the caller
 145 |     |     /// @param _amount Amount of BIFI to withdraw
 146 | *   |     function withdraw(uint256 _amount) external update(msg.sender) {
 147 | *   |         _withdraw(_amount);
 148 |     |     }
 149 |     | 
 150 |     |     /// @notice Withdraw all of the caller's BIFI tokens and claim rewards
 151 |     |     /// @dev Burns all receipt tokens owned by the caller
 152 |     |     function exit() external update(msg.sender) {
 153 |     |         _withdraw(balanceOf(msg.sender));
 154 |     |         _getReward();
 155 |     |     }
 156 |     | 
 157 |     |     /// @notice Claim all the caller's earned rewards 
 158 |     |     function getReward() external update(msg.sender) {
 159 |     |         _getReward();
 160 |     |     }
 161 |     | 
 162 |     |     /// @notice View the amount of rewards earned by the user
 163 |     |     /// @param _user User to view the earned rewards for
 164 |     |     /// @return rewardTokens Address array of the rewards
 165 |     |     /// @return earnedAmounts Amounts of the user's earned rewards
 166 |     |     function earned(address _user) external view returns (
 167 |     |         address[] memory rewardTokens,
 168 |     |         uint256[] memory earnedAmounts
 169 |     |     ) {
 170 |     |         uint256 rewardLength = rewards.length;
 171 |     |         uint256[] memory amounts = new uint256[](rewardLength);
 172 |     |         for (uint i; i < rewardLength;) {
 173 |     |             amounts[i] = _earned(_user, rewards[i]);
 174 |     |             unchecked { ++i; }
 175 |     |         }
 176 |     |         earnedAmounts = amounts;
 177 |     |         rewardTokens = rewards;
 178 |     |     }
 179 |     | 
 180 |     |     /// @notice View the amount of a single reward earned by the user
 181 |     |     /// @param _user User to view the earned reward for
 182 |     |     /// @param _reward Reward to calculate the earned amount for
 183 |     |     /// @return earnedAmount Amount of the user's earned reward
 184 |     |     function earned(address _user, address _reward) external view returns (uint256 earnedAmount) {
 185 |     |         earnedAmount = _earned(_user, _reward);
 186 |     |     }
 187 |     | 
 188 |     |     /// @notice View the reward information
 189 |     |     /// @dev The active reward information is automatically selected from the id mapping
 190 |     |     /// @param _rewardId Index of the reward in the array to get the information for
 191 |     |     /// @return reward Address of the reward
 192 |     |     /// @return periodFinish End timestamp of reward distribution
 193 |     |     /// @return duration Distribution length of time in seconds
 194 |     |     /// @return lastUpdateTime Latest timestamp of an update
 195 |     |     /// @return rate Distribution speed in wei per second
 196 |     |     function rewardInfo(uint256 _rewardId) external view returns (
 197 |     |         address reward,
 198 |     |         uint256 periodFinish,
 199 |     |         uint256 duration,
 200 |     |         uint256 lastUpdateTime,
 201 |     |         uint256 rate
 202 |     |     ) {
 203 |     |         reward = rewards[_rewardId];
 204 |     |         RewardInfo storage info = _getRewardInfo(reward);
 205 |     |         (periodFinish, duration, lastUpdateTime, rate) =
 206 |     |             (info.periodFinish, info.duration, info.lastUpdateTime, info.rate);
 207 |     |     }
 208 |     | 
 209 |     |     /* ------------------------------- ERC20 OVERRIDE FUNCTIONS ------------------------------- */
 210 |     | 
 211 |     |     /// @notice Update rewards for both source and recipient and then transfer receipt tokens to 
 212 |     |     /// the recipient address
 213 |     |     /// @dev Overrides the ERC20 implementation to add the reward update
 214 |     |     /// @param _to Recipient address of the token transfer
 215 |     |     /// @param _value Amount to transfer
 216 |     |     /// @return success Transfer was successful or not
 217 |     |     function transfer(address _to, uint256 _value) public override returns (bool success) {
 218 |     |         _update(msg.sender);
 219 |     |         _update(_to);
 220 |     |         return super.transfer(_to, _value);
 221 |     |     }
 222 |     | 
 223 |     |     /// @notice Update rewards for both source and recipient and then transfer receipt tokens from
 224 |     |     /// the source address to the recipient address
 225 |     |     /// @dev Overrides the ERC20 implementation to add the reward update
 226 |     |     /// @param _from Source address of the token transfer
 227 |     |     /// @param _to Recipient address of the token transfer
 228 |     |     /// @param _value Amount to transfer
 229 |     |     /// @return success Transfer was successful or not
 230 |     |     function transferFrom(
 231 |     |         address _from,
 232 |     |         address _to,
 233 |     |         uint256 _value
 234 |     |     ) public override returns (bool success) {
 235 |     |         _update(_from);
 236 |     |         _update(_to);
 237 |     |         return super.transferFrom(_from, _to, _value);
 238 |     |     }
 239 |     | 
 240 |     |     /* ----------------------------------- OWNER FUNCTIONS ------------------------------------ */
 241 |     | 
 242 |     |     /// @notice Manager function to start a reward distribution
 243 |     |     /// @dev Must approve this contract to spend the reward amount before calling this function. 
 244 |     |     /// New rewards will be assigned a id using their address and the block timestamp.
 245 |     |     /// @param _reward Address of the reward
 246 |     |     /// @param _amount Amount of reward
 247 |     |     /// @param _duration Duration of the reward distribution in seconds
 248 |     |     function notifyRewardAmount(
 249 |     |         address _reward,
 250 |     |         uint256 _amount,
 251 |     |         uint256 _duration
 252 |     |     ) external onlyManager update(address(0)) {
 253 |     |         if (_reward == address(stakedToken)) revert StakedTokenIsNotAReward();
 254 |     |         if (_duration < 1 hours) revert ShortDuration(_duration);
 255 |     | 
 256 |     |         if (!_rewardExists(_reward)) {
 257 |     |             _id[_reward] = keccak256(abi.encodePacked(_reward, block.timestamp));
 258 |     |             uint256 rewardLength = rewards.length;
 259 |     |             if (rewards.length + 1 > rewardMax) revert TooManyRewards();
 260 |     |             _index[_reward] = rewardLength;
 261 |     |             rewards.push(_reward);
 262 |     |             emit AddReward(_reward);
 263 |     |         }
 264 |     | 
 265 |     |         IERC20Upgradeable(_reward).safeTransferFrom(msg.sender, address(this), _amount);
 266 |     | 
 267 |     |         RewardInfo storage rewardData = _getRewardInfo(_reward);
 268 |     |         uint256 leftover;
 269 |     | 
 270 |     |         if (block.timestamp < rewardData.periodFinish) {
 271 |     |             uint256 remaining = rewardData.periodFinish - block.timestamp;
 272 |     |             leftover = remaining * rewardData.rate;
 273 |     |         }
 274 |     | 
 275 |     |         rewardData.rate = (_amount + leftover) / _duration;
 276 |     |         rewardData.lastUpdateTime = block.timestamp;
 277 |     |         rewardData.periodFinish = block.timestamp + _duration;
 278 |     |         rewardData.duration = _duration;
 279 |     | 
 280 |     |         emit NotifyReward(_reward, _amount, _duration);
 281 |     |     }
 282 |     | 
 283 |     |     /// @notice Owner function to remove a reward from this contract
 284 |     |     /// @dev All unclaimed earnings are ignored. Re-adding the reward will have a new set of
 285 |     |     /// reward information so any unclaimed earnings cannot be recovered
 286 |     |     /// @param _reward Address of the reward to be removed
 287 |     |     /// @param _recipient Address of the recipient that the removed reward was sent to
 288 | *   |     function removeReward(address _reward, address _recipient) external onlyOwner {
 289 |     |         if (!_rewardExists(_reward)) revert RewardNotFound(_reward);
 290 |     | 
 291 |     |         uint256 replacedIndex = _index[_reward];
 292 |     |         address endToken = rewards[rewards.length - 1];
 293 |     |         rewards[replacedIndex] = endToken;
 294 |     |         _index[endToken] = replacedIndex;
 295 |     |         rewards.pop();
 296 |     | 
 297 |     |         uint256 rewardBal = IERC20Upgradeable(_reward).balanceOf(address(this));
 298 |     |         IERC20Upgradeable(_reward).safeTransfer(_recipient, rewardBal);
 299 |     | 
 300 |     |         emit RemoveReward(_reward, _recipient);
 301 |     |     }
 302 |     | 
 303 |     |     /// @notice Owner function to remove unsupported tokens sent to this contract
 304 |     |     /// @param _token Address of the token to be removed
 305 |     |     /// @param _recipient Address of the recipient that the removed token was sent to
 306 |     |     function rescueTokens(address _token, address _recipient) external onlyOwner {
 307 |     |         if (_token == address(stakedToken)) revert WithdrawingStakedToken();
 308 |     |         if (_rewardExists(_token)) revert WithdrawingRewardToken(_token);
 309 |     | 
 310 |     |         uint256 amount = IERC20Upgradeable(_token).balanceOf(address(this));
 311 |     |         IERC20Upgradeable(_token).safeTransfer(_recipient, amount);
 312 |     |         emit RescueTokens(_token, _recipient);
 313 |     |     }
 314 |     | 
 315 |     |     /// @notice Owner function to add addresses to the whitelist
 316 |     |     /// @param _manager Address able to call manager functions
 317 |     |     /// @param _whitelisted Whether to add or remove from whitelist
 318 |     |     function setWhitelist(address _manager, bool _whitelisted) external onlyOwner {
 319 |     |         whitelisted[_manager] = _whitelisted;
 320 |     |         emit SetWhitelist(_manager, _whitelisted);
 321 |     |     }
 322 |     | 
 323 |     |     /* ---------------------------------- INTERNAL FUNCTIONS ---------------------------------- */
 324 |     | 
 325 |     |     /// @dev Update the rewards and earnings for a user
 326 |     |     /// @param _user Address to update the earnings for
 327 |     |     function _update(address _user) private {
 328 |     |         uint256 rewardLength = rewards.length;
 329 |     |         for (uint i; i < rewardLength;) {
 330 |     |             address reward = rewards[i];
 331 |     |             RewardInfo storage rewardData = _getRewardInfo(reward);
 332 |     |             rewardData.rewardPerTokenStored = _rewardPerToken(reward);
 333 |     |             rewardData.lastUpdateTime = _lastTimeRewardApplicable(rewardData.periodFinish);
 334 |     |             if (_user != address(0)) {
 335 |     |                 rewardData.earned[_user] = _earned(_user, reward);
 336 |     |                 rewardData.userRewardPerTokenPaid[_user] = rewardData.rewardPerTokenStored;
 337 |     |             }
 338 |     |             unchecked { ++i; } 
 339 |     |         }
 340 |     |     }
 341 |     | 
 342 |     |     /// @dev Stake BIFI tokens and mint the caller receipt tokens
 343 |     |     /// @param _user Address of the user to stake for
 344 |     |     /// @param _amount Amount of BIFI to stake
 345 |     |     function _stake(address _user, uint256 _amount) private {
 346 |     |         _mint(_user, _amount);
 347 |     |         stakedToken.safeTransferFrom(_user, address(this), _amount);
 348 |     |         emit Staked(msg.sender, _amount);
 349 |     |     }
 350 |     | 
 351 |     |     /// @dev Withdraw BIFI tokens and burn an equal number of receipt tokens from the caller
 352 |     |     /// @param _amount Amount of BIFI to withdraw
 353 |     |     
 354 |     |     function _withdraw(uint256 _amount) private {
 355 |     |         _burn(msg.sender, _amount);
 356 |     |         stakedToken.safeTransfer(msg.sender, _amount);
 357 |     |         emit Withdrawn(msg.sender, _amount);
 358 |     |     }
 359 |     | 
 360 |     |     /// @dev Claim all the caller's earned rewards 
 361 |     |     function _getReward() private {
 362 |     |         uint256 rewardLength = rewards.length;
 363 |     |         for (uint i; i < rewardLength;) {
 364 |     |             address reward = rewards[i];
 365 |     |             uint256 rewardEarned = _earned(msg.sender, reward);
 366 |     |             if (rewardEarned > 0) {
 367 |     |                 _getRewardInfo(reward).earned[msg.sender] = 0;
 368 |     |                 _rewardTransfer(reward, msg.sender, rewardEarned);
 369 |     |                 emit RewardPaid(msg.sender, reward, rewardEarned);
 370 |     |             }
 371 |     |             unchecked { ++i; }
 372 |     |         }
 373 |     |     }
 374 |     | 
 375 |     |     /// @dev Return either the period finish or the current timestamp, whichever is earliest
 376 |     |     /// @param _periodFinish End timestamp of the reward distribution
 377 |     |     /// @return timestamp Earliest timestamp out of the period finish or block timestamp 
 378 |     |     function _lastTimeRewardApplicable(uint256 _periodFinish) private view returns (uint256 timestamp) {
 379 |     |         timestamp = block.timestamp > _periodFinish ? _periodFinish : block.timestamp;
 380 |     |     }
 381 |     | 
 382 |     |     /// @dev Calculate the reward amount per BIFI token
 383 |     |     /// @param _reward Address of the reward
 384 |     |     /// @return rewardPerToken Reward amount per BIFI token
 385 | *   |     function _rewardPerToken(address _reward) private view returns (uint256 rewardPerToken) {
 386 |     |         RewardInfo storage rewardData = _getRewardInfo(_reward);
 387 | *   |         if (totalSupply() == 0) {
 388 |     |             rewardPerToken = rewardData.rewardPerTokenStored;
 389 |     |         } else {
 390 |     |             rewardPerToken = rewardData.rewardPerTokenStored + (
 391 |     |                 (_lastTimeRewardApplicable(rewardData.periodFinish) - rewardData.lastUpdateTime) 
 392 |     |                 * rewardData.rate
 393 |     |                 * 1e18 
 394 |     |                 / totalSupply()
 395 |     |             );
 396 |     |         }
 397 |     |     }
 398 |     | 
 399 |     |     /// @dev Calculate the reward amount earned by the user
 400 |     |     /// @param _user Address of the user
 401 |     |     /// @param _reward Address of the reward
 402 |     |     /// @return earnedAmount Amount of reward earned by the user
 403 |     |     function _earned(address _user, address _reward) private view returns (uint256 earnedAmount) {
 404 |     |         RewardInfo storage rewardData = _getRewardInfo(_reward);
 405 |     |         earnedAmount = rewardData.earned[_user] + (
 406 |     |             balanceOf(_user) * 
 407 |     |             (_rewardPerToken(_reward) - rewardData.userRewardPerTokenPaid[_user]) 
 408 |     |             / 1e18
 409 |     |         );
 410 |     |     }
 411 |     | 
 412 |     |     /// @dev Return the most current reward information for a reward
 413 |     |     /// @param _reward Address of the reward
 414 |     |     /// @return info Reward information for the reward
 415 |     |     function _getRewardInfo(address _reward) private view returns(RewardInfo storage info) {
 416 |     |         info = _rewardInfo[_id[_reward]];
 417 |     |     }
 418 |     | 
 419 |     |     /// @dev Check if a reward exists in the reward array already
 420 |     |     /// @param _reward Address of the reward
 421 |     |     /// @return exists Returns true if token is in the array
 422 | *   |     function _rewardExists(address _reward) private view returns (bool exists) {
 423 | *   |         if (rewards.length > 0) exists = _reward == rewards[_index[_reward]];
 424 |     |     }
 425 |     | 
 426 |     |     /// @dev Transfer at most the balance of the reward on this contract to avoid errors
 427 |     |     /// @param _reward Address of the reward
 428 |     |     /// @param _recipient Address of the recipient of the reward
 429 |     |     /// @param _amount Amount of the reward to be sent to the recipient
 430 |     |     function _rewardTransfer(address _reward, address _recipient, uint256 _amount) private {
 431 |     |         uint256 rewardBal = IERC20Upgradeable(_reward).balanceOf(address(this));
 432 |     |         if (_amount > rewardBal) _amount = rewardBal;
 433 |     |         if (_amount > 0) IERC20Upgradeable(_reward).safeTransfer(_recipient, _amount);
 434 |     |     }
 435 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/rewardpool/BeefyRewardPoolFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | import {BeefyRewardPool} from "./BeefyRewardPool.sol";
  5 |     | import {ClonesUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol";
  6 |     | 
  7 |     | // Beefy Reward Pool Proxy Factory
  8 |     | // Minimal proxy pattern for creating new Beefy concentrated liquidity reward pools
  9 | *   | contract BeefyRewardPoolFactory {
 10 |     |   using ClonesUpgradeable for address;
 11 |     | 
 12 |     |   /// @notice Contract template for deploying proxied Beefy Reward Pools
 13 | *   |   BeefyRewardPool public instance;
 14 |     | 
 15 |     |   /// @notice Emitted when a new Beefy Reward Pool is created
 16 |     |   event ProxyCreated(address proxy);
 17 |     | 
 18 |     |   /** 
 19 |     |    * @notice Constructor initializes the Beefy Reward Pool template instance
 20 |     |    * @param _instance The address of the Beefy Reward Pool template instance
 21 |     |    */
 22 |     |   constructor(address _instance) {
 23 |     |     if (_instance == address(0)) {
 24 |     |       instance = new BeefyRewardPool();
 25 |     |     } else {
 26 |     |       instance = BeefyRewardPool(_instance);
 27 |     |     }
 28 |     |   }
 29 |     | 
 30 |     |   /**
 31 |     |    * @notice Create a new Beefy Reward Pool as a proxy of the template instance
 32 |     |    * @return A reference to the new proxied Beefy Reward Pool
 33 |     |    */
 34 | *   |   function cloneRewardPool(
 35 | *   |   ) external returns (BeefyRewardPool) {
 36 | *   |     BeefyRewardPool vault = BeefyRewardPool(_cloneContract(address(instance)));
 37 |     |     return vault;
 38 |     |   }
 39 |     | 
 40 |     |   /**
 41 |     |    * Deploys and returns the address of a clone that mimics the behaviour of `implementation`
 42 |     |    * @param implementation The address of the contract to clone
 43 |     |    * @return The address of the newly created clone
 44 |     |   */
 45 | *   |   function _cloneContract(address implementation) private returns (address) {
 46 | *   |     address proxy = implementation.clone();
 47 | *   |     emit ProxyCreated(proxy);
 48 | *   |     return proxy;
 49 |     |   }
 50 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/strategies/StratFeeManagerInitializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.23;
   4 |     | 
   5 |     | import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
   6 |     | import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
   7 |     | import {IFeeConfig} from "../interfaces/beefy/IFeeConfig.sol";
   8 |     | import {IStrategyFactory} from "../interfaces/beefy/IStrategyFactory.sol";
   9 |     | 
  10 |     | contract StratFeeManagerInitializable is OwnableUpgradeable, PausableUpgradeable {
  11 |     |     struct CommonAddresses {
  12 |     |         address vault;
  13 |     |         address unirouter;
  14 |     |         address strategist;
  15 |     |         address factory;
  16 |     |     }
  17 |     | 
  18 |     |     /// @notice The native address of the chain
  19 |     |     address public native;
  20 |     | 
  21 |     |     /// @notice The address of the vault
  22 |     |     address public vault;
  23 |     | 
  24 |     |     /// @notice The address of the unirouter
  25 |     |     address public unirouter;
  26 |     | 
  27 |     |     /// @notice The address of the strategist
  28 |     |     address public strategist;
  29 |     | 
  30 |     |     /// @notice The address of the strategy factory
  31 |     |     IStrategyFactory public factory;
  32 |     | 
  33 |     |     /// @notice The total amount of token0 locked in the vault
  34 |     |     uint256 public totalLocked0;
  35 |     | 
  36 |     |     /// @notice The total amount of token1 locked in the vault
  37 |     |     uint256 public totalLocked1;
  38 |     | 
  39 |     |     /// @notice The last time the strat harvested
  40 |     |     uint256 public lastHarvest;
  41 |     | 
  42 |     |     /// @notice The duration of the locked rewards
  43 |     |     uint256 constant DURATION = 1 hours;
  44 |     | 
  45 |     |     /// @notice The divisor used to calculate the fee
  46 |     |     uint256 constant DIVISOR = 1 ether;
  47 |     | 
  48 |     | 
  49 |     |     // Events
  50 |     |     event SetStratFeeId(uint256 feeId);
  51 |     |     event SetUnirouter(address unirouter);
  52 |     |     event SetStrategist(address strategist);
  53 |     | 
  54 |     |     // Errors
  55 |     |     error NotManager();
  56 |     |     error NotStrategist();
  57 |     |     error OverLimit();
  58 |     |     error StrategyPaused();
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice Initialize the Strategy Fee Manager inherited contract with the common addresses
  62 |     |      * @param _commonAddresses The common addresses of the vault, unirouter, keeper, strategist, beefyFeeRecipient and beefyFeeConfig
  63 |     |      */
  64 | *   |     function __StratFeeManager_init(CommonAddresses calldata _commonAddresses) internal onlyInitializing {
  65 | *   |         __Ownable_init();
  66 | *   |         __Pausable_init();
  67 | *   |         vault = _commonAddresses.vault;
  68 | *   |         unirouter = _commonAddresses.unirouter;
  69 | *   |         strategist = _commonAddresses.strategist;
  70 | *   |         factory = IStrategyFactory(_commonAddresses.factory);
  71 | *   |         native = factory.native();
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice function that throws if the strategy is paused
  76 |     |      */
  77 |     |     function _whenStrategyNotPaused() internal view {
  78 |     |         if (paused() || factory.globalPause()) revert StrategyPaused();
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice function that returns true if the strategy is paused
  83 |     |      */
  84 |     | 
  85 |     |     function _isPaused() internal view returns (bool) {
  86 |     |         return paused() || factory.globalPause();
  87 |     |     }
  88 |     | 
  89 |     |     /** 
  90 |     |      * @notice Modifier that throws if called by any account other than the manager or the owner
  91 |     |     */
  92 |     |     //audit Can the keeper be changed ?  @mody: only through the setkeeper in the factory. protected with onlyowner modifier
  93 |     |     modifier onlyManager() {
  94 |     |         if (msg.sender != owner() && msg.sender != keeper()) revert NotManager();
  95 |     |         _;
  96 |     |     }
  97 |     | 
  98 |     |     /// @notice The address of the keeper, set on the factory. 
  99 |     |     function keeper() public view returns (address) {
 100 |     |         return factory.keeper();
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice The address of the beefy fee recipient, set on the factory.
 104 |     |     function beefyFeeRecipient() public view returns (address) {
 105 |     |         return factory.beefyFeeRecipient();
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice The address of the beefy fee config, set on the factory.
 109 |     |     function beefyFeeConfig() public view returns (IFeeConfig) {
 110 |     |         return IFeeConfig(factory.beefyFeeConfig());
 111 |     |     }
 112 |     | 
 113 |     |     /**
 114 |     |      * @notice get the fees breakdown from the fee config for this contract
 115 |     |      * @return IFeeConfig.FeeCategory The fees breakdown
 116 |     |      */
 117 |     | 
 118 |     |     //audit-info What is IFeeConfig(factory.beefyFeeConfig).getFees(this);
 119 |     |     function getFees() internal view returns (IFeeConfig.FeeCategory memory) {
 120 |     |         return beefyFeeConfig().getFees(address(this));
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice get all the fees from the fee config for this contract
 125 |     |      * @return IFeeConfig.AllFees The fees
 126 |     |      */
 127 |     |      //audit depositFee(), withdrawFee() set to 0.
 128 |     |     function getAllFees() external view returns (IFeeConfig.AllFees memory) {
 129 |     |         return IFeeConfig.AllFees(getFees(), depositFee(), withdrawFee());
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @notice get the strat fee id from the fee config
 134 |     |      * @return uint256 The strat fee id
 135 |     |      */
 136 |     |     function getStratFeeId() external view returns (uint256) {
 137 |     |         return beefyFeeConfig().stratFeeId(address(this));
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @notice set the strat fee id in the fee config
 142 |     |      * @param _feeId The new strat fee id
 143 |     |      */
 144 |     |     function setStratFeeId(uint256 _feeId) external onlyManager {
 145 |     |         beefyFeeConfig().setStratFeeId(_feeId);
 146 |     |         emit SetStratFeeId(_feeId);
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @notice set the unirouter address
 151 |     |      * @param _unirouter The new unirouter address
 152 |     |      */
 153 |     |     function setUnirouter(address _unirouter) external virtual onlyOwner {
 154 |     |         unirouter = _unirouter;
 155 |     |         emit SetUnirouter(_unirouter);
 156 |     |     }
 157 |     | 
 158 |     |     /**
 159 |     |      * @notice set the strategist address
 160 |     |      * @param _strategist The new strategist address
 161 |     |      */
 162 |     |     function setStrategist(address _strategist) external {
 163 |     |         if (msg.sender != strategist) revert NotStrategist();
 164 |     |         strategist = _strategist;
 165 |     |         emit SetStrategist(_strategist);
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @notice The deposit fee variable will alwasy be 0. This is used by the UI. 
 170 |     |      * @return uint256 The deposit fee
 171 |     |      */
 172 |     |     function depositFee() public virtual view returns (uint256) {
 173 |     |         return 0;
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @notice The withdraw fee variable will alwasy be 0. This is used by the UI. 
 178 |     |      * @return uint256 The withdraw fee
 179 |     |      */
 180 |     |     function withdrawFee() public virtual view returns (uint256) {
 181 |     |         return 0;
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @notice The locked profit is the amount of token0 and token1 that is locked in the vault, this can be overriden by the strategy contract.
 186 |     |      * @return locked0 The amount of token0 locked
 187 |     |      * @return locked1 The amount of token1 locked
 188 |     |      */
 189 |     |      //audit-info Looks weird
 190 |     |     function lockedProfit() public virtual view returns (uint256 locked0, uint256 locked1) {
 191 |     |         uint256 elapsed = block.timestamp - lastHarvest;
 192 |     |         uint256 remaining = elapsed < DURATION ? DURATION - elapsed : 0;
 193 |     |         return (totalLocked0 * remaining / DURATION, totalLocked1 * remaining / DURATION);
 194 |     |     }
 195 |     | 
 196 |     |     /**
 197 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 198 |     |      * variables without shifting down storage in the inheritance chain.
 199 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 200 |     |      */
 201 |     |     uint256[49] private __gap;
 202 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/strategies/StrategyFactory.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | import {BeaconProxy} from "@openzeppelin-4/contracts/proxy/beacon/BeaconProxy.sol";
   5 |     | import {UpgradeableBeacon} from "@openzeppelin-4/contracts/proxy/beacon/UpgradeableBeacon.sol";
   6 |     | import {Ownable} from "@openzeppelin-4/contracts/access/Ownable.sol";
   7 |     | 
   8 |     | // Beefy Strategy ConcLiq Proxy Factory
   9 |     | // Minimal proxy pattern for creating new Beefy concentrated liquidity vaults
  10 | *   | contract StrategyFactory is Ownable {
  11 |     | 
  12 |     |   /// @notice instance mapping to strategy name with version. 
  13 | *   |   mapping (string => UpgradeableBeacon) public instances;
  14 |     | 
  15 |     |   /// @notice approved rebalancer mapping 
  16 |     |   mapping (address => bool) public rebalancers;
  17 |     | 
  18 |     |   /// @notice deployed strategy types
  19 |     |   string[] public strategyTypes;
  20 |     | 
  21 |     |   /// @notice The address of the native token
  22 | *   |   address public native;
  23 |     | 
  24 |     |   /// @notice The address of the keeper
  25 |     |   address public keeper;
  26 |     | 
  27 |     |   /// @notice The beefy fee recipient
  28 |     |   address public beefyFeeRecipient;
  29 |     | 
  30 |     |   /// @notice The beefy fee config
  31 |     |   address public beefyFeeConfig;
  32 |     | 
  33 |     |   /// @notice Global pause state for all strategies that use this
  34 |     |   bool public globalPause;
  35 |     | 
  36 |     |   /// @notice Emitted when a new Beefy Strategy is created
  37 |     |   event ProxyCreated(string strategyName, address proxy);
  38 |     | 
  39 |     |   /// @notice Emitted when a Beefy Strategy is upgraded
  40 |     |   event InstanceUpgraded(string strategyName, address newImplementation);
  41 |     | 
  42 |     |   /// @notice Emitted when a new Beefy Strategy is added
  43 |     |   event NewStrategyAdded(string strategyName, address implementation);
  44 |     | 
  45 |     |   /// @notice Emitted when the beefy fee recipient address is changed
  46 |     |   event SetBeefyFeeRecipient(address beefyFeeRecipient);
  47 |     | 
  48 |     |   /// @notice Emitted when the beefy fee config address is changed
  49 |     |   event SetBeefyFeeConfig(address beefyFeeConfig);
  50 |     | 
  51 |     |   /// @notice Emitted when the keeper address is changed
  52 |     |   event SetKeeper(address keeper);
  53 |     | 
  54 |     |   /// @notice Emitted when the global pause state is changed
  55 |     |   event GlobalPause(bool paused);
  56 |     | 
  57 |     |   /// @notice Emitted when a rebalancer is added or removed
  58 |     |   event RebalancerChanged(address rebalancer, bool isRebalancer);
  59 |     | 
  60 |     |   // Errors
  61 |     |   error NotManager();
  62 |     |   error StratVersionExists();
  63 |     | 
  64 |     |   /// @notice Throws if called by any account other than the owner or the keeper/
  65 |     |   modifier onlyManager() {
  66 | *   |     if (msg.sender != owner() && msg.sender != address(keeper)) revert NotManager();
  67 |     |     _;
  68 |     |   }
  69 |     | 
  70 |     |   /// @notice Constructor initializes the keeper address
  71 |     |   constructor(
  72 |     |     address _native,
  73 |     |     address _keeper,
  74 |     |     address _beefyFeeRecipient,
  75 |     |     address _beefyFeeConfig
  76 |     |   ) Ownable(msg.sender) {
  77 |     |     native = _native;
  78 |     |     keeper = _keeper;
  79 |     |     beefyFeeRecipient = _beefyFeeRecipient;
  80 |     |     beefyFeeConfig = _beefyFeeConfig;
  81 |     |   }
  82 |     | 
  83 |     |   /** @notice Creates a new Beefy Strategy as a proxy of the template instance
  84 |     |     * @param _strategyName The name of the strategy
  85 |     |     * @return A reference to the new proxied Beefy Strategy
  86 |     |    */
  87 | *   |   function createStrategy(string calldata _strategyName) external returns (address) {
  88 |     |     
  89 |     |     // Create a new Beefy Strategy as a proxy of the template instance
  90 | *   |     UpgradeableBeacon instance = instances[_strategyName];
  91 | *   |     BeaconProxy proxy = new BeaconProxy(address(instance), "");
  92 |     | 
  93 | *   |     emit ProxyCreated(_strategyName, address(proxy));
  94 |     | 
  95 | *   |     return address(proxy);
  96 |     |   }
  97 |     | 
  98 |     |   /**
  99 |     |    * @notice Upgrades the implementation of a strategy
 100 |     |    * @param _strategyName The name of the strategy
 101 |     |    * @param _newImplementation The new implementation address
 102 |     |    */
 103 |     |   function upgradeTo(string calldata _strategyName, address _newImplementation) external onlyOwner {
 104 |     |     UpgradeableBeacon instance = instances[_strategyName];
 105 |     |     instance.upgradeTo(_newImplementation);
 106 |     |     emit InstanceUpgraded(_strategyName, _newImplementation);
 107 |     |   }
 108 |     | 
 109 |     |   /**
 110 |     |    * @notice Adds a new strategy to the factory
 111 |     |    * @param _strategyName The name of the strategy
 112 |     |    * @param _implementation The implementation address
 113 |     |    */
 114 | *   |   function addStrategy(string calldata _strategyName, address _implementation) external onlyManager {
 115 | *   |     if (address(instances[_strategyName]) != address(0)) revert StratVersionExists();
 116 | *   |     instances[_strategyName] = new UpgradeableBeacon(_implementation, address(this));
 117 |     | 
 118 |     |     // Store in our deployed strategy type array
 119 | *   |     strategyTypes.push(_strategyName);
 120 | *   |     emit NewStrategyAdded(_strategyName, _implementation);
 121 |     |   }
 122 |     | 
 123 |     |   /**
 124 |     |    * @notice Pauses all strategies
 125 |     |    */
 126 |     |   function pauseAllStrats() external onlyManager {
 127 |     |     globalPause = true;
 128 |     |     emit GlobalPause(true);
 129 |     |   }
 130 |     | 
 131 |     |   /**
 132 |     |    * @notice Unpauses all strategies
 133 |     |    */
 134 |     |   function unpauseAllStrats() external onlyOwner {
 135 |     |     globalPause = false;
 136 |     |     emit GlobalPause(false);
 137 |     |   }
 138 |     | 
 139 |     |   /**
 140 |     |    * @notice Adds a rebalancer callable by the owner
 141 |     |    * @param _rebalancer The rebalancer address
 142 |     |    */
 143 | *   |   function addRebalancer(address _rebalancer) external onlyOwner {
 144 |     |     rebalancers[_rebalancer] = true;
 145 |     |     emit RebalancerChanged(_rebalancer, true);
 146 |     |   }
 147 |     | 
 148 |     |   /**
 149 |     |    * @notice Removes a rebalancer callable by a manager
 150 |     |    * @param _rebalancer The rebalancer address
 151 |     |    */
 152 |     |   function removeRebalancer(address _rebalancer) external onlyManager {
 153 |     |     rebalancers[_rebalancer] = false;
 154 |     |     emit RebalancerChanged(_rebalancer, false);
 155 |     |   }
 156 |     | 
 157 |     |   /**
 158 |     |    * @notice set the beefy fee recipient address
 159 |     |    * @param _beefyFeeRecipient The new beefy fee recipient address
 160 |     |    */
 161 |     |   function setBeefyFeeRecipient(address _beefyFeeRecipient) external onlyOwner {
 162 |     |       beefyFeeRecipient = _beefyFeeRecipient;
 163 |     |       emit SetBeefyFeeRecipient(_beefyFeeRecipient);
 164 |     |   }
 165 |     | 
 166 |     |   /**
 167 |     |    * @notice set the beefy fee config address
 168 |     |    * @param _beefyFeeConfig The new beefy fee config address
 169 |     |    */
 170 | *   |   function setBeefyFeeConfig(address _beefyFeeConfig) external onlyOwner {
 171 |     |       beefyFeeConfig = _beefyFeeConfig;
 172 |     |       emit SetBeefyFeeConfig(_beefyFeeConfig);
 173 |     |   }
 174 |     | 
 175 |     |   /**
 176 |     |    * @notice set the keeper address
 177 |     |    * @param _keeper The new keeper address
 178 |     |    */
 179 |     |   function setKeeper(address _keeper) external onlyOwner {
 180 |     |       keeper = _keeper;
 181 |     |       emit SetKeeper(_keeper);
 182 |     |   }
 183 |     | 
 184 |     |   /**
 185 |     |    * @notice Gets the implementation of a strategy
 186 |     |    * @param _strategyName The name of the strategy
 187 |     |    * @return The implementation address
 188 |     |    */
 189 |     |   function getImplementation(string calldata _strategyName) external view returns (address) {
 190 |     |     return instances[_strategyName].implementation();
 191 |     |   }
 192 |     | 
 193 |     |   /**
 194 |     |    * @notice Gets the array of deployed strategies
 195 |     |    * @return The array of deployed strategies
 196 |     |    */
 197 |     |   function getStrategyTypes() external view returns (string[] memory) {
 198 |     |     return strategyTypes;
 199 |     |   }
 200 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/strategies/uniswap/StrategyPassiveManagerUniswap.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | import {IERC20Metadata} from "@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol";
   5 |     | import {SafeERC20} from "@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol";
   6 |     | import {SignedMath} from "@openzeppelin-4/contracts/utils/math/SignedMath.sol";
   7 |     | import {StratFeeManagerInitializable, IFeeConfig} from "../StratFeeManagerInitializable.sol";
   8 |     | import {IUniswapV3Pool} from "../../interfaces/uniswap/IUniswapV3Pool.sol";
   9 |     | import {LiquidityAmounts} from "../../utils/LiquidityAmounts.sol";
  10 |     | import {TickMath} from "../../utils/TickMath.sol";
  11 |     | import {TickUtils, FullMath} from "../../utils/TickUtils.sol";
  12 |     | import {UniV3Utils} from "../../utils/UniV3Utils.sol";
  13 |     | import {IBeefyVaultConcLiq} from "../../interfaces/beefy/IBeefyVaultConcLiq.sol";
  14 |     | import {IStrategyFactory} from "../../interfaces/beefy/IStrategyFactory.sol";
  15 |     | import {IStrategyConcLiq} from "../../interfaces/beefy/IStrategyConcLiq.sol";
  16 |     | import {IStrategyUniswapV3} from "../../interfaces/beefy/IStrategyUniswapV3.sol";
  17 |     | import {IQuoter} from "../../interfaces/uniswap/IQuoter.sol";
  18 |     | 
  19 |     | /// @title Beefy Passive Position Manager. Version: Uniswap
  20 |     | /// @author weso, Beefy
  21 |     | /// @notice This is a contract for managing a passive concentrated liquidity position on Uniswap V3.
  22 |     | contract StrategyPassiveManagerUniswap is StratFeeManagerInitializable, IStrategyConcLiq, IStrategyUniswapV3 {
  23 |     |     using SafeERC20 for IERC20Metadata;
  24 |     |     using TickMath for int24;
  25 |     | 
  26 |     |     /// @notice The precision for pricing.
  27 |     |     uint256 private constant PRECISION = 1e36;
  28 |     |     uint256 private constant SQRT_PRECISION = 1e18;
  29 |     | 
  30 |     |     /// @notice The max and min ticks univ3 allows.
  31 |     |     int56 private constant MIN_TICK = -887272;
  32 |     |     int56 private constant MAX_TICK = 887272;
  33 |     | 
  34 |     |     /// @notice The address of the Uniswap V3 pool.
  35 |     |     address public pool;
  36 |     |     /// @notice The address of the quoter. 
  37 |     |     address public quoter;
  38 |     |     /// @notice The address of the first token in the liquidity pool.
  39 |     |     address public lpToken0;
  40 |     |     /// @notice The address of the second token in the liquidity pool.
  41 |     |     address public lpToken1;
  42 |     | 
  43 |     |     /// @notice The fees that are collected in the strategy but have not yet completed the harvest process.
  44 |     |     uint256 public fees0;
  45 |     |     uint256 public fees1;
  46 |     | 
  47 |     |     /// @notice The path to swap the first token to the native token for fee harvesting.
  48 |     |     bytes public lpToken0ToNativePath;
  49 |     |     /// @notice The path to swap the second token to the native token for fee harvesting.
  50 |     |     bytes public lpToken1ToNativePath;
  51 |     | 
  52 |     |     /// @notice The struct to store our tick positioning.
  53 |     |     struct Position {
  54 |     |         int24 tickLower;
  55 |     |         int24 tickUpper;
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice The main position of the strategy.
  59 |     |     /// @dev this will always be a 50/50 position that will be equal to position width * tickSpacing on each side.
  60 |     |     Position public positionMain;
  61 |     | 
  62 |     |     /// @notice The alternative position of the strategy.
  63 |     |     /// @dev this will always be a single sided (limit order) position that will start closest to current tick and continue to width * tickSpacing.
  64 |     |     /// This will always be in the token that has the most value after we fill our main position. 
  65 |     |     Position public positionAlt;
  66 |     | 
  67 |     |     /// @notice The width of the position, thats a multiplier for tick spacing to find our range. 
  68 |     |     int24 public positionWidth;
  69 |     | 
  70 |     |     /// @notice the max tick deviations we will allow for deposits/harvests. 
  71 |     |     int56 public maxTickDeviation;
  72 |     | 
  73 |     |     /// @notice The twap interval seconds we use for the twap check. 
  74 |     |     uint32 public twapInterval;
  75 |     | 
  76 |     |     /// @notice Bool switch to prevent reentrancy on the mint callback.
  77 |     |     bool private minting;
  78 |     | 
  79 |     |     /// @notice Initializes the ticks on first deposit. 
  80 |     |     bool private initTicks;
  81 |     | 
  82 |     |     // Errors 
  83 |     |     error NotAuthorized();
  84 |     |     error NotPool();
  85 |     |     error InvalidEntry();
  86 |     |     error NotVault();
  87 |     |     error InvalidInput();
  88 |     |     error InvalidOutput();
  89 |     |     error NotCalm();
  90 |     |     error TooMuchSlippage();
  91 |     | 
  92 |     |     // Events
  93 |     |     event Deposit(uint256 bal0, uint256 bal1);
  94 |     |     event Withdraw(uint256 bal0, uint256 bal1);
  95 |     |     event Harvest(uint256 fee0, uint256 fee1);
  96 |     |     event SetPositionWidth(int24 oldWidth, int24 width);
  97 |     |     event SetDeviation(int56 maxTickDeviation);
  98 |     |     event SetTwapInterval(uint32 oldInterval, uint32 interval);
  99 |     |     event SetLpToken0ToNativePath(bytes path);
 100 |     |     event SetLpToken1ToNativePath(bytes path);
 101 |     |     event SetQuoter(address quoter);
 102 |     |     event ChargedFees(uint256 callFeeAmount, uint256 beefyFeeAmount, uint256 strategistFeeAmount);
 103 |     |     event ClaimedFees(uint256 feeMain0, uint256 feeMain1, uint256 feeAlt0, uint256 feeAlt1);
 104 |     | 
 105 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
 106 |     |     constructor() {
 107 |     |         _disableInitializers();
 108 |     |     }
 109 |     |  
 110 |     |     /// @notice Modifier to only allow deposit/harvest actions when current price is within a certain deviation of twap.
 111 |     |     modifier onlyCalmPeriods() {
 112 |     |         _onlyCalmPeriods();
 113 |     |         _;
 114 |     |     }
 115 |     | 
 116 |     |     modifier onlyRebalancers() {
 117 |     |         if (!IStrategyFactory(factory).rebalancers(msg.sender)) revert NotAuthorized();
 118 |     |         _;
 119 |     |     }
 120 |     | 
 121 |     |     /// @notice function to only allow deposit/harvest actions when current price is within a certain deviation of twap.
 122 |     |     function _onlyCalmPeriods() private view {
 123 |     |         if (!isCalm()) revert NotCalm();
 124 |     |     }
 125 |     | 
 126 |     |     /// @notice function to only allow deposit/harvest actions when current price is within a certain deviation of twap.
 127 |     |     function isCalm() public view returns (bool) {
 128 |     |         int24 tick = currentTick();
 129 |     |         int56 twapTick = twap();
 130 |     | 
 131 |     |         int56 minCalmTick = int56(SignedMath.max(twapTick - maxTickDeviation, MIN_TICK));
 132 |     |         int56 maxCalmTick = int56(SignedMath.min(twapTick + maxTickDeviation, MAX_TICK));
 133 |     | 
 134 |     |         // Calculate if greater than deviation % from twap and revert if it is. 
 135 |     |         if(minCalmTick > tick  || maxCalmTick < tick) return false;
 136 |     |         else return true;
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Initializes the strategy and the inherited strat fee manager.
 141 |     |      * @dev Make sure cardinality is set appropriately for the twap.
 142 |     |      * @param _pool The underlying Uniswap V3 pool.
 143 |     |      * @param _quoter The address of the quoter.
 144 |     |      * @param _positionWidth The multiplier for tick spacing to find our range.
 145 |     |      * @param _lpToken0ToNativePath The bytes path for swapping the first token to the native token.
 146 |     |      * @param _lpToken1ToNativePath The bytes path for swapping the second token to the native token.
 147 |     |      * @param _commonAddresses The common addresses needed for the strat fee manager.
 148 |     |      */
 149 |     |     function initialize (
 150 |     |         address _pool,
 151 |     |         address _quoter, 
 152 |     |         int24 _positionWidth,
 153 |     |         bytes calldata _lpToken0ToNativePath,
 154 |     |         bytes calldata _lpToken1ToNativePath,
 155 |     |         CommonAddresses calldata _commonAddresses
 156 |     |     ) external initializer {
 157 |     |         __StratFeeManager_init(_commonAddresses);
 158 |     | 
 159 |     |         pool = _pool;
 160 |     |         quoter = _quoter;
 161 |     |         lpToken0 = IUniswapV3Pool(_pool).token0();
 162 |     |         lpToken1 = IUniswapV3Pool(_pool).token1();
 163 |     | 
 164 |     |         // Our width multiplier. The tick distance of each side will be width * tickSpacing.
 165 |     |         positionWidth = _positionWidth;
 166 |     | 
 167 |     |         // Set up our paths for swapping to native.
 168 |     |         setLpToken0ToNativePath(_lpToken0ToNativePath);
 169 |     |         setLpToken1ToNativePath(_lpToken1ToNativePath);
 170 |     |     
 171 |     |         // Set the twap interval to 120 seconds.
 172 |     |         twapInterval = 120;
 173 |     | 
 174 |     |         _giveAllowances();
 175 |     |     }
 176 |     | 
 177 |     |     /// @notice Only allows the vault to call a function.
 178 |     |     function _onlyVault () private view {
 179 |     |         if (msg.sender != vault) revert NotVault();
 180 |     |     }
 181 |     | 
 182 |     |     /// @notice Called during deposit and withdraw to remove liquidity and harvest fees for accounting purposes.
 183 |     |     function beforeAction() external {
 184 |     |         _onlyVault();
 185 |     |         _claimEarnings();
 186 |     |         _removeLiquidity();
 187 |     |     }
 188 |     | 
 189 |     |     /// @notice Called during deposit to add all liquidity back to their positions. 
 190 |     |     function deposit() external onlyCalmPeriods {
 191 |     |         _onlyVault();
 192 |     | 
 193 |     |         // Add all liquidity
 194 |     |         if (!initTicks) {
 195 |     |             _setTicks();
 196 |     |             initTicks = true;
 197 |     |         }
 198 |     | 
 199 |     |         _addLiquidity();
 200 |     |         
 201 |     |         (uint256 bal0, uint256 bal1) = balances();
 202 |     | 
 203 |     |         // TVL Balances after deposit
 204 |     |         emit Deposit(bal0, bal1);
 205 |     |     }
 206 |     | 
 207 |     |     /**
 208 |     |      * @notice Withdraws the specified amount of tokens from the strategy as calculated by the vault.
 209 |     |      * @param _amount0 The amount of token0 to withdraw.
 210 |     |      * @param _amount1 The amount of token1 to withdraw.
 211 |     |      */
 212 |     |     function withdraw(uint256 _amount0, uint256 _amount1) external {
 213 |     |         _onlyVault();
 214 |     | 
 215 |     |         // Liquidity has already been removed in beforeAction() so this is just a simple withdraw.
 216 |     |         if (_amount0 > 0) IERC20Metadata(lpToken0).safeTransfer(vault, _amount0);
 217 |     |         if (_amount1 > 0) IERC20Metadata(lpToken1).safeTransfer(vault, _amount1);
 218 |     | 
 219 |     |         // After we take what is needed we add it all back to our positions. 
 220 |     |         if (!_isPaused()) _addLiquidity();
 221 |     | 
 222 |     |         (uint256 bal0, uint256 bal1) = balances();
 223 |     | 
 224 |     |         // TVL Balances after withdraw
 225 |     |         emit Withdraw(bal0, bal1);
 226 |     |     }
 227 |     | 
 228 |     |     /// @notice Adds liquidity to the main and alternative positions called on deposit, harvest and withdraw.
 229 |     |     //audit mody:should revert if amountsOk is flase. Could lead to minting Alt positions without Main positions
 230 |     |     function _addLiquidity() private {
 231 |     |         _whenStrategyNotPaused();
 232 |     | 
 233 |     |         (uint256 bal0, uint256 bal1) = balancesOfThis();
 234 |     | 
 235 |     |         // Then we fetch how much liquidity we get for adding at the main position ticks with our token balances. 
 236 |     |         uint160 sqrtprice = sqrtPrice();
 237 |     |         uint128 liquidity = LiquidityAmounts.getLiquidityForAmounts(
 238 |     |             sqrtprice,
 239 |     |             TickMath.getSqrtRatioAtTick(positionMain.tickLower),
 240 |     |             TickMath.getSqrtRatioAtTick(positionMain.tickUpper),
 241 |     |             bal0,
 242 |     |             bal1
 243 |     |         );
 244 |     | 
 245 |     |         bool amountsOk = _checkAmounts(liquidity, positionMain.tickLower, positionMain.tickUpper);
 246 |     | 
 247 |     |         // Flip minting to true and call the pool to mint the liquidity. 
 248 |     |         if (liquidity > 0 && amountsOk) {
 249 |     |             minting = true;
 250 |     |             IUniswapV3Pool(pool).mint(address(this), positionMain.tickLower, positionMain.tickUpper, liquidity, "Beefy Main");
 251 |     |         }
 252 |     | 
 253 |     |         (bal0, bal1) = balancesOfThis();
 254 |     | 
 255 |     |         // Fetch how much liquidity we get for adding at the alternative position ticks with our token balances.
 256 |     |         liquidity = LiquidityAmounts.getLiquidityForAmounts(
 257 |     |             sqrtprice,
 258 |     |             TickMath.getSqrtRatioAtTick(positionAlt.tickLower),
 259 |     |             TickMath.getSqrtRatioAtTick(positionAlt.tickUpper),
 260 |     |             bal0,
 261 |     |             bal1
 262 |     |         );
 263 |     | 
 264 |     |         // Flip minting to true and call the pool to mint the liquidity.
 265 |     |         if (liquidity > 0) {
 266 |     |             minting = true;
 267 |     |             IUniswapV3Pool(pool).mint(address(this), positionAlt.tickLower, positionAlt.tickUpper, liquidity, "Beefy Alt");
 268 |     |         }
 269 |     |     }
 270 |     | 
 271 |     |     /// @notice Removes liquidity from the main and alternative positions, called on deposit, withdraw and harvest.
 272 |     |     function _removeLiquidity() private {
 273 |     | 
 274 |     |         // First we fetch our position keys in order to get our liquidity balances from the pool. 
 275 |     |         (bytes32 keyMain, bytes32 keyAlt) = getKeys();
 276 |     |         
 277 |     |         // Fetch the liquidity balances from the pool.
 278 |     |         (uint128 liquidity,,,,) = IUniswapV3Pool(pool).positions(keyMain);
 279 |     |         (uint128 liquidityAlt,,,,) = IUniswapV3Pool(pool).positions(keyAlt);
 280 |     | 
 281 |     |         // If we have liquidity in the positions we remove it and collect our tokens.
 282 |     |         if (liquidity > 0) {
 283 |     |             IUniswapV3Pool(pool).burn(positionMain.tickLower, positionMain.tickUpper, liquidity);
 284 |     |             IUniswapV3Pool(pool).collect(address(this), positionMain.tickLower, positionMain.tickUpper, type(uint128).max, type(uint128).max);
 285 |     |         }
 286 |     | 
 287 |     |         if (liquidityAlt > 0) {
 288 |     |             IUniswapV3Pool(pool).burn(positionAlt.tickLower, positionAlt.tickUpper, liquidityAlt);
 289 |     |             IUniswapV3Pool(pool).collect(address(this), positionAlt.tickLower, positionAlt.tickUpper, type(uint128).max, type(uint128).max);
 290 |     |         }
 291 |     |     }
 292 |     | 
 293 |     |     /**
 294 |     |      *  @notice Checks if the amounts are ok to add liquidity.
 295 |     |      * @param _liquidity The liquidity to add.
 296 |     |      * @param _tickLower The lower tick of the position.
 297 |     |      * @param _tickUpper The upper tick of the position.
 298 |     |      * @return bool True if the amounts are ok, false if not.
 299 |     |      */
 300 |     |     function _checkAmounts(uint128 _liquidity, int24 _tickLower, int24 _tickUpper) private view returns (bool) {
 301 |     |         (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
 302 |     |             sqrtPrice(),
 303 |     |             TickMath.getSqrtRatioAtTick(_tickLower),
 304 |     |             TickMath.getSqrtRatioAtTick(_tickUpper),
 305 |     |             _liquidity
 306 |     |         );
 307 |     | 
 308 |     |         if (amount0 == 0 || amount1 == 0) return false;
 309 |     |         else return true;
 310 |     |     }
 311 |     | 
 312 |     |     /// @notice Harvest call to claim fees from pool, charge fees for Beefy, then readjust our positions.
 313 |     |     /// @param _callFeeRecipient The address to send the call fee to.
 314 |     |     function harvest(address _callFeeRecipient) external {
 315 |     |         _harvest(_callFeeRecipient);
 316 |     |     }
 317 |     | 
 318 |     |     /// @notice Harvest call to claim fees from the pool, charge fees for Beefy, then readjust our positions.
 319 |     |     /// @dev Call fee goes to the tx.origin. 
 320 |     |     function harvest() external {
 321 |     |         _harvest(tx.origin);
 322 |     |     }
 323 |     | 
 324 |     |     /// @notice Internal function to claim fees from the pool, charge fees for Beefy, then readjust our positions.
 325 |     | 
 326 |     |     //audit mody: reentrancy recipient can reenter the external harvest function.
 327 |     |     //audit-ok no reentrancy issue 
 328 |     |     //audit mody: dos. receipient can front run harvest calls and force a failure on fee distribution in their smart contract
 329 |     |     //audit-ok the contract does not have a timelock which makes DOS not possible. Frontrun-ed transactions will just execute normally. 
 330 |     |     function _harvest (address _callFeeRecipient) private {
 331 |     |         // Claim fees from the pool and collect them.
 332 |     |         _claimEarnings();
 333 |     |         _removeLiquidity();
 334 |     |         
 335 |     |         // Charge fees for Beefy and send them to the appropriate addresses, charge fees to accrued state fee amounts.
 336 |     |         (uint256 fee0, uint256 fee1) = _chargeFees(_callFeeRecipient, fees0, fees1);
 337 |     | 
 338 |     |         _addLiquidity();
 339 |     | 
 340 |     |         // Reset state fees to 0. 
 341 |     |         fees0 = 0;
 342 |     |         fees1 = 0;
 343 |     |         
 344 |     |         // We stream the rewards over time to the LP. 
 345 |     |         (uint256 currentLock0, uint256 currentLock1) = lockedProfit();
 346 |     |         totalLocked0 = fee0 + currentLock0;
 347 |     |         totalLocked1 = fee1 + currentLock1;
 348 |     | 
 349 |     |         // Log the last time we claimed fees. 
 350 |     |         lastHarvest = block.timestamp;
 351 |     | 
 352 |     |         // Log the fees post Beefy fees.
 353 |     |         emit Harvest(fee0, fee1);
 354 |     |     }
 355 |     | 
 356 |     |     /// @notice Function called to rebalance the position 
 357 |     |     function rebalance() external onlyCalmPeriods onlyRebalancers {
 358 |     |         _claimEarnings();
 359 |     |         _removeLiquidity();
 360 |     |         _setTicks();
 361 |     |         _addLiquidity();
 362 |     |     }
 363 |     | 
 364 |     |     /// @notice Claims fees from the pool and collects them.
 365 |     |     function claimEarnings() external returns (uint256 fee0, uint256 fee1, uint256 feeAlt0, uint256 feeAlt1) {
 366 |     |         (fee0, fee1, feeAlt0, feeAlt1) = _claimEarnings();
 367 |     |     }
 368 |     | 
 369 |     |     /// @notice Internal function to claim fees from the pool and collect them.
 370 |     |     function _claimEarnings() private returns (uint256 fee0, uint256 fee1, uint256 feeAlt0, uint256 feeAlt1) {
 371 |     |         // Claim fees
 372 |     |         (bytes32 keyMain, bytes32 keyAlt) = getKeys();
 373 |     |         (uint128 liquidity,,,,) = IUniswapV3Pool(pool).positions(keyMain);
 374 |     |         (uint128 liquidityAlt,,,,) = IUniswapV3Pool(pool).positions(keyAlt);
 375 |     | 
 376 |     |         // Burn 0 liquidity to make fees available to claim. 
 377 |     |         if (liquidity > 0) IUniswapV3Pool(pool).burn(positionMain.tickLower, positionMain.tickUpper, 0);
 378 |     |         if (liquidityAlt > 0) IUniswapV3Pool(pool).burn(positionAlt.tickLower, positionAlt.tickUpper, 0);
 379 |     | 
 380 |     |         // Collect fees from the pool. 
 381 |     |         (fee0, fee1) = IUniswapV3Pool(pool).collect(address(this), positionMain.tickLower, positionMain.tickUpper, type(uint128).max, type(uint128).max);
 382 |     |         (feeAlt0, feeAlt1) = IUniswapV3Pool(pool).collect(address(this), positionAlt.tickLower, positionAlt.tickUpper, type(uint128).max, type(uint128).max);
 383 |     | 
 384 |     |         // Set the total fees collected to state.
 385 |     |         fees0 = fees0 + fee0 + feeAlt0;
 386 |     |         fees1 = fees1 + fee1 + feeAlt1;
 387 |     | 
 388 |     |         emit ClaimedFees(fee0, fee1, feeAlt0, feeAlt1);
 389 |     |     }
 390 |     | 
 391 |     |     /**
 392 |     |      * @notice Internal function to charge fees for Beefy and send them to the appropriate addresses.
 393 |     |      * @param _callFeeRecipient The address to send the call fee to.
 394 |     |      * @param _amount0 The amount of token0 to charge fees on.
 395 |     |      * @param _amount1 The amount of token1 to charge fees on.
 396 |     |      * @return _amountLeft0 The amount of token0 left after fees.
 397 |     |      * @return _amountLeft1 The amount of token1 left after fees.
 398 |     |      */
 399 |     |     function _chargeFees(address _callFeeRecipient, uint256 _amount0, uint256 _amount1) private returns (uint256 _amountLeft0, uint256 _amountLeft1){
 400 |     |         /// Fetch our fee percentage amounts from the fee config.
 401 |     |         IFeeConfig.FeeCategory memory fees = getFees();
 402 |     | 
 403 |     |         /// We calculate how much to swap and then swap both tokens to native and charge fees.
 404 |     |         uint256 nativeEarned;
 405 |     |         if (_amount0 > 0) {
 406 |     |             // Calculate amount of token 0 to swap for fees.
 407 |     |             uint256 amountToSwap0 = _amount0 * fees.total / DIVISOR;
 408 |     |             _amountLeft0 = _amount0 - amountToSwap0;
 409 |     |             
 410 |     |             // If token0 is not native, swap to native the fee amount.
 411 |     |             uint256 out0;
 412 |     |             if (lpToken0 != native) out0 = UniV3Utils.swap(unirouter, lpToken0ToNativePath, amountToSwap0);
 413 |     |             
 414 |     |             // Add the native earned to the total of native we earned for beefy fees, handle if token0 is native.
 415 |     |             if (lpToken0 == native)  nativeEarned += amountToSwap0;
 416 |     |             else nativeEarned += out0;
 417 |     |         }
 418 |     | 
 419 |     |         if (_amount1 > 0) {
 420 |     |             // Calculate amount of token 1 to swap for fees.
 421 |     |             uint256 amountToSwap1 = _amount1 * fees.total / DIVISOR;
 422 |     |             _amountLeft1 = _amount1 - amountToSwap1;
 423 |     | 
 424 |     |             // If token1 is not native, swap to native the fee amount.
 425 |     |             uint256 out1;
 426 |     |             if (lpToken1 != native) out1 = UniV3Utils.swap(unirouter, lpToken1ToNativePath, amountToSwap1);
 427 |     |             
 428 |     |             // Add the native earned to the total of native we earned for beefy fees, handle if token1 is native.
 429 |     |             if (lpToken1 == native) nativeEarned += amountToSwap1;
 430 |     |             else nativeEarned += out1;
 431 |     |         }
 432 |     | 
 433 |     |         // Distribute the native earned to the appropriate addresses.
 434 |     |         uint256 callFeeAmount = nativeEarned * fees.call / DIVISOR;
 435 |     |         IERC20Metadata(native).safeTransfer(_callFeeRecipient, callFeeAmount);
 436 |     | 
 437 |     |         uint256 strategistFeeAmount = nativeEarned * fees.strategist / DIVISOR;
 438 |     |         IERC20Metadata(native).safeTransfer(strategist, strategistFeeAmount);
 439 |     | 
 440 |     |         uint256 beefyFeeAmount = nativeEarned - callFeeAmount - strategistFeeAmount;
 441 |     |         IERC20Metadata(native).safeTransfer(beefyFeeRecipient(), beefyFeeAmount);
 442 |     | 
 443 |     |         emit ChargedFees(callFeeAmount, beefyFeeAmount, strategistFeeAmount);
 444 |     |     }
 445 |     | 
 446 |     |     /** 
 447 |     |      * @notice Returns total token balances in the strategy.
 448 |     |      * @return token0Bal The amount of token0 in the strategy.
 449 |     |      * @return token1Bal The amount of token1 in the strategy.
 450 |     |     */
 451 |     |     function balances() public view returns (uint256 token0Bal, uint256 token1Bal) {
 452 |     |         (uint256 thisBal0, uint256 thisBal1) = balancesOfThis();
 453 |     |         (uint256 poolBal0, uint256 poolBal1,,,,) = balancesOfPool();
 454 |     |         (uint256 locked0, uint256 locked1) = lockedProfit();
 455 |     | 
 456 |     |         uint256 total0 = thisBal0 + poolBal0 - locked0;
 457 |     |         uint256 total1 = thisBal1 + poolBal1 - locked1;
 458 |     |         uint256 unharvestedFees0 = fees0;
 459 |     |         uint256 unharvestedFees1 = fees1;
 460 |     | 
 461 |     |         // If pair is so imbalanced that we no longer have any enough tokens to pay fees, we set them to 0.
 462 |     |         if (unharvestedFees0 > total0) unharvestedFees0 = total0;
 463 |     |         if (unharvestedFees1 > total1) unharvestedFees1 = total1;
 464 |     | 
 465 |     |         // For token0 and token1 we return balance of this contract + balance of positions - locked profit - feesUnharvested.
 466 |     |         return (total0 - unharvestedFees0, total1 - unharvestedFees1);
 467 |     |     }
 468 |     | 
 469 |     |     /**
 470 |     |      * @notice Returns total tokens sitting in the strategy.
 471 |     |      * @return token0Bal The amount of token0 in the strategy.
 472 |     |      * @return token1Bal The amount of token1 in the strategy.
 473 |     |     */
 474 |     |     function balancesOfThis() public view returns (uint256 token0Bal, uint256 token1Bal) {
 475 |     |         return (IERC20Metadata(lpToken0).balanceOf(address(this)), IERC20Metadata(lpToken1).balanceOf(address(this)));
 476 |     |     }
 477 |     | 
 478 |     |     /** 
 479 |     |      * @notice Returns total tokens in pool positions (is a calculation which means it could be a little off by a few wei). 
 480 |     |      * @return token0Bal The amount of token0 in the pool.
 481 |     |      * @return token1Bal The amount of token1 in the pool.
 482 |     |      * @return mainAmount0 The amount of token0 in the main position.
 483 |     |      * @return mainAmount1 The amount of token1 in the main position.
 484 |     |      * @return altAmount0 The amount of token0 in the alt position.
 485 |     |      * @return altAmount1 The amount of token1 in the alt position.
 486 |     |     */
 487 |     |     function balancesOfPool() public view returns (uint256 token0Bal, uint256 token1Bal, uint256 mainAmount0, uint256 mainAmount1, uint256 altAmount0, uint256 altAmount1) {
 488 |     |         (bytes32 keyMain, bytes32 keyAlt) = getKeys();
 489 |     |         uint160 sqrtPriceX96 = sqrtPrice();
 490 |     |         (uint128 liquidity,,,uint256 owed0, uint256 owed1) = IUniswapV3Pool(pool).positions(keyMain);
 491 |     |         (uint128 altLiquidity,,,uint256 altOwed0, uint256 altOwed1) =IUniswapV3Pool(pool).positions(keyAlt);
 492 |     | 
 493 |     |         (mainAmount0, mainAmount1) = LiquidityAmounts.getAmountsForLiquidity(
 494 |     |             sqrtPriceX96,
 495 |     |             TickMath.getSqrtRatioAtTick(positionMain.tickLower),
 496 |     |             TickMath.getSqrtRatioAtTick(positionMain.tickUpper),
 497 |     |             liquidity
 498 |     |         );
 499 |     | 
 500 |     |         (altAmount0, altAmount1) = LiquidityAmounts.getAmountsForLiquidity(
 501 |     |             sqrtPriceX96,   
 502 |     |             TickMath.getSqrtRatioAtTick(positionAlt.tickLower),
 503 |     |             TickMath.getSqrtRatioAtTick(positionAlt.tickUpper),
 504 |     |             altLiquidity
 505 |     |         );
 506 |     | 
 507 |     |         mainAmount0 += owed0;
 508 |     |         mainAmount1 += owed1;
 509 |     | 
 510 |     |         altAmount0 += altOwed0;
 511 |     |         altAmount1 += altOwed1;
 512 |     |         
 513 |     |         token0Bal = mainAmount0 + altAmount0;
 514 |     |         token1Bal = mainAmount1 + altAmount1;
 515 |     |     }
 516 |     | 
 517 |     |     /**
 518 |     |      * @notice Returns the amount of locked profit in the strategy, this is linearly release over a duration defined in the fee manager.
 519 |     |      * @return locked0 The amount of token0 locked in the strategy.
 520 |     |      * @return locked1 The amount of token1 locked in the strategy.
 521 |     |     */
 522 |     |     //audit mody: invriant: as time goes by locked0 and locked1 should get smaller
 523 |     |     function lockedProfit() public override view returns (uint256 locked0, uint256 locked1) {
 524 |     |         (uint256 balThis0, uint256 balThis1) = balancesOfThis();
 525 |     |         (uint256 balPool0, uint256 balPool1,,,,) = balancesOfPool();
 526 |     |         uint256 totalBal0 = balThis0 + balPool0;
 527 |     |         uint256 totalBal1 = balThis1 + balPool1;
 528 |     | 
 529 |     |         uint256 elapsed = block.timestamp - lastHarvest;
 530 |     |         uint256 remaining = elapsed < DURATION ? DURATION - elapsed : 0;
 531 |     | 
 532 |     |         // Make sure we don't lock more than we have.
 533 |     |         if (totalBal0 > totalLocked0) locked0 = totalLocked0 * remaining / DURATION;
 534 |     |         else locked0 = totalBal0 * remaining / DURATION;
 535 |     | 
 536 |     |         if (totalBal1 > totalLocked1) locked1 = totalLocked1 * remaining / DURATION; 
 537 |     |         else locked1 = totalBal1 * remaining / DURATION;
 538 |     |     }
 539 |     |     
 540 |     |     /**
 541 |     |      * @notice Returns the range of the pool, will always be the main position.
 542 |     |      * @return lowerPrice The lower price of the position.
 543 |     |      * @return upperPrice The upper price of the position.
 544 |     |     */
 545 |     |     function range() external view returns (uint256 lowerPrice, uint256 upperPrice) {
 546 |     |         // the main position is always covering the alt range
 547 |     |         lowerPrice = FullMath.mulDiv(uint256(TickMath.getSqrtRatioAtTick(positionMain.tickLower)), SQRT_PRECISION, (2 ** 96)) ** 2;
 548 |     |         upperPrice = FullMath.mulDiv(uint256(TickMath.getSqrtRatioAtTick(positionMain.tickUpper)), SQRT_PRECISION, (2 ** 96)) ** 2;
 549 |     |     }
 550 |     | 
 551 |     |     /**
 552 |     |      * @notice Returns the keys for the main and alternative positions.
 553 |     |      * @return keyMain The key for the main position.
 554 |     |      * @return keyAlt The key for the alternative position.
 555 |     |     */
 556 |     |     function getKeys() public view returns (bytes32 keyMain, bytes32 keyAlt) {
 557 |     |         keyMain = keccak256(abi.encodePacked(address(this), positionMain.tickLower, positionMain.tickUpper));
 558 |     |         keyAlt = keccak256(abi.encodePacked(address(this), positionAlt.tickLower, positionAlt.tickUpper));
 559 |     |     }
 560 |     | 
 561 |     |     /**
 562 |     |      * @notice The current tick of the pool.
 563 |     |      * @return tick The current tick of the pool.
 564 |     |     */
 565 |     |     function currentTick() public view returns (int24 tick) {
 566 |     |         (,tick,,,,,) = IUniswapV3Pool(pool).slot0();
 567 |     |     }
 568 |     | 
 569 |     |     /**
 570 |     |      * @notice The current price of the pool in token1, encoded with 36 decimals.
 571 |     |      * @return _price The current price of the pool.
 572 |     |     */
 573 |     |     function price() public view returns (uint256 _price) {
 574 |     |         uint160 sqrtPriceX96 = sqrtPrice();
 575 |     |         _price = FullMath.mulDiv(uint256(sqrtPriceX96), SQRT_PRECISION, (2 ** 96)) ** 2;
 576 |     |     }
 577 |     | 
 578 |     |     /**
 579 |     |      * @notice The sqrt price of the pool.
 580 |     |      * @return sqrtPriceX96 The sqrt price of the pool.
 581 |     |     */
 582 |     |     function sqrtPrice() public view returns (uint160 sqrtPriceX96) {
 583 |     |         (sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();
 584 |     |     }
 585 |     | 
 586 |     |     /** 
 587 |     |      * @notice The tick distance of the pool.
 588 |     |      * @return int24 The tick distance/spacing of the pool.
 589 |     |     */
 590 |     |     function _tickDistance() private view returns (int24) {
 591 |     |         return IUniswapV3Pool(pool).tickSpacing();
 592 |     |     }
 593 |     | 
 594 |     |     /**
 595 |     |      * @notice Callback function for Uniswap V3 pool to call when minting liquidity.
 596 |     |      * @param amount0 Amount of token0 owed to the pool
 597 |     |      * @param amount1 Amount of token1 owed to the pool
 598 |     |      * bytes Additional data but unused in this case.
 599 |     |     */
 600 |     |     function uniswapV3MintCallback(uint256 amount0, uint256 amount1, bytes memory /*data*/) external {
 601 |     |         if (msg.sender != pool) revert NotPool();
 602 |     |         if (!minting) revert InvalidEntry();
 603 |     | 
 604 |     |         if (amount0 > 0) IERC20Metadata(lpToken0).safeTransfer(pool, amount0);
 605 |     |         if (amount1 > 0) IERC20Metadata(lpToken1).safeTransfer(pool, amount1);
 606 |     |         minting = false;
 607 |     |     }
 608 |     | 
 609 |     |     /// @notice Sets the tick positions for the main and alternative positions.
 610 |     |     function _setTicks() private onlyCalmPeriods {
 611 |     |         int24 tick = currentTick();
 612 |     |         int24 distance = _tickDistance();
 613 |     |         int24 width = positionWidth * distance;
 614 |     | 
 615 |     |         _setMainTick(tick, distance, width);
 616 |     |         _setAltTick(tick, distance, width);
 617 |     |     }
 618 |     | 
 619 |     |     /// @notice Sets the main tick position.
 620 |     |     function _setMainTick(int24 tick, int24 distance, int24 width) private {
 621 |     |         (positionMain.tickLower, positionMain.tickUpper) = TickUtils.baseTicks(
 622 |     |             tick,
 623 |     |             width,
 624 |     |             distance
 625 |     |         );
 626 |     |     }
 627 |     | 
 628 |     |     /// @notice Sets the alternative tick position.
 629 |     |     function _setAltTick(int24 tick, int24 distance, int24 width) private {
 630 |     |         (uint256 bal0, uint256 bal1) = balancesOfThis();
 631 |     | 
 632 |     |         // We calculate how much token0 we have in the price of token1. 
 633 |     |         uint256 amount0;
 634 |     | 
 635 |     |         if (bal0 > 0) {
 636 |     |             amount0 = bal0 * price() / PRECISION;
 637 |     |         }
 638 |     | 
 639 |     |         // We set the alternative position based on the token that has the most value available. 
 640 |     |         if (amount0 < bal1) {
 641 |     |             (positionAlt.tickLower, ) = TickUtils.baseTicks(
 642 |     |                 tick,
 643 |     |                 width,
 644 |     |                 distance
 645 |     |             );
 646 |     | 
 647 |     |             (positionAlt.tickUpper, ) = TickUtils.baseTicks(
 648 |     |                 tick,
 649 |     |                 distance,
 650 |     |                 distance
 651 |     |             ); 
 652 |     |         } else if (bal1 < amount0) {
 653 |     |             (, positionAlt.tickLower) = TickUtils.baseTicks(
 654 |     |                 tick,
 655 |     |                 distance,
 656 |     |                 distance
 657 |     |             );
 658 |     | 
 659 |     |             (, positionAlt.tickUpper) = TickUtils.baseTicks(
 660 |     |                 tick,
 661 |     |                 width,
 662 |     |                 distance
 663 |     |             ); 
 664 |     |         }
 665 |     |     }
 666 |     | 
 667 |     |     /**
 668 |     |      * @notice Sets the path to swap the first token to the native token for fee harvesting.
 669 |     |      * @param _path The path to swap the first token to the native token.
 670 |     |     */
 671 |     |     function setLpToken0ToNativePath(bytes calldata _path) public onlyOwner {
 672 |     |         if (_path.length > 0) {
 673 |     |             (address[] memory _route) = UniV3Utils.pathToRoute(_path);
 674 |     |             if (_route[0] != lpToken0) revert InvalidInput();
 675 |     |             if (_route[_route.length - 1] != native) revert InvalidOutput();
 676 |     |             lpToken0ToNativePath = _path;
 677 |     |             emit SetLpToken0ToNativePath(_path);
 678 |     |         }
 679 |     |     }
 680 |     | 
 681 |     |     /**
 682 |     |      * @notice Sets the path to swap the second token to the native token for fee harvesting.
 683 |     |      * @param _path The path to swap the second token to the native token.
 684 |     |     */
 685 |     |     function setLpToken1ToNativePath(bytes calldata _path) public onlyOwner {
 686 |     |         if (_path.length > 0) {
 687 |     |             (address[] memory _route) = UniV3Utils.pathToRoute(_path);
 688 |     |             if (_route[0] != lpToken1) revert InvalidInput();
 689 |     |             if (_route[_route.length - 1] != native) revert InvalidOutput();
 690 |     |             lpToken1ToNativePath = _path;
 691 |     |             emit SetLpToken1ToNativePath(_path);
 692 |     |         }
 693 |     |     }
 694 |     | 
 695 |     |     /**
 696 |     |      * @notice Sets the deviation from the twap we will allow on adding liquidity.
 697 |     |      * @param _maxDeviation The max deviation from twap we will allow.
 698 |     |     */
 699 |     |     function setDeviation(int56 _maxDeviation) external onlyOwner {
 700 |     |         emit SetDeviation(_maxDeviation);
 701 |     | 
 702 |     |         // Require the deviation to be less than or equal to 4 times the tick spacing.
 703 |     |         if (_maxDeviation >= _tickDistance() * 4) revert InvalidInput();
 704 |     | 
 705 |     |         maxTickDeviation = _maxDeviation;
 706 |     |     }
 707 |     | 
 708 |     |     /**
 709 |     |      * @notice Returns the route to swap the first token to the native token for fee harvesting.
 710 |     |      * @return address[] The route to swap the first token to the native token.
 711 |     |     */
 712 |     |     function lpToken0ToNative() external view returns (address[] memory) {
 713 |     |         if (lpToken0ToNativePath.length == 0) return new address[](0);
 714 |     |         return UniV3Utils.pathToRoute(lpToken0ToNativePath);
 715 |     |     }
 716 |     | 
 717 |     |     /** 
 718 |     |      * @notice Returns the route to swap the second token to the native token for fee harvesting.
 719 |     |      * @return address[] The route to swap the second token to the native token.
 720 |     |     */
 721 |     |     function lpToken1ToNative() external view returns (address[] memory) {
 722 |     |         if (lpToken1ToNativePath.length == 0) return new address[](0);
 723 |     |         return UniV3Utils.pathToRoute(lpToken1ToNativePath);
 724 |     |     }
 725 |     | 
 726 |     |     /// @notice Returns the price of the first token in native token.
 727 |     |     function lpToken0ToNativePrice() external returns (uint256) {
 728 |     |         uint amount = 10**IERC20Metadata(lpToken0).decimals() / 10;
 729 |     |         if (lpToken0 == native) return amount * 10;
 730 |     |         return IQuoter(quoter).quoteExactInput(lpToken0ToNativePath, amount) * 10;
 731 |     |     }
 732 |     | 
 733 |     |     /// @notice Returns the price of the second token in native token.
 734 |     |     function lpToken1ToNativePrice() external returns (uint256) {
 735 |     |         uint amount = 10**IERC20Metadata(lpToken1).decimals() / 10;
 736 |     |         if (lpToken1 == native) return amount * 10;
 737 |     |         return IQuoter(quoter).quoteExactInput(lpToken1ToNativePath, amount) * 10;
 738 |     |     }
 739 |     |     /** 
 740 |     |      * @notice The twap of the last minute from the pool.
 741 |     |      * @return twapTick The twap of the last minute from the pool.
 742 |     |     */
 743 |     |     function twap() public view returns (int56 twapTick) {
 744 |     |         uint32[] memory secondsAgo = new uint32[](2);
 745 |     |         secondsAgo[0] = uint32(twapInterval);
 746 |     |         secondsAgo[1] = 0;
 747 |     | 
 748 |     |         (int56[] memory tickCuml,) = IUniswapV3Pool(pool).observe(secondsAgo);
 749 |     |         twapTick = (tickCuml[1] - tickCuml[0]) / int32(twapInterval);
 750 |     |     }
 751 |     | 
 752 |     |     function setTwapInterval(uint32 _interval) external onlyOwner {
 753 |     |         emit SetTwapInterval(twapInterval, _interval);
 754 |     | 
 755 |     |         // Require the interval to be greater than 60 seconds.
 756 |     |         if (_interval < 60) revert InvalidInput();
 757 |     | 
 758 |     |         twapInterval = _interval;
 759 |     |     }
 760 |     | 
 761 |     |     /** 
 762 |     |      * @notice Sets our position width and readjusts our positions.
 763 |     |      * @param _width The new width multiplier of the position.
 764 |     |     */
 765 |     |     function setPositionWidth(int24 _width) external onlyOwner {
 766 |     |         emit SetPositionWidth(positionWidth, _width);
 767 |     |         _claimEarnings();
 768 |     |         _removeLiquidity();
 769 |     |         positionWidth = _width;
 770 |     |         _setTicks();
 771 |     |         _addLiquidity();
 772 |     |     }
 773 |     | 
 774 |     |     /**
 775 |     |      * @notice set the unirouter address
 776 |     |      * @param _unirouter The new unirouter address
 777 |     |      */
 778 |     |     function setUnirouter(address _unirouter) external override onlyOwner {
 779 |     |         _removeAllowances();
 780 |     |         unirouter = _unirouter;
 781 |     |         _giveAllowances();
 782 |     |         emit SetUnirouter(_unirouter);
 783 |     |     }
 784 |     | 
 785 |     |     /// @notice Retire the strategy and return all the dust to the fee recipient.
 786 |     |     function retireVault() external onlyOwner {
 787 |     |         if (IBeefyVaultConcLiq(vault).totalSupply() != 10**3) revert NotAuthorized();
 788 |     |         panic(0,0);
 789 |     |         address feeRecipient = beefyFeeRecipient();
 790 |     |         IERC20Metadata(lpToken0).safeTransfer(feeRecipient, IERC20Metadata(lpToken0).balanceOf(address(this)));
 791 |     |         IERC20Metadata(lpToken1).safeTransfer(feeRecipient, IERC20Metadata(lpToken1).balanceOf(address(this)));
 792 |     |         _transferOwnership(address(0));
 793 |     |     }
 794 |     | 
 795 |     |     /**  
 796 |     |      * @notice Remove Liquidity and Allowances, then pause deposits.
 797 |     |      * @param _minAmount0 The minimum amount of token0 in the strategy after panic.
 798 |     |      * @param _minAmount1 The minimum amount of token1 in the strategy after panic.
 799 |     |      */
 800 |     |     function panic(uint256 _minAmount0, uint256 _minAmount1) public onlyManager {
 801 |     |         _claimEarnings();
 802 |     |         _removeLiquidity();
 803 |     |         _removeAllowances();
 804 |     |         _pause();
 805 |     | 
 806 |     |         (uint256 bal0, uint256 bal1) = balances();
 807 |     |         if (bal0 < _minAmount0 || bal1 < _minAmount1) revert TooMuchSlippage();
 808 |     |     }
 809 |     | 
 810 |     |     /// @notice Unpause deposits, give allowances and add liquidity.
 811 |     |     function unpause() external onlyManager {
 812 |     |         if (owner() == address(0)) revert NotAuthorized();
 813 |     |         _giveAllowances();
 814 |     |         _unpause();
 815 |     |         _setTicks();
 816 |     |         _addLiquidity();
 817 |     |     }
 818 |     | 
 819 |     |     /// @notice gives swap permisions for the tokens to the unirouter.
 820 |     |     function _giveAllowances() private {
 821 |     |         IERC20Metadata(lpToken0).forceApprove(unirouter, type(uint256).max);
 822 |     |         IERC20Metadata(lpToken1).forceApprove(unirouter, type(uint256).max);
 823 |     |     }
 824 |     | 
 825 |     |     /// @notice removes swap permisions for the tokens from the unirouter.
 826 |     |     function _removeAllowances() private {
 827 |     |         IERC20Metadata(lpToken0).forceApprove(unirouter, 0);
 828 |     |         IERC20Metadata(lpToken1).forceApprove(unirouter, 0);
 829 |     |     }
 830 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/strategies/velodrome/StrategyPassiveManagerVelodrome.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity 0.8.23;
    3 |     | 
    4 |     | import {Test, console} from "forge-std/Test.sol";
    5 |     | 
    6 |     | import {IERC20Metadata} from "@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol";
    7 |     | import {IERC721} from "@openzeppelin-4/contracts/token/ERC721/IERC721.sol";
    8 |     | import {SafeERC20} from "@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol";
    9 |     | import {SignedMath} from "@openzeppelin-4/contracts/utils/math/SignedMath.sol";
   10 |     | import {StratFeeManagerInitializable, IFeeConfig} from "../StratFeeManagerInitializable.sol";
   11 |     | import {IVeloPool} from "../../interfaces/velodrome/IVeloPool.sol";
   12 |     | import {IVeloRouter} from "../../interfaces/velodrome/IVeloRouter.sol";
   13 |     | import {LiquidityAmounts} from "../../utils/LiquidityAmounts.sol";
   14 |     | import {TickMath} from "../../utils/TickMath.sol";
   15 |     | import {TickUtils, FullMath} from "../../utils/TickUtils.sol";
   16 |     | import {VeloSwapUtils} from "../../utils/VeloSwapUtils.sol";
   17 |     | import {IBeefyVaultConcLiq} from "../../interfaces/beefy/IBeefyVaultConcLiq.sol";
   18 |     | import {IStrategyConcLiq} from "../../interfaces/beefy/IStrategyConcLiq.sol";
   19 |     | import {IStrategyVelodrome} from "../../interfaces/beefy/IStrategyVelodrome.sol";
   20 |     | import {IStrategyFactory} from "../../interfaces/beefy/IStrategyFactory.sol";
   21 |     | import {INftPositionManager} from "../../interfaces/velodrome/INftPositionManager.sol";
   22 |     | import {ICLGauge} from "../../interfaces/velodrome/ICLGauge.sol";
   23 |     | import {IRewardPool} from "../../interfaces/beefy/IRewardPool.sol";
   24 |     | import {IQuoter} from "../../interfaces/uniswap/IQuoter.sol";
   25 |     | import {UniV3Utils} from "../../utils/UniV3Utils.sol";
   26 |     | 
   27 |     | /// @title Beefy Passive Position Manager. Version: Velodrome
   28 |     | /// @author weso, Beefy
   29 |     | /// @notice This is a contract for managing a passive concentrated liquidity position on Velodrome.
   30 | *   | contract StrategyPassiveManagerVelodrome is
   31 |     |     StratFeeManagerInitializable,
   32 |     |     IStrategyConcLiq,
   33 |     |     IStrategyVelodrome
   34 |     | {
   35 |     |     using SafeERC20 for IERC20Metadata;
   36 |     |     using TickMath for int24;
   37 |     | 
   38 |     |     /// @notice The precision for pricing.
   39 |     |     uint256 private constant PRECISION = 1e36;
   40 |     |     uint256 private constant SQRT_PRECISION = 1e18;
   41 |     | 
   42 |     |     /// @notice The max and min ticks univ3 allows.
   43 |     |     int56 private constant MIN_TICK = -887272;
   44 |     |     int56 private constant MAX_TICK = 887272;
   45 |     | 
   46 |     |     /// @notice The address of the Velodrome pool.
   47 |     |     address public pool;
   48 |     |     /// @notice The address of the quoter.
   49 |     |     //audit-info What's the quoter ?
   50 |     |     address public quoter;
   51 |     |     /// @notice The address of the NFT position manager.
   52 |     |     address public nftManager;
   53 |     |     /// @notice The address of the gauge.
   54 |     |     //audit-info What's the gauge ?
   55 |     |     address public gauge;
   56 |     |     /// @notice The address of the output.
   57 |     |     address public output;
   58 |     |     /// @notice The address of the first token in the liquidity pool.
   59 |     |     address public lpToken0;
   60 |     |     /// @notice The address of the second token in the liquidity pool.
   61 |     |     address public lpToken1;
   62 |     |     /// @notice The address of the rewardPool.
   63 |     |     //audit-info What's the reward pool ? @mody: on beefy, you can stake your reipt beef tokens and get rewards on them with another native token
   64 |     |     address public rewardPool;
   65 |     | 
   66 |     |     /// @notice The amount of unharvested output in the strategy.
   67 |     |     uint256 public fees;
   68 |     | 
   69 |     |     /// @notice The path to swap the output to the native token for fee harvesting.
   70 |     |     bytes public outputToNativePath;
   71 |     |     /// @notice The path to swap the first token to the native token for data pricing.
   72 |     |     bytes public lpToken0ToNativePath;
   73 |     |     /// @notice The path to swap the second token to the native token for data pricing.
   74 |     |     bytes public lpToken1ToNativePath;
   75 |     | 
   76 |     |     /// @notice The struct to store our tick positioning.
   77 |     |     struct Position {
   78 |     |         uint256 nftId;
   79 |     |         int24 tickLower;
   80 |     |         int24 tickUpper;
   81 |     |     }
   82 |     | 
   83 |     |     /// @notice The main position of the strategy.
   84 |     |     /// @dev this will always be a 50/50 position that will be equal to position width * tickSpacing on each side.
   85 |     |     Position public positionMain;
   86 |     | 
   87 |     |     /// @notice The alternative position of the strategy.
   88 |     |     /// @dev this will always be a single sided (limit order) position that will start closest to current tick and continue to width * tickSpacing.
   89 |     |     /// This will always be in the token that has the most value after we fill our main position.
   90 |     |     //audit Invariant: Alternative Position SHOULD always be in the token that has the most value
   91 |     |     Position public positionAlt;
   92 |     | 
   93 |     |     /// @notice The width of the position, thats a multiplier for tick spacing to find our range.
   94 |     |     //audit-info Who set's that and can it be modify ? In what term ?
   95 |     |     int24 public positionWidth;
   96 |     | 
   97 |     |     /// @notice the max tick deviations we will allow for deposits/setTick.
   98 |     |     //audit-info Who set's that and can it be modify ? In what term ?
   99 |     |     int56 public maxTickDeviation;
  100 |     | 
  101 |     |     /// @notice The twap interval seconds we use for the twap check.
  102 |     |     uint32 public twapInterval;
  103 |     | 
  104 |     |     /// @notice Initializes the ticks on first deposit.
  105 |     |     bool private initTicks;
  106 |     | 
  107 |     |     // Errors
  108 |     |     error NotAuthorized();
  109 |     |     error NotPool();
  110 |     |     error InvalidEntry();
  111 |     |     error NotVault();
  112 |     |     error InvalidInput();
  113 |     |     error InvalidOutput();
  114 |     |     error NotCalm();
  115 |     |     error TooMuchSlippage();
  116 |     | 
  117 |     |     // Events
  118 |     |     event TVL(uint256 bal0, uint256 bal1);
  119 |     |     event Harvest(uint256 fees);
  120 |     |     event SetPositionWidth(int24 oldWidth, int24 width);
  121 |     |     event SetDeviation(int56 maxTickDeviation);
  122 |     |     event SetTwapInterval(uint32 oldInterval, uint32 interval);
  123 |     |     event SetOutputToNativePath(bytes path);
  124 |     |     event SetRewardPool(address rewardPool);
  125 |     |     event ChargedFees(
  126 |     |         uint256 callFeeAmount,
  127 |     |         uint256 beefyFeeAmount,
  128 |     |         uint256 strategistFeeAmount
  129 |     |     );
  130 |     |     event ClaimedFees(uint256 fees);
  131 |     | 
  132 |     |     /// @notice Modifier to only allow deposit/setTick actions when current price is within a certain deviation of twap.
  133 |     |     modifier onlyCalmPeriods() {
  134 |     |         _onlyCalmPeriods();
  135 |     |         _;
  136 |     |     }
  137 |     | 
  138 |     |     /// @notice function to only allow deposit/setTick actions when current price is within a certain deviation of twap.
  139 |     |     function _onlyCalmPeriods() private view {
  140 |     |         if (!isCalm()) revert NotCalm();
  141 |     |     }
  142 |     | 
  143 |     |     //audit-info Assuming the rebalancer is the Gelato bot
  144 |     |     modifier onlyRebalancers() {
  145 |     |         if (!IStrategyFactory(factory).rebalancers(msg.sender))
  146 |     |             revert NotAuthorized();
  147 |     |         _;
  148 |     |     }
  149 |     | 
  150 |     |     /// @notice function to only allow deposit/setTick actions when current price is within a certain deviation of twap.
  151 |     |     //audit Crutial function imo
  152 |     |     function isCalm() public view returns (bool) {
  153 |     |         int24 tick = currentTick();
  154 |     |         int56 twapTick = twap();
  155 |     | 
  156 |     |         int56 minCalmTick = int56(
  157 |     |             SignedMath.max(twapTick - maxTickDeviation, MIN_TICK)
  158 |     |         );
  159 |     |         int56 maxCalmTick = int56(
  160 |     |             SignedMath.min(twapTick + maxTickDeviation, MAX_TICK)
  161 |     |         );
  162 |     | 
  163 |     |         // Calculate if tick move more than allowed from twap and revert if it did.
  164 |     |         if (minCalmTick > tick || maxCalmTick < tick) return false;
  165 |     |         else return true;
  166 |     |     }
  167 |     | 
  168 |     |     /**
  169 |     |      * @notice Initializes the strategy and the inherited strat fee manager.
  170 |     |      * @dev Make sure cardinality is set appropriately for the twap.
  171 |     |      * @param _pool The underlying Velodrome pool.
  172 |     |      * @param _nftManager The NFT position manager.
  173 |     |      * @param _output The output token for the strategy.
  174 |     |      * @param _positionWidth The multiplier for tick spacing to find our range.
  175 |     |      * @param _paths The bytes paths for swapping (Output To Native, Token0 to Native, Token1 to Native).
  176 |     |      * @param _commonAddresses The common addresses needed for the strat fee manager.
  177 |     |      */
  178 | *   |     function initialize(
  179 |     |         address _pool,
  180 |     |         address _quoter,
  181 |     |         address _nftManager,
  182 |     |         address _gauge,
  183 |     |         address _rewardPool,
  184 |     |         address _output,
  185 |     |         int24 _positionWidth,
  186 |     |         bytes[] calldata _paths,
  187 |     |         CommonAddresses calldata _commonAddresses
  188 |     |     ) external initializer {
  189 | *   |         __StratFeeManager_init(_commonAddresses);
  190 |     | 
  191 | *   |         pool = _pool;
  192 | *   |         quoter = _quoter;
  193 | *   |         output = _output;
  194 | *   |         nftManager = _nftManager;
  195 | *   |         gauge = _gauge;
  196 | *   |         rewardPool = _rewardPool;
  197 |     | 
  198 | *   |         lpToken0 = IVeloPool(_pool).token0();
  199 |     |         lpToken1 = IVeloPool(_pool).token1();
  200 |     | 
  201 |     |         // Our width multiplier. The tick distance of each side will be width * tickSpacing.
  202 |     |         positionWidth = _positionWidth;
  203 |     | 
  204 |     |         outputToNativePath = _paths[0];
  205 |     |         lpToken0ToNativePath = _paths[1];
  206 |     |         lpToken1ToNativePath = _paths[2];
  207 |     | 
  208 |     |         // Set the twap interval to 120 seconds.
  209 |     |         twapInterval = 120;
  210 |     | 
  211 |     |         _giveAllowances();
  212 |     |     }
  213 |     | 
  214 |     |     /// @notice Only allows the vault to call a function.
  215 |     |     //audit Can the vault address be changed ?
  216 |     |     function _onlyVault() private view {
  217 |     |         if (msg.sender != vault) revert NotVault();
  218 |     |     }
  219 |     | 
  220 |     |     /// @notice Called during deposit and withdraw to remove liquidity and harvest fees for accounting purposes.
  221 | *   |     function beforeAction() external {
  222 |     |         _onlyVault();
  223 |     |         _claimEarnings();
  224 | *   |         _removeLiquidity();
  225 |     |     }
  226 |     | 
  227 |     |     /// @notice Called during deposit to add all liquidity back to their positions.
  228 |     |     function deposit() external onlyCalmPeriods {
  229 |     |         _onlyVault();
  230 |     | 
  231 |     |         if (!initTicks) {
  232 |     |             _setTicks();
  233 |     |             initTicks = true;
  234 |     |         }
  235 |     | 
  236 |     |         // Add all liquidity
  237 |     |         _addLiquidity();
  238 |     | 
  239 |     |         (uint256 bal0, uint256 bal1) = balances();
  240 |     | 
  241 |     |         // TVL Balances after deposit
  242 |     |         emit TVL(bal0, bal1);
  243 |     |     }
  244 |     | 
  245 |     |     /**
  246 |     |      * @notice Withdraws the specified amount of tokens from the strategy as calculated by the vault.
  247 |     |      * @param _amount0 The amount of token0 to withdraw.
  248 |     |      * @param _amount1 The amount of token1 to withdraw.
  249 |     |      */
  250 |     |     function withdraw(uint256 _amount0, uint256 _amount1) external {
  251 |     |         _onlyVault();
  252 |     | 
  253 |     |         // Liquidity has already been removed in beforeAction() so this is just a simple withdraw.
  254 |     |         if (_amount0 > 0)
  255 |     |             IERC20Metadata(lpToken0).safeTransfer(vault, _amount0);
  256 |     |         if (_amount1 > 0)
  257 |     |             IERC20Metadata(lpToken1).safeTransfer(vault, _amount1);
  258 |     | 
  259 |     |         // After we take what is needed we add it all back to our positions.
  260 |     |         if (!_isPaused()) _addLiquidity();
  261 |     | 
  262 |     |         (uint256 bal0, uint256 bal1) = balances();
  263 |     | 
  264 |     |         // TVL Balances after withdraw
  265 |     |         emit TVL(bal0, bal1);
  266 |     |     }
  267 |     | 
  268 |     |     /// @notice Adds liquidity to the main and alternative positions called on deposit, harvest and withdraw.
  269 |     |     function _addLiquidity() private {
  270 |     |         _whenStrategyNotPaused(); //revert if the Stategy is Paused
  271 |     | 
  272 |     |         (uint256 bal0, uint256 bal1) = balancesOfThis();
  273 |     | 
  274 |     |         int24 mainLower = positionMain.tickLower; //get the tick Lower of Main position
  275 |     |         int24 mainUpper = positionMain.tickUpper; //get the tick Upper of Main position
  276 |     |         int24 altLower = positionAlt.tickLower; //get the tick Lower of Alt position
  277 |     |         int24 altUpper = positionAlt.tickUpper; //get the tick Upper of Alt position
  278 |     | 
  279 |     |         // Then we fetch how much liquidity we get for adding at the main position ticks with our token balances.
  280 |     |         uint160 sqrtprice = sqrtPrice();
  281 |     |         uint128 liquidity = LiquidityAmounts.getLiquidityForAmounts(
  282 |     |             sqrtprice,
  283 |     |             TickMath.getSqrtRatioAtTick(mainLower),
  284 |     |             TickMath.getSqrtRatioAtTick(mainUpper),
  285 |     |             bal0,
  286 |     |             bal1
  287 |     |         );
  288 |     | 
  289 |     |         (uint256 amount0, uint256 amount1) = LiquidityAmounts
  290 |     |             .getAmountsForLiquidity(
  291 |     |                 sqrtprice,
  292 |     |                 TickMath.getSqrtRatioAtTick(mainLower),
  293 |     |                 TickMath.getSqrtRatioAtTick(mainUpper),
  294 |     |                 liquidity
  295 |     |             );
  296 |     | 
  297 |     |         bool amountsOk = _checkAmounts(liquidity, mainLower, mainUpper);
  298 |     | 
  299 |     |         // Mint or add liquidity to the position.
  300 |     |         if (liquidity > 0 && amountsOk) {
  301 |     |             //audit-info Mint position if the user has some liquidity in main
  302 |     |             _mintPosition(mainLower, mainUpper, amount0, amount1, true);
  303 |     |         }
  304 |     | 
  305 |     |         (bal0, bal1) = balancesOfThis();
  306 |     | 
  307 |     |         // Fetch how much liquidity we get for adding at the alternative position ticks with our token balances.
  308 |     |         liquidity = LiquidityAmounts.getLiquidityForAmounts(
  309 |     |             sqrtprice,
  310 |     |             TickMath.getSqrtRatioAtTick(altLower),
  311 |     |             TickMath.getSqrtRatioAtTick(altUpper),
  312 |     |             bal0,
  313 |     |             bal1
  314 |     |         );
  315 |     | 
  316 |     |         (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(
  317 |     |             sqrtprice,
  318 |     |             TickMath.getSqrtRatioAtTick(altLower),
  319 |     |             TickMath.getSqrtRatioAtTick(altUpper),
  320 |     |             liquidity
  321 |     |         );
  322 |     | 
  323 |     |         // Mint or add liquidity to the position.
  324 |     |         if (liquidity > 0 && (amount0 > 0 || amount1 > 0)) {
  325 |     |             //audit-info Mint position if the user has some liquidity in alt
  326 |     |             _mintPosition(altLower, altUpper, amount0, amount1, false);
  327 |     |         }
  328 |     | 
  329 |     |         if (positionMain.nftId != 0)
  330 |     |             ICLGauge(gauge).deposit(positionMain.nftId);
  331 |     |         if (positionAlt.nftId != 0) ICLGauge(gauge).deposit(positionAlt.nftId);
  332 |     |     }
  333 |     | 
  334 |     |     /// @notice Mints a new position for the main or alternative position.
  335 |     |     function _mintPosition(
  336 |     |         int24 _tickLower,
  337 |     |         int24 _tickUpper,
  338 |     |         uint256 _amount0,
  339 |     |         uint256 _amount1,
  340 |     |         bool _mainPosition
  341 |     |     ) private {
  342 |     |         INftPositionManager.MintParams memory mintParams = INftPositionManager
  343 |     |             .MintParams({
  344 |     |                 token0: lpToken0,
  345 |     |                 token1: lpToken1,
  346 |     |                 tickSpacing: _tickDistance(),
  347 |     |                 tickLower: _tickLower,
  348 |     |                 tickUpper: _tickUpper,
  349 |     |                 amount0Desired: _amount0,
  350 |     |                 amount1Desired: _amount1,
  351 |     |                 amount0Min: 0,
  352 |     |                 amount1Min: 0,
  353 |     |                 recipient: address(this),
  354 |     |                 deadline: block.timestamp,
  355 |     |                 sqrtPriceX96: 0
  356 |     |             });
  357 |     | 
  358 |     |         (uint256 nftId, , , ) = INftPositionManager(nftManager).mint(
  359 |     |             mintParams
  360 |     |         );
  361 |     | 
  362 |     |         if (_mainPosition) positionMain.nftId = nftId;
  363 |     |         else positionAlt.nftId = nftId;
  364 |     | 
  365 |     |         IERC721(nftManager).approve(gauge, nftId);
  366 |     |     }
  367 |     | 
  368 |     |     /// @notice Removes liquidity from the main and alternative positions, called on deposit, withdraw and harvest.
  369 |     |     function _removeLiquidity() private {
  370 |     |         uint128 liquidity;
  371 |     |         uint128 liquidityAlt;
  372 |     |         if (positionMain.nftId != 0) {
  373 |     |             (, , , , , , , liquidity, , , , ) = INftPositionManager(nftManager)
  374 |     |                 .positions(positionMain.nftId);
  375 |     |             ICLGauge(gauge).withdraw(positionMain.nftId);
  376 |     |         }
  377 |     | 
  378 |     |         if (positionAlt.nftId != 0) {
  379 |     |             (, , , , , , , liquidityAlt, , , , ) = INftPositionManager(
  380 |     |                 nftManager
  381 |     |             ).positions(positionAlt.nftId);
  382 |     |             ICLGauge(gauge).withdraw(positionAlt.nftId);
  383 |     |         }
  384 |     | 
  385 |     |         // init our params
  386 |     |         INftPositionManager.DecreaseLiquidityParams
  387 |     |             memory decreaseLiquidityParams;
  388 |     |         INftPositionManager.CollectParams memory collectParams;
  389 |     | 
  390 |     |         // If we have liquidity in the positions we remove it and collect our tokens.
  391 |     |         if (liquidity > 0) {
  392 |     |             decreaseLiquidityParams = INftPositionManager
  393 |     |                 .DecreaseLiquidityParams({
  394 |     |                     tokenId: positionMain.nftId,
  395 |     |                     liquidity: liquidity,
  396 |     |                     amount0Min: 0,
  397 |     |                     amount1Min: 0,
  398 |     |                     deadline: block.timestamp
  399 |     |                 });
  400 |     |             //audit Is it possible to have 0 liquidity and still have some fees left to collect ?
  401 |     |             //audit If that's the case, the fees aren't collected, and the positions isn't burn.
  402 |     |             collectParams = INftPositionManager.CollectParams({
  403 |     |                 tokenId: positionMain.nftId,
  404 |     |                 recipient: address(this),
  405 |     |                 amount0Max: type(uint128).max,
  406 |     |                 amount1Max: type(uint128).max
  407 |     |             });
  408 |     | 
  409 |     |             INftPositionManager(nftManager).decreaseLiquidity(
  410 |     |                 decreaseLiquidityParams
  411 |     |             );
  412 |     |             INftPositionManager(nftManager).collect(collectParams);
  413 |     |             INftPositionManager(nftManager).burn(positionMain.nftId);
  414 |     |             positionMain.nftId = 0;
  415 |     |         }
  416 |     | 
  417 |     |         if (liquidityAlt > 0) {
  418 |     |             decreaseLiquidityParams = INftPositionManager
  419 |     |                 .DecreaseLiquidityParams({
  420 |     |                     tokenId: positionAlt.nftId,
  421 |     |                     liquidity: liquidityAlt,
  422 |     |                     amount0Min: 0,
  423 |     |                     amount1Min: 0,
  424 |     |                     deadline: block.timestamp
  425 |     |                 });
  426 |     | 
  427 |     |             collectParams = INftPositionManager.CollectParams({
  428 |     |                 tokenId: positionAlt.nftId,
  429 |     |                 recipient: address(this),
  430 |     |                 amount0Max: type(uint128).max,
  431 |     |                 amount1Max: type(uint128).max
  432 |     |             });
  433 |     | 
  434 |     |             INftPositionManager(nftManager).decreaseLiquidity(
  435 |     |                 decreaseLiquidityParams
  436 |     |             );
  437 |     |             INftPositionManager(nftManager).collect(collectParams);
  438 |     |             INftPositionManager(nftManager).burn(positionAlt.nftId);
  439 |     |             positionAlt.nftId = 0;
  440 |     |         }
  441 |     |     }
  442 |     | 
  443 |     |     /**
  444 |     |      *  @notice Checks if the amounts are ok to add liquidity.
  445 |     |      * @param _liquidity The liquidity to add.
  446 |     |      * @param _tickLower The lower tick of the position.
  447 |     |      * @param _tickUpper The upper tick of the position.
  448 |     |      * @return bool True if the amounts are ok, false if not.
  449 |     |      */
  450 |     |     function _checkAmounts(
  451 |     |         uint128 _liquidity,
  452 |     |         int24 _tickLower,
  453 |     |         int24 _tickUpper
  454 |     |     ) private view returns (bool) {
  455 |     |         (uint256 amount0, uint256 amount1) = LiquidityAmounts
  456 |     |             .getAmountsForLiquidity(
  457 |     |                 sqrtPrice(),
  458 |     |                 TickMath.getSqrtRatioAtTick(_tickLower),
  459 |     |                 TickMath.getSqrtRatioAtTick(_tickUpper),
  460 |     |                 _liquidity
  461 |     |             );
  462 |     | 
  463 |     |         if (amount0 == 0 || amount1 == 0) return false;
  464 |     |         else return true;
  465 |     |     }
  466 |     | 
  467 |     |     /// @notice Function called to rebalance the position
  468 |     |     function moveTicks() external onlyCalmPeriods onlyRebalancers {
  469 |     |         _claimEarnings();
  470 |     |         _removeLiquidity();
  471 |     |         _setTicks();
  472 |     |         _addLiquidity();
  473 |     | 
  474 |     |         (uint256 bal0, uint256 bal1) = balances();
  475 |     |         emit TVL(bal0, bal1);
  476 |     |     }
  477 |     | 
  478 |     |     /// @notice Harvest call to claim rewards from gauge then charge fees for Beefy and notify rewards.
  479 |     |     /// @param _callFeeRecipient The address to send the call fee to.
  480 | *   |     function harvest(address _callFeeRecipient) external {
  481 | *   |         _harvest(_callFeeRecipient);
  482 |     |     }
  483 |     | 
  484 |     |     /// @notice Harvest call to claim rewards from gauge then charge fees for Beefy and notify rewards.
  485 |     |     /// @dev Call fee goes to the tx.origin.
  486 |     |     function harvest() external {
  487 |     |         //audit-info Why not use msg.sender ? Account Abstraction EIP4337 is not compatible
  488 |     |         _harvest(tx.origin);
  489 |     |     }
  490 |     | 
  491 |     |     /// @notice Internal function to claim rewards from gauge then charge fees for Beefy and notify rewards
  492 |     |     function _harvest(address _callFeeRecipient) private {
  493 |     |         // Claim rewards from gauge
  494 |     |         _claimEarnings();
  495 |     | 
  496 |     |         // Charge fees for Beefy and send them to the appropriate addresses, charge fees to accrued state fee amounts.
  497 |     |         uint256 feeLeft = _chargeFees(_callFeeRecipient, fees);
  498 |     | 
  499 |     |         // Reset state fees to 0.
  500 |     |         fees = 0;
  501 |     | 
  502 |     |         // Notify rewards with our velo.
  503 |     |         IRewardPool(rewardPool).notifyRewardAmount(output, feeLeft, 1 days);
  504 |     | 
  505 |     |         // Log the last time we claimed fees.
  506 |     |         lastHarvest = block.timestamp;
  507 |     | 
  508 |     |         // Log the fees post Beefy fees.
  509 |     |         emit Harvest(feeLeft);
  510 |     |     }
  511 |     | 
  512 |     |     /// @notice Internal function to claim rewards from the gauge and collect them.
  513 |     |     function _claimEarnings() private {
  514 |     |         // Claim rewards
  515 |     |         uint256 feeBefore = IERC20Metadata(output).balanceOf(address(this));
  516 |     | 
  517 |     |         //audit-info How this is working ? Is this contract suppose to receive some tokens ?
  518 |     |         if (positionMain.nftId != 0)
  519 |     |             ICLGauge(gauge).getReward(positionMain.nftId);
  520 |     |         if (positionAlt.nftId != 0)
  521 |     |             ICLGauge(gauge).getReward(positionAlt.nftId);
  522 |     | 
  523 |     |         uint256 claimed = IERC20Metadata(output).balanceOf(address(this)) -
  524 |     |             feeBefore;
  525 |     |         fees = fees + claimed;
  526 |     | 
  527 |     |         emit ClaimedFees(claimed);
  528 |     |     }
  529 |     | 
  530 |     |     /**
  531 |     |      * @notice Internal function to charge fees for Beefy and send them to the appropriate addresses.
  532 |     |      * @param _callFeeRecipient The address to send the call fee to.
  533 |     |      * @param _amount The amount of output to charge fees on.
  534 |     |      * @return _amountLeft The amount of token0 left after fees.
  535 |     |      */
  536 |     |     function _chargeFees(
  537 |     |         address _callFeeRecipient,
  538 |     |         uint256 _amount
  539 |     |     ) private returns (uint256 _amountLeft) {
  540 |     |         /// Fetch our fee percentage amounts from the fee config.
  541 |     |         IFeeConfig.FeeCategory memory fee = getFees();
  542 |     | 
  543 |     |         /// We calculate how much to swap and then swap both tokens to native and charge fees.
  544 |     |         uint256 nativeEarned;
  545 |     |         if (_amount > 0) {
  546 |     |             // Calculate amount of token 0 to swap for fees.
  547 |     |             uint256 amountToSwap = (_amount * fee.total) / DIVISOR;
  548 |     |             _amountLeft = _amount - amountToSwap;
  549 |     | 
  550 |     |             // If token0 is not native, swap to native the fee amount.
  551 |     |             uint256 out;
  552 |     |             uint256 nativeBefore = IERC20Metadata(native).balanceOf(
  553 |     |                 address(this)
  554 |     |             );
  555 |     |             if (output != native) {
  556 |     |                 VeloSwapUtils.swap(
  557 |     |                     unirouter,
  558 |     |                     outputToNativePath,
  559 |     |                     amountToSwap,
  560 |     |                     true
  561 |     |                 );
  562 |     |                 out =
  563 |     |                     IERC20Metadata(native).balanceOf(address(this)) -
  564 |     |                     nativeBefore;
  565 |     |             }
  566 |     | 
  567 |     |             // Add the native earned to the total of native we earned for beefy fees, handle if token0 is native.
  568 |     |             if (output == native) nativeEarned += amountToSwap;
  569 |     |             else nativeEarned += out;
  570 |     |         }
  571 |     | 
  572 |     |         // Distribute the native earned to the appropriate addresses.
  573 |     |         uint256 callFeeAmount = (nativeEarned * fee.call) / DIVISOR;
  574 |     |         IERC20Metadata(native).safeTransfer(_callFeeRecipient, callFeeAmount);
  575 |     | 
  576 |     |         uint256 strategistFeeAmount = (nativeEarned * fee.strategist) / DIVISOR;
  577 |     |         IERC20Metadata(native).safeTransfer(strategist, strategistFeeAmount);
  578 |     | 
  579 |     |         uint256 beefyFeeAmount = nativeEarned -
  580 |     |             callFeeAmount -
  581 |     |             strategistFeeAmount;
  582 |     |         IERC20Metadata(native).safeTransfer(
  583 |     |             beefyFeeRecipient(),
  584 |     |             beefyFeeAmount
  585 |     |         );
  586 |     | 
  587 |     |         emit ChargedFees(callFeeAmount, beefyFeeAmount, strategistFeeAmount);
  588 |     |     }
  589 |     | 
  590 |     |     /**
  591 |     |      * @notice Returns total token balances in the strategy.
  592 |     |      * @return token0Bal The amount of token0 in the strategy.
  593 |     |      * @return token1Bal The amount of token1 in the strategy.
  594 |     |      */
  595 |     |     function balances()
  596 |     |         public
  597 |     |         view
  598 |     |         returns (uint256 token0Bal, uint256 token1Bal)
  599 |     |     {
  600 |     |         (uint256 thisBal0, uint256 thisBal1) = balancesOfThis();
  601 |     |         (uint256 poolBal0, uint256 poolBal1, , , , ) = balancesOfPool();
  602 |     | 
  603 |     |         uint256 total0 = thisBal0 + poolBal0;
  604 |     |         uint256 total1 = thisBal1 + poolBal1;
  605 |     | 
  606 |     |         // For token0 and token1 we return balance of this contract + balance of positions - feesUnharvested.
  607 |     |         return (total0, total1);
  608 |     |     }
  609 |     | 
  610 |     |     /**
  611 |     |      * @notice Returns total tokens sitting in the strategy.
  612 |     |      * @return token0Bal The amount of token0 in the strategy.
  613 |     |      * @return token1Bal The amount of token1 in the strategy.
  614 |     |      */
  615 |     |     function balancesOfThis()
  616 |     |         public
  617 |     |         view
  618 |     |         returns (uint256 token0Bal, uint256 token1Bal)
  619 |     |     {
  620 |     |         return (
  621 |     |             IERC20Metadata(lpToken0).balanceOf(address(this)),
  622 |     |             IERC20Metadata(lpToken1).balanceOf(address(this))
  623 |     |         );
  624 |     |     }
  625 |     | 
  626 |     |     /**
  627 |     |      * @notice Returns total tokens in pool positions (is a calculation which means it could be a little off by a few wei).
  628 |     |      * @return token0Bal The amount of token0 in the pool.
  629 |     |      * @return token1Bal The amount of token1 in the pool.
  630 |     |      * @return mainAmount0 The amount of token0 in the main position.
  631 |     |      * @return mainAmount1 The amount of token1 in the main position.
  632 |     |      * @return altAmount0 The amount of token0 in the alt position.
  633 |     |      * @return altAmount1 The amount of token1 in the alt position.
  634 |     |      */
  635 |     |     function balancesOfPool()
  636 |     |         public
  637 |     |         view
  638 |     |         returns (
  639 |     |             uint256 token0Bal,
  640 |     |             uint256 token1Bal,
  641 |     |             uint256 mainAmount0,
  642 |     |             uint256 mainAmount1,
  643 |     |             uint256 altAmount0,
  644 |     |             uint256 altAmount1
  645 |     |         )
  646 |     |     {
  647 |     |         uint160 sqrtPriceX96 = sqrtPrice();
  648 |     | 
  649 |     |         uint128 liquidity;
  650 |     |         uint128 altLiquidity;
  651 |     |         uint256 owed0;
  652 |     |         uint256 owed1;
  653 |     |         uint256 altOwed0;
  654 |     |         uint256 altOwed1;
  655 |     |         if (positionMain.nftId != 0)
  656 |     |             (, , , , , , , liquidity, , , owed0, owed1) = INftPositionManager(
  657 |     |                 nftManager
  658 |     |             ).positions(positionMain.nftId);
  659 |     |         if (positionAlt.nftId != 0)
  660 |     |             (
  661 |     |                 ,
  662 |     |                 ,
  663 |     |                 ,
  664 |     |                 ,
  665 |     |                 ,
  666 |     |                 ,
  667 |     |                 ,
  668 |     |                 altLiquidity,
  669 |     |                 ,
  670 |     |                 ,
  671 |     |                 altOwed0,
  672 |     |                 altOwed1
  673 |     |             ) = INftPositionManager(nftManager).positions(positionAlt.nftId);
  674 |     | 
  675 |     |         (mainAmount0, mainAmount1) = LiquidityAmounts.getAmountsForLiquidity(
  676 |     |             sqrtPriceX96,
  677 |     |             TickMath.getSqrtRatioAtTick(positionMain.tickLower),
  678 |     |             TickMath.getSqrtRatioAtTick(positionMain.tickUpper),
  679 |     |             liquidity
  680 |     |         );
  681 |     | 
  682 |     |         (altAmount0, altAmount1) = LiquidityAmounts.getAmountsForLiquidity(
  683 |     |             sqrtPriceX96,
  684 |     |             TickMath.getSqrtRatioAtTick(positionAlt.tickLower),
  685 |     |             TickMath.getSqrtRatioAtTick(positionAlt.tickUpper),
  686 |     |             altLiquidity
  687 |     |         );
  688 |     | 
  689 |     |         mainAmount0 += owed0;
  690 |     |         mainAmount1 += owed1;
  691 |     | 
  692 |     |         altAmount0 += altOwed0;
  693 |     |         altAmount1 += altOwed1;
  694 |     | 
  695 |     |         token0Bal = mainAmount0 + altAmount0;
  696 |     |         token1Bal = mainAmount1 + altAmount1;
  697 |     |     }
  698 |     | 
  699 |     |     /**
  700 |     |      * @notice Returns the range of the pool, will always be the main position.
  701 |     |      * @return lowerPrice The lower price of the position.
  702 |     |      * @return upperPrice The upper price of the position.
  703 |     |      */
  704 |     |     function range()
  705 |     |         external
  706 |     |         view
  707 |     |         returns (uint256 lowerPrice, uint256 upperPrice)
  708 |     |     {
  709 |     |         // the main position is always covering the alt range
  710 |     |         lowerPrice =
  711 |     |             FullMath.mulDiv(
  712 |     |                 uint256(TickMath.getSqrtRatioAtTick(positionMain.tickLower)),
  713 |     |                 SQRT_PRECISION,
  714 |     |                 (2 ** 96)
  715 |     |             ) **
  716 |     |                 2;
  717 |     |         upperPrice =
  718 |     |             FullMath.mulDiv(
  719 |     |                 uint256(TickMath.getSqrtRatioAtTick(positionMain.tickUpper)),
  720 |     |                 SQRT_PRECISION,
  721 |     |                 (2 ** 96)
  722 |     |             ) **
  723 |     |                 2;
  724 |     |     }
  725 |     | 
  726 |     |     /**
  727 |     |      * @notice The current tick of the pool.
  728 |     |      * @return tick The current tick of the pool.
  729 |     |      */
  730 |     |     function currentTick() public view returns (int24 tick) {
  731 |     |         //audit Is the current tick can be manipulable like the spot price ?
  732 |     |         (, tick, , , , ) = IVeloPool(pool).slot0();
  733 |     |     }
  734 |     | 
  735 |     |     /**
  736 |     |      * @notice The current price of the pool.
  737 |     |      * @return _price The current price of the pool.
  738 |     |      */
  739 |     |     function price() public view returns (uint256 _price) {
  740 |     |         uint160 sqrtPriceX96 = sqrtPrice();
  741 |     |         _price =
  742 |     |             FullMath.mulDiv(uint256(sqrtPriceX96), SQRT_PRECISION, (2 ** 96)) **
  743 |     |                 2;
  744 |     |     }
  745 |     | 
  746 |     |     /**
  747 |     |      * @notice The sqrt price of the pool.
  748 |     |      * @return sqrtPriceX96 The sqrt price of the pool.
  749 |     |      */
  750 |     | 
  751 |     |     //audit Watchout, Can be easily manipulated
  752 |     |     function sqrtPrice() public view returns (uint160 sqrtPriceX96) {
  753 |     |         (sqrtPriceX96, , , , , ) = IVeloPool(pool).slot0();
  754 |     |     }
  755 |     | 
  756 |     |     /**
  757 |     |      * @notice The tick distance of the pool.
  758 |     |      * @return int24 The tick distance/spacing of the pool.
  759 |     |      */
  760 |     |     function _tickDistance() private view returns (int24) {
  761 |     |         return IVeloPool(pool).tickSpacing();
  762 |     |     }
  763 |     | 
  764 |     |     /// @notice Sets the tick positions for the main and alternative positions.
  765 |     |     function _setTicks() private onlyCalmPeriods {
  766 |     |         int24 tick = currentTick();
  767 |     |         int24 distance = _tickDistance();
  768 |     |         int24 width = positionWidth * distance;
  769 |     | 
  770 |     |         _setMainTick(tick, distance, width);
  771 |     |         _setAltTick(tick, distance, width);
  772 |     |     }
  773 |     | 
  774 |     |     /// @notice Sets the main tick position.
  775 |     |     function _setMainTick(int24 tick, int24 distance, int24 width) private {
  776 |     |         (positionMain.tickLower, positionMain.tickUpper) = TickUtils.baseTicks(
  777 |     |             tick,
  778 |     |             width,
  779 |     |             distance
  780 |     |         );
  781 |     |     }
  782 |     | 
  783 |     |     /// @notice Sets the alternative tick position.
  784 |     |     function _setAltTick(int24 tick, int24 distance, int24 width) private {
  785 |     |         (uint256 bal0, uint256 bal1) = balancesOfThis();
  786 |     | 
  787 |     |         // We calculate how much token0 we have in the price of token1.
  788 |     |         uint256 amount0;
  789 |     | 
  790 |     |         if (bal0 > 0) {
  791 |     |             //audit price() is spot price and it's manipulable
  792 |     |             amount0 = (bal0 * price()) / PRECISION;
  793 |     |         }
  794 |     | 
  795 |     |         // We set the alternative position based on the token that has the most value available.
  796 |     |         if (amount0 < bal1) {
  797 |     |             (positionAlt.tickLower, ) = TickUtils.baseTicks(
  798 |     |                 tick,
  799 |     |                 width,
  800 |     |                 distance
  801 |     |             );
  802 |     | 
  803 |     |             (positionAlt.tickUpper, ) = TickUtils.baseTicks(
  804 |     |                 tick,
  805 |     |                 distance,
  806 |     |                 distance
  807 |     |             );
  808 |     |         } else if (bal1 < amount0) {
  809 |     |             (, positionAlt.tickLower) = TickUtils.baseTicks(
  810 |     |                 tick,
  811 |     |                 distance,
  812 |     |                 distance
  813 |     |             );
  814 |     | 
  815 |     |             (, positionAlt.tickUpper) = TickUtils.baseTicks(
  816 |     |                 tick,
  817 |     |                 width,
  818 |     |                 distance
  819 |     |             );
  820 |     |         }
  821 |     |     }
  822 |     | 
  823 |     |     /**
  824 |     |      * @notice Sets the path to swap the output token to the native token for fee harvesting.
  825 |     |      * @param _path The path to swap the output token to the native token.
  826 |     |      */
  827 |     |     function setOutputToNativePath(bytes calldata _path) public onlyOwner {
  828 |     |         if (_path.length > 0) {
  829 |     |             address[] memory _route = VeloSwapUtils.pathToRoute(_path);
  830 |     |             if (_route[0] != output) revert InvalidInput();
  831 |     |             if (_route[_route.length - 1] != native) revert InvalidOutput();
  832 |     |             outputToNativePath = _path;
  833 |     |             emit SetOutputToNativePath(_path);
  834 |     |         }
  835 |     |     }
  836 |     | 
  837 |     |     /**
  838 |     |      * @notice Sets the deviation from the twap we will allow on adding liquidity.
  839 |     |      * @param _maxDeviation The max deviation from twap we will allow.
  840 |     |      */
  841 |     |     function setDeviation(int56 _maxDeviation) external onlyOwner {
  842 |     |         emit SetDeviation(_maxDeviation);
  843 |     | 
  844 |     |         // Require the deviation to be less than or equal to 4 times the tick spacing.
  845 |     |         if (_maxDeviation >= _tickDistance() * 4) revert InvalidInput();
  846 |     | 
  847 |     |         maxTickDeviation = _maxDeviation;
  848 |     |     }
  849 |     | 
  850 |     |     /**
  851 |     |      * @notice Returns the route to swap the output token to the native token for fee harvesting.
  852 |     |      * @return address[] The route to swap the output to the native token.
  853 |     |      */
  854 |     |     function outputToNative() public view returns (address[] memory) {
  855 |     |         if (outputToNativePath.length == 0) return new address[](0);
  856 |     |         return VeloSwapUtils.pathToRoute(outputToNativePath);
  857 |     |     }
  858 |     | 
  859 |     |     /// @notice Returns the price of the first token in native token.
  860 |     |     function lpToken0ToNativePrice() public returns (uint256) {
  861 |     |         uint amount = 10 ** IERC20Metadata(lpToken0).decimals() / 10;
  862 |     |         if (lpToken0 == native) return amount;
  863 |     |         return IQuoter(quoter).quoteExactInput(lpToken0ToNativePath, amount);
  864 |     |     }
  865 |     | 
  866 |     |     /// @notice Returns the price of the second token in native token.
  867 |     |     function lpToken1ToNativePrice() public returns (uint256) {
  868 |     |         uint amount = 10 ** IERC20Metadata(lpToken1).decimals() / 10;
  869 |     |         if (lpToken1 == native) return amount;
  870 |     |         return IQuoter(quoter).quoteExactInput(lpToken1ToNativePath, amount);
  871 |     |     }
  872 |     | 
  873 |     |     /**
  874 |     |      * @notice The twap of the last minute from the pool.
  875 |     |      * @return twapTick The twap of the last minute from the pool.
  876 |     |      */
  877 |     |     function twap() public view returns (int56 twapTick) {
  878 |     |         uint32[] memory secondsAgo = new uint32[](2);
  879 |     |         secondsAgo[0] = uint32(twapInterval); //audit-info Why cast it to uint32 when it's already the default type?
  880 |     |         secondsAgo[1] = 0;
  881 |     | 
  882 |     |         (int56[] memory tickCuml, ) = IVeloPool(pool).observe(secondsAgo); //audit-info check on what observe() is doing
  883 |     |         twapTick = (tickCuml[1] - tickCuml[0]) / int32(twapInterval); //audit-ok Pretty safe to downcast to int32 as the max value is 2B.
  884 |     |     }
  885 |     | 
  886 |     |     function setTwapInterval(uint32 _interval) external onlyOwner {
  887 |     |         emit SetTwapInterval(twapInterval, _interval);
  888 |     | 
  889 |     |         // Require the interval to be greater than 60 seconds.
  890 |     |         if (_interval < 60) revert InvalidInput();
  891 |     | 
  892 |     |         twapInterval = _interval;
  893 |     |     }
  894 |     | 
  895 |     |     /**
  896 |     |      * @notice Sets our position width and readjusts our positions.
  897 |     |      * @param _width The new width multiplier of the position.
  898 |     |      */
  899 |     |     function setPositionWidth(int24 _width) external onlyOwner {
  900 |     |         emit SetPositionWidth(positionWidth, _width);
  901 |     |         _claimEarnings();
  902 |     |         _removeLiquidity();
  903 |     |         positionWidth = _width;
  904 |     |         _setTicks();
  905 |     |         _addLiquidity();
  906 |     |     }
  907 |     | 
  908 |     |     /**
  909 |     |      * @notice Sets the reward pool address.
  910 |     |      * @param _rewardPool The new reward pool address.
  911 |     |      */
  912 |     |     function setRewardPool(address _rewardPool) external onlyOwner {
  913 |     |         rewardPool = _rewardPool;
  914 |     |         emit SetRewardPool(_rewardPool);
  915 |     |     }
  916 |     | 
  917 |     |     /**
  918 |     |      * @notice set the unirouter address
  919 |     |      * @param _unirouter The new unirouter address
  920 |     |      */
  921 |     |     function setUnirouter(address _unirouter) external override onlyOwner {
  922 |     |         _removeAllowances();
  923 |     |         unirouter = _unirouter;
  924 |     |         _giveAllowances();
  925 |     |         emit SetUnirouter(_unirouter);
  926 |     |     }
  927 |     | 
  928 |     |     /// @notice Retire the strategy and return all the dust to the fee recipient.
  929 |     |     function retireVault() external onlyOwner {
  930 |     |         if (IBeefyVaultConcLiq(vault).totalSupply() != 10 ** 3)
  931 |     |             revert NotAuthorized();
  932 |     |         panic(0, 0);
  933 |     |         address feeRecipient = beefyFeeRecipient();
  934 |     |         IERC20Metadata(lpToken0).safeTransfer(
  935 |     |             feeRecipient,
  936 |     |             IERC20Metadata(lpToken0).balanceOf(address(this))
  937 |     |         );
  938 |     |         IERC20Metadata(lpToken1).safeTransfer(
  939 |     |             feeRecipient,
  940 |     |             IERC20Metadata(lpToken1).balanceOf(address(this))
  941 |     |         );
  942 |     |         _transferOwnership(address(0));
  943 |     |     }
  944 |     | 
  945 |     |     /**
  946 |     |      * @notice Remove Liquidity and Allowances, then pause deposits.
  947 |     |      * @param _minAmount0 The minimum amount of token0 in the strategy after panic.
  948 |     |      * @param _minAmount1 The minimum amount of token1 in the strategy after panic.
  949 |     |      */
  950 |     |     function panic(
  951 |     |         uint256 _minAmount0,
  952 |     |         uint256 _minAmount1
  953 |     |     ) public onlyManager {
  954 |     |         _claimEarnings();
  955 |     |         _removeLiquidity();
  956 |     |         _removeAllowances();
  957 |     |         _pause();
  958 |     | 
  959 |     |         (uint256 bal0, uint256 bal1) = balances();
  960 |     |         if (bal0 < _minAmount0 || bal1 < _minAmount1) revert TooMuchSlippage();
  961 |     |     }
  962 |     | 
  963 |     |     /// @notice Unpause deposits, give allowances and add liquidity.
  964 |     |     //audit What's the matter of Pause/Unpaused when there are no function using the whenNotPaused() modifier ?
  965 |     |     function unpause() external onlyManager {
  966 |     |         //audit-info how can the owner be the 0 address ?
  967 |     |         if (owner() == address(0)) revert NotAuthorized();
  968 |     | 
  969 |     |         //audit-info Why so many actions only on unpaused ?
  970 |     |         _giveAllowances();
  971 |     |         _unpause();
  972 |     |         _setTicks();
  973 |     |         _addLiquidity();
  974 |     |     }
  975 |     | 
  976 |     |     /// @notice gives swap permisions for the tokens to the unirouter.
  977 |     |     function _giveAllowances() private {
  978 |     |         IERC20Metadata(output).forceApprove(unirouter, type(uint256).max);
  979 |     |         IERC20Metadata(output).forceApprove(rewardPool, type(uint256).max);
  980 |     |         IERC20Metadata(lpToken0).forceApprove(nftManager, type(uint256).max);
  981 |     |         IERC20Metadata(lpToken1).forceApprove(nftManager, type(uint256).max);
  982 |     |     }
  983 |     | 
  984 |     |     /// @notice removes swap permisions for the tokens from the unirouter.
  985 |     |     function _removeAllowances() private {
  986 |     |         IERC20Metadata(output).forceApprove(unirouter, 0);
  987 |     |         IERC20Metadata(output).forceApprove(rewardPool, 0);
  988 |     |         IERC20Metadata(lpToken0).forceApprove(nftManager, 0);
  989 |     |         IERC20Metadata(lpToken1).forceApprove(nftManager, 0);
  990 |     |     }
  991 |     | 
  992 |     |     function onERC721Received(
  993 |     |         address,
  994 |     |         address,
  995 |     |         uint256,
  996 |     |         bytes calldata
  997 |     |     ) external pure returns (bytes4) {
  998 |     |         return this.onERC721Received.selector;
  999 |     |     }
 1000 |     | }
 1001 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/BytesLib.sol
   1 |     | // SPDX-License-Identifier: Unlicense
   2 |     | /*
   3 |     |  * @title Solidity Bytes Arrays Utils
   4 |     |  * @author Gonçalo Sá <goncalo.sa@consensys.net>
   5 |     |  *
   6 |     |  * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.
   7 |     |  *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.
   8 |     |  */
   9 |     | pragma solidity >=0.8.0 <0.9.0;
  10 |     | 
  11 |     | 
  12 |     | library BytesLib {
  13 |     |     function concat(
  14 |     |         bytes memory _preBytes,
  15 |     |         bytes memory _postBytes
  16 |     |     )
  17 |     |     internal
  18 |     |     pure
  19 |     |     returns (bytes memory)
  20 |     |     {
  21 |     |         bytes memory tempBytes;
  22 |     | 
  23 |     |         assembly {
  24 |     |         // Get a location of some free memory and store it in tempBytes as
  25 |     |         // Solidity does for memory variables.
  26 |     |             tempBytes := mload(0x40)
  27 |     | 
  28 |     |         // Store the length of the first bytes array at the beginning of
  29 |     |         // the memory for tempBytes.
  30 |     |             let length := mload(_preBytes)
  31 |     |             mstore(tempBytes, length)
  32 |     | 
  33 |     |         // Maintain a memory counter for the current write location in the
  34 |     |         // temp bytes array by adding the 32 bytes for the array length to
  35 |     |         // the starting location.
  36 |     |             let mc := add(tempBytes, 0x20)
  37 |     |         // Stop copying when the memory counter reaches the length of the
  38 |     |         // first bytes array.
  39 |     |             let end := add(mc, length)
  40 |     | 
  41 |     |             for {
  42 |     |             // Initialize a copy counter to the start of the _preBytes data,
  43 |     |             // 32 bytes into its memory.
  44 |     |                 let cc := add(_preBytes, 0x20)
  45 |     |             } lt(mc, end) {
  46 |     |             // Increase both counters by 32 bytes each iteration.
  47 |     |                 mc := add(mc, 0x20)
  48 |     |                 cc := add(cc, 0x20)
  49 |     |             } {
  50 |     |             // Write the _preBytes data into the tempBytes memory 32 bytes
  51 |     |             // at a time.
  52 |     |                 mstore(mc, mload(cc))
  53 |     |             }
  54 |     | 
  55 |     |         // Add the length of _postBytes to the current length of tempBytes
  56 |     |         // and store it as the new length in the first 32 bytes of the
  57 |     |         // tempBytes memory.
  58 |     |             length := mload(_postBytes)
  59 |     |             mstore(tempBytes, add(length, mload(tempBytes)))
  60 |     | 
  61 |     |         // Move the memory counter back from a multiple of 0x20 to the
  62 |     |         // actual end of the _preBytes data.
  63 |     |             mc := end
  64 |     |         // Stop copying when the memory counter reaches the new combined
  65 |     |         // length of the arrays.
  66 |     |             end := add(mc, length)
  67 |     | 
  68 |     |             for {
  69 |     |                 let cc := add(_postBytes, 0x20)
  70 |     |             } lt(mc, end) {
  71 |     |                 mc := add(mc, 0x20)
  72 |     |                 cc := add(cc, 0x20)
  73 |     |             } {
  74 |     |                 mstore(mc, mload(cc))
  75 |     |             }
  76 |     | 
  77 |     |         // Update the free-memory pointer by padding our last write location
  78 |     |         // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
  79 |     |         // next 32 byte block, then round down to the nearest multiple of
  80 |     |         // 32. If the sum of the length of the two arrays is zero then add
  81 |     |         // one before rounding down to leave a blank 32 bytes (the length block with 0).
  82 |     |             mstore(0x40, and(
  83 |     |             add(add(end, iszero(add(length, mload(_preBytes)))), 31),
  84 |     |             not(31) // Round down to the nearest 32 bytes.
  85 |     |             ))
  86 |     |         }
  87 |     | 
  88 |     |         return tempBytes;
  89 |     |     }
  90 |     | 
  91 |     |     function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
  92 |     |         assembly {
  93 |     |         // Read the first 32 bytes of _preBytes storage, which is the length
  94 |     |         // of the array. (We don't need to use the offset into the slot
  95 |     |         // because arrays use the entire slot.)
  96 |     |             let fslot := sload(_preBytes.slot)
  97 |     |         // Arrays of 31 bytes or less have an even value in their slot,
  98 |     |         // while longer arrays have an odd value. The actual length is
  99 |     |         // the slot divided by two for odd values, and the lowest order
 100 |     |         // byte divided by two for even values.
 101 |     |         // If the slot is even, bitwise and the slot with 255 and divide by
 102 |     |         // two to get the length. If the slot is odd, bitwise and the slot
 103 |     |         // with -1 and divide by two.
 104 |     |             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
 105 |     |             let mlength := mload(_postBytes)
 106 |     |             let newlength := add(slength, mlength)
 107 |     |         // slength can contain both the length and contents of the array
 108 |     |         // if length < 32 bytes so let's prepare for that
 109 |     |         // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
 110 |     |             switch add(lt(slength, 32), lt(newlength, 32))
 111 |     |             case 2 {
 112 |     |             // Since the new array still fits in the slot, we just need to
 113 |     |             // update the contents of the slot.
 114 |     |             // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
 115 |     |                 sstore(
 116 |     |                 _preBytes.slot,
 117 |     |                 // all the modifications to the slot are inside this
 118 |     |                 // next block
 119 |     |                 add(
 120 |     |                 // we can just add to the slot contents because the
 121 |     |                 // bytes we want to change are the LSBs
 122 |     |                 fslot,
 123 |     |                 add(
 124 |     |                 mul(
 125 |     |                 div(
 126 |     |                 // load the bytes from memory
 127 |     |                 mload(add(_postBytes, 0x20)),
 128 |     |                 // zero all bytes to the right
 129 |     |                 exp(0x100, sub(32, mlength))
 130 |     |                 ),
 131 |     |                 // and now shift left the number of bytes to
 132 |     |                 // leave space for the length in the slot
 133 |     |                 exp(0x100, sub(32, newlength))
 134 |     |                 ),
 135 |     |                 // increase length by the double of the memory
 136 |     |                 // bytes length
 137 |     |                 mul(mlength, 2)
 138 |     |                 )
 139 |     |                 )
 140 |     |                 )
 141 |     |             }
 142 |     |             case 1 {
 143 |     |             // The stored value fits in the slot, but the combined value
 144 |     |             // will exceed it.
 145 |     |             // get the keccak hash to get the contents of the array
 146 |     |                 mstore(0x0, _preBytes.slot)
 147 |     |                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
 148 |     | 
 149 |     |             // save new length
 150 |     |                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
 151 |     | 
 152 |     |             // The contents of the _postBytes array start 32 bytes into
 153 |     |             // the structure. Our first read should obtain the `submod`
 154 |     |             // bytes that can fit into the unused space in the last word
 155 |     |             // of the stored array. To get this, we read 32 bytes starting
 156 |     |             // from `submod`, so the data we read overlaps with the array
 157 |     |             // contents by `submod` bytes. Masking the lowest-order
 158 |     |             // `submod` bytes allows us to add that value directly to the
 159 |     |             // stored value.
 160 |     | 
 161 |     |                 let submod := sub(32, slength)
 162 |     |                 let mc := add(_postBytes, submod)
 163 |     |                 let end := add(_postBytes, mlength)
 164 |     |                 let mask := sub(exp(0x100, submod), 1)
 165 |     | 
 166 |     |                 sstore(
 167 |     |                 sc,
 168 |     |                 add(
 169 |     |                 and(
 170 |     |                 fslot,
 171 |     |                 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00
 172 |     |                 ),
 173 |     |                 and(mload(mc), mask)
 174 |     |                 )
 175 |     |                 )
 176 |     | 
 177 |     |                 for {
 178 |     |                     mc := add(mc, 0x20)
 179 |     |                     sc := add(sc, 1)
 180 |     |                 } lt(mc, end) {
 181 |     |                     sc := add(sc, 1)
 182 |     |                     mc := add(mc, 0x20)
 183 |     |                 } {
 184 |     |                     sstore(sc, mload(mc))
 185 |     |                 }
 186 |     | 
 187 |     |                 mask := exp(0x100, sub(mc, end))
 188 |     | 
 189 |     |                 sstore(sc, mul(div(mload(mc), mask), mask))
 190 |     |             }
 191 |     |             default {
 192 |     |             // get the keccak hash to get the contents of the array
 193 |     |                 mstore(0x0, _preBytes.slot)
 194 |     |             // Start copying to the last used word of the stored array.
 195 |     |                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
 196 |     | 
 197 |     |             // save new length
 198 |     |                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
 199 |     | 
 200 |     |             // Copy over the first `submod` bytes of the new data as in
 201 |     |             // case 1 above.
 202 |     |                 let slengthmod := mod(slength, 32)
 203 |     |                 let mlengthmod := mod(mlength, 32)
 204 |     |                 let submod := sub(32, slengthmod)
 205 |     |                 let mc := add(_postBytes, submod)
 206 |     |                 let end := add(_postBytes, mlength)
 207 |     |                 let mask := sub(exp(0x100, submod), 1)
 208 |     | 
 209 |     |                 sstore(sc, add(sload(sc), and(mload(mc), mask)))
 210 |     | 
 211 |     |                 for {
 212 |     |                     sc := add(sc, 1)
 213 |     |                     mc := add(mc, 0x20)
 214 |     |                 } lt(mc, end) {
 215 |     |                     sc := add(sc, 1)
 216 |     |                     mc := add(mc, 0x20)
 217 |     |                 } {
 218 |     |                     sstore(sc, mload(mc))
 219 |     |                 }
 220 |     | 
 221 |     |                 mask := exp(0x100, sub(mc, end))
 222 |     | 
 223 |     |                 sstore(sc, mul(div(mload(mc), mask), mask))
 224 |     |             }
 225 |     |         }
 226 |     |     }
 227 |     | 
 228 |     |     function slice(
 229 |     |         bytes memory _bytes,
 230 |     |         uint256 _start,
 231 |     |         uint256 _length
 232 |     |     )
 233 |     |     internal
 234 |     |     pure
 235 |     |     returns (bytes memory)
 236 |     |     {
 237 |     |         require(_length + 31 >= _length, "slice_overflow");
 238 |     |         require(_bytes.length >= _start + _length, "slice_outOfBounds");
 239 |     | 
 240 |     |         bytes memory tempBytes;
 241 |     | 
 242 |     |         assembly {
 243 |     |             switch iszero(_length)
 244 |     |             case 0 {
 245 |     |             // Get a location of some free memory and store it in tempBytes as
 246 |     |             // Solidity does for memory variables.
 247 |     |                 tempBytes := mload(0x40)
 248 |     | 
 249 |     |             // The first word of the slice result is potentially a partial
 250 |     |             // word read from the original array. To read it, we calculate
 251 |     |             // the length of that partial word and start copying that many
 252 |     |             // bytes into the array. The first word we copy will start with
 253 |     |             // data we don't care about, but the last `lengthmod` bytes will
 254 |     |             // land at the beginning of the contents of the new array. When
 255 |     |             // we're done copying, we overwrite the full first word with
 256 |     |             // the actual length of the slice.
 257 |     |                 let lengthmod := and(_length, 31)
 258 |     | 
 259 |     |             // The multiplication in the next line is necessary
 260 |     |             // because when slicing multiples of 32 bytes (lengthmod == 0)
 261 |     |             // the following copy loop was copying the origin's length
 262 |     |             // and then ending prematurely not copying everything it should.
 263 |     |                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
 264 |     |                 let end := add(mc, _length)
 265 |     | 
 266 |     |                 for {
 267 |     |                 // The multiplication in the next line has the same exact purpose
 268 |     |                 // as the one above.
 269 |     |                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
 270 |     |                 } lt(mc, end) {
 271 |     |                     mc := add(mc, 0x20)
 272 |     |                     cc := add(cc, 0x20)
 273 |     |                 } {
 274 |     |                     mstore(mc, mload(cc))
 275 |     |                 }
 276 |     | 
 277 |     |                 mstore(tempBytes, _length)
 278 |     | 
 279 |     |             //update free-memory pointer
 280 |     |             //allocating the array padded to 32 bytes like the compiler does now
 281 |     |                 mstore(0x40, and(add(mc, 31), not(31)))
 282 |     |             }
 283 |     |             //if we want a zero-length slice let's just return a zero-length array
 284 |     |             default {
 285 |     |                 tempBytes := mload(0x40)
 286 |     |             //zero out the 32 bytes slice we are about to return
 287 |     |             //we need to do it because Solidity does not garbage collect
 288 |     |                 mstore(tempBytes, 0)
 289 |     | 
 290 |     |                 mstore(0x40, add(tempBytes, 0x20))
 291 |     |             }
 292 |     |         }
 293 |     | 
 294 |     |         return tempBytes;
 295 |     |     }
 296 |     | 
 297 |     |     function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
 298 |     |         require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
 299 |     |         address tempAddress;
 300 |     | 
 301 |     |         assembly {
 302 |     |             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
 303 |     |         }
 304 |     | 
 305 |     |         return tempAddress;
 306 |     |     }
 307 |     | 
 308 |     |     function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
 309 |     |         require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");
 310 |     |         uint8 tempUint;
 311 |     | 
 312 |     |         assembly {
 313 |     |             tempUint := mload(add(add(_bytes, 0x1), _start))
 314 |     |         }
 315 |     | 
 316 |     |         return tempUint;
 317 |     |     }
 318 |     | 
 319 |     |     function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
 320 |     |         require(_bytes.length >= _start + 2, "toUint16_outOfBounds");
 321 |     |         uint16 tempUint;
 322 |     | 
 323 |     |         assembly {
 324 |     |             tempUint := mload(add(add(_bytes, 0x2), _start))
 325 |     |         }
 326 |     | 
 327 |     |         return tempUint;
 328 |     |     }
 329 |     | 
 330 |     |     function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {
 331 |     |         require(_start + 3 >= _start, 'toUint24_overflow');
 332 |     |         require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');
 333 |     |         uint24 tempUint;
 334 |     | 
 335 |     |         assembly {
 336 |     |             tempUint := mload(add(add(_bytes, 0x3), _start))
 337 |     |         }
 338 |     | 
 339 |     |         return tempUint;
 340 |     |     }
 341 |     | 
 342 |     |     function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
 343 |     |         require(_bytes.length >= _start + 4, "toUint32_outOfBounds");
 344 |     |         uint32 tempUint;
 345 |     | 
 346 |     |         assembly {
 347 |     |             tempUint := mload(add(add(_bytes, 0x4), _start))
 348 |     |         }
 349 |     | 
 350 |     |         return tempUint;
 351 |     |     }
 352 |     | 
 353 |     |     function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
 354 |     |         require(_bytes.length >= _start + 8, "toUint64_outOfBounds");
 355 |     |         uint64 tempUint;
 356 |     | 
 357 |     |         assembly {
 358 |     |             tempUint := mload(add(add(_bytes, 0x8), _start))
 359 |     |         }
 360 |     | 
 361 |     |         return tempUint;
 362 |     |     }
 363 |     | 
 364 |     |     function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
 365 |     |         require(_bytes.length >= _start + 12, "toUint96_outOfBounds");
 366 |     |         uint96 tempUint;
 367 |     | 
 368 |     |         assembly {
 369 |     |             tempUint := mload(add(add(_bytes, 0xc), _start))
 370 |     |         }
 371 |     | 
 372 |     |         return tempUint;
 373 |     |     }
 374 |     | 
 375 |     |     function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
 376 |     |         require(_bytes.length >= _start + 16, "toUint128_outOfBounds");
 377 |     |         uint128 tempUint;
 378 |     | 
 379 |     |         assembly {
 380 |     |             tempUint := mload(add(add(_bytes, 0x10), _start))
 381 |     |         }
 382 |     | 
 383 |     |         return tempUint;
 384 |     |     }
 385 |     | 
 386 |     |     function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
 387 |     |         require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
 388 |     |         uint256 tempUint;
 389 |     | 
 390 |     |         assembly {
 391 |     |             tempUint := mload(add(add(_bytes, 0x20), _start))
 392 |     |         }
 393 |     | 
 394 |     |         return tempUint;
 395 |     |     }
 396 |     | 
 397 |     |     function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
 398 |     |         require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");
 399 |     |         bytes32 tempBytes32;
 400 |     | 
 401 |     |         assembly {
 402 |     |             tempBytes32 := mload(add(add(_bytes, 0x20), _start))
 403 |     |         }
 404 |     | 
 405 |     |         return tempBytes32;
 406 |     |     }
 407 |     | 
 408 |     |     function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
 409 |     |         bool success = true;
 410 |     | 
 411 |     |         assembly {
 412 |     |             let length := mload(_preBytes)
 413 |     | 
 414 |     |         // if lengths don't match the arrays are not equal
 415 |     |             switch eq(length, mload(_postBytes))
 416 |     |             case 1 {
 417 |     |             // cb is a circuit breaker in the for loop since there's
 418 |     |             //  no said feature for inline assembly loops
 419 |     |             // cb = 1 - don't breaker
 420 |     |             // cb = 0 - break
 421 |     |                 let cb := 1
 422 |     | 
 423 |     |                 let mc := add(_preBytes, 0x20)
 424 |     |                 let end := add(mc, length)
 425 |     | 
 426 |     |                 for {
 427 |     |                     let cc := add(_postBytes, 0x20)
 428 |     |                 // the next line is the loop condition:
 429 |     |                 // while(uint256(mc < end) + cb == 2)
 430 |     |                 } eq(add(lt(mc, end), cb), 2) {
 431 |     |                     mc := add(mc, 0x20)
 432 |     |                     cc := add(cc, 0x20)
 433 |     |                 } {
 434 |     |                 // if any of these checks fails then arrays are not equal
 435 |     |                     if iszero(eq(mload(mc), mload(cc))) {
 436 |     |                     // unsuccess:
 437 |     |                         success := 0
 438 |     |                         cb := 0
 439 |     |                     }
 440 |     |                 }
 441 |     |             }
 442 |     |             default {
 443 |     |             // unsuccess:
 444 |     |                 success := 0
 445 |     |             }
 446 |     |         }
 447 |     | 
 448 |     |         return success;
 449 |     |     }
 450 |     | 
 451 |     |     function equalStorage(
 452 |     |         bytes storage _preBytes,
 453 |     |         bytes memory _postBytes
 454 |     |     )
 455 |     |     internal
 456 |     |     view
 457 |     |     returns (bool)
 458 |     |     {
 459 |     |         bool success = true;
 460 |     | 
 461 |     |         assembly {
 462 |     |         // we know _preBytes_offset is 0
 463 |     |             let fslot := sload(_preBytes.slot)
 464 |     |         // Decode the length of the stored array like in concatStorage().
 465 |     |             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
 466 |     |             let mlength := mload(_postBytes)
 467 |     | 
 468 |     |         // if lengths don't match the arrays are not equal
 469 |     |             switch eq(slength, mlength)
 470 |     |             case 1 {
 471 |     |             // slength can contain both the length and contents of the array
 472 |     |             // if length < 32 bytes so let's prepare for that
 473 |     |             // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
 474 |     |                 if iszero(iszero(slength)) {
 475 |     |                     switch lt(slength, 32)
 476 |     |                     case 1 {
 477 |     |                     // blank the last byte which is the length
 478 |     |                         fslot := mul(div(fslot, 0x100), 0x100)
 479 |     | 
 480 |     |                         if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
 481 |     |                         // unsuccess:
 482 |     |                             success := 0
 483 |     |                         }
 484 |     |                     }
 485 |     |                     default {
 486 |     |                     // cb is a circuit breaker in the for loop since there's
 487 |     |                     //  no said feature for inline assembly loops
 488 |     |                     // cb = 1 - don't breaker
 489 |     |                     // cb = 0 - break
 490 |     |                         let cb := 1
 491 |     | 
 492 |     |                     // get the keccak hash to get the contents of the array
 493 |     |                         mstore(0x0, _preBytes.slot)
 494 |     |                         let sc := keccak256(0x0, 0x20)
 495 |     | 
 496 |     |                         let mc := add(_postBytes, 0x20)
 497 |     |                         let end := add(mc, mlength)
 498 |     | 
 499 |     |                     // the next line is the loop condition:
 500 |     |                     // while(uint256(mc < end) + cb == 2)
 501 |     |                         for {} eq(add(lt(mc, end), cb), 2) {
 502 |     |                             sc := add(sc, 1)
 503 |     |                             mc := add(mc, 0x20)
 504 |     |                         } {
 505 |     |                             if iszero(eq(sload(sc), mload(mc))) {
 506 |     |                             // unsuccess:
 507 |     |                                 success := 0
 508 |     |                                 cb := 0
 509 |     |                             }
 510 |     |                         }
 511 |     |                     }
 512 |     |                 }
 513 |     |             }
 514 |     |             default {
 515 |     |             // unsuccess:
 516 |     |                 success := 0
 517 |     |             }
 518 |     |         }
 519 |     | 
 520 |     |         return success;
 521 |     |     }
 522 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @title Contains 512-bit math functions
   5 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   6 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   7 |     | library FullMath {
   8 |     |     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
   9 |     |     /// @param a The multiplicand
  10 |     |     /// @param b The multiplier
  11 |     |     /// @param denominator The divisor
  12 |     |     /// @return result The 256-bit result
  13 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  14 | *   |     function mulDiv(
  15 |     |         uint256 a,
  16 |     |         uint256 b,
  17 |     |         uint256 denominator
  18 |     |     ) internal pure returns (uint256 result) {
  19 |     |         unchecked {
  20 |     |             // 512-bit multiply [prod1 prod0] = a * b
  21 |     |             // Compute the product mod 2**256 and mod 2**256 - 1
  22 |     |             // then use the Chinese Remainder Theorem to reconstruct
  23 |     |             // the 512 bit result. The result is stored in two 256
  24 |     |             // variables such that product = prod1 * 2**256 + prod0
  25 |     |             uint256 prod0; // Least significant 256 bits of the product
  26 |     |             uint256 prod1; // Most significant 256 bits of the product
  27 |     |             assembly {
  28 |     |                 let mm := mulmod(a, b, not(0))
  29 |     |                 prod0 := mul(a, b)
  30 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  31 |     |             }
  32 |     | 
  33 |     |             // Handle non-overflow cases, 256 by 256 division
  34 |     |             if (prod1 == 0) {
  35 |     |                 require(denominator > 0);
  36 |     |                 assembly {
  37 |     |                     result := div(prod0, denominator)
  38 |     |                 }
  39 |     |                 return result;
  40 |     |             }
  41 |     | 
  42 |     |             // Make sure the result is less than 2**256.
  43 |     |             // Also prevents denominator == 0
  44 |     |             require(denominator > prod1);
  45 |     | 
  46 |     |             ///////////////////////////////////////////////
  47 |     |             // 512 by 256 division.
  48 |     |             ///////////////////////////////////////////////
  49 |     | 
  50 |     |             // Make division exact by subtracting the remainder from [prod1 prod0]
  51 |     |             // Compute remainder using mulmod
  52 |     |             uint256 remainder;
  53 |     |             assembly {
  54 |     |                 remainder := mulmod(a, b, denominator)
  55 |     |             }
  56 |     |             // Subtract 256 bit number from 512 bit number
  57 |     |             assembly {
  58 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  59 |     |                 prod0 := sub(prod0, remainder)
  60 |     |             }
  61 |     | 
  62 |     |             // Factor powers of two out of denominator
  63 |     |             // Compute largest power of two divisor of denominator.
  64 |     |             // Always >= 1.
  65 |     |             // EDIT for 0.8 compatibility:
  66 |     |             // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256
  67 |     |             uint256 twos = denominator & (~denominator + 1);
  68 |     | 
  69 |     |             // Divide denominator by power of two
  70 |     |             assembly {
  71 |     |                 denominator := div(denominator, twos)
  72 |     |             }
  73 |     | 
  74 |     |             // Divide [prod1 prod0] by the factors of two
  75 |     |             assembly {
  76 |     |                 prod0 := div(prod0, twos)
  77 |     |             }
  78 |     |             // Shift in bits from prod1 into prod0. For this we need
  79 |     |             // to flip `twos` such that it is 2**256 / twos.
  80 |     |             // If twos is zero, then it becomes one
  81 |     |             assembly {
  82 |     |                 twos := add(div(sub(0, twos), twos), 1)
  83 |     |             }
  84 |     |             prod0 |= prod1 * twos;
  85 |     | 
  86 |     |             // Invert denominator mod 2**256
  87 |     |             // Now that denominator is an odd number, it has an inverse
  88 |     |             // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  89 |     |             // Compute the inverse by starting with a seed that is correct
  90 |     |             // correct for four bits. That is, denominator * inv = 1 mod 2**4
  91 |     |             uint256 inv = (3 * denominator) ^ 2;
  92 |     |             // Now use Newton-Raphson iteration to improve the precision.
  93 |     |             // Thanks to Hensel's lifting lemma, this also works in modular
  94 |     |             // arithmetic, doubling the correct bits in each step.
  95 |     |             inv *= 2 - denominator * inv; // inverse mod 2**8
  96 |     |             inv *= 2 - denominator * inv; // inverse mod 2**16
  97 |     |             inv *= 2 - denominator * inv; // inverse mod 2**32
  98 |     |             inv *= 2 - denominator * inv; // inverse mod 2**64
  99 |     |             inv *= 2 - denominator * inv; // inverse mod 2**128
 100 |     |             inv *= 2 - denominator * inv; // inverse mod 2**256
 101 |     | 
 102 |     |             // Because the division is now exact we can divide by multiplying
 103 |     |             // with the modular inverse of denominator. This will give us the
 104 |     |             // correct result modulo 2**256. Since the precoditions guarantee
 105 |     |             // that the outcome is less than 2**256, this is the final result.
 106 |     |             // We don't need to compute the high bits of the result and prod1
 107 |     |             // is no longer required.
 108 |     |             result = prod0 * inv;
 109 |     |             return result;
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 114 |     |     /// @param a The multiplicand
 115 |     |     /// @param b The multiplier
 116 |     |     /// @param denominator The divisor
 117 |     |     /// @return result The 256-bit result
 118 |     |     function mulDivRoundingUp(
 119 |     |         uint256 a,
 120 |     |         uint256 b,
 121 |     |         uint256 denominator
 122 |     |     ) internal pure returns (uint256 result) {
 123 |     |         result = mulDiv(a, b, denominator);
 124 |     |         if (mulmod(a, b, denominator) > 0) {
 125 |     |             require(result < type(uint256).max);
 126 |     |             result++;
 127 |     |         }
 128 |     |     }
 129 |     | }
 130 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/LiquidityAmounts.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | import "./FullMath.sol";
   4 |     | 
   5 |     | /// @title FixedPoint96
   6 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
   7 |     | /// @dev Used in SqrtPriceMath.sol
   8 |     | //audit-info This library defines constants for handling binary fixed point numbers with a resolution of 96 bits.
   9 |     | library FixedPoint96 {
  10 |     |     uint8 internal constant RESOLUTION = 96;
  11 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  12 |     | }
  13 |     | 
  14 |     | /// @title Liquidity amount functions
  15 |     | /// @notice Provides functions for computing liquidity amounts from token amounts and prices
  16 |     | //audit-info This library provides functions to compute liquidity amounts from token amounts and prices, and vice versa.
  17 |     | library LiquidityAmounts {
  18 |     |     function toUint128(uint256 x) private pure returns (uint128 y) {
  19 |     |         require((y = uint128(x)) == x);
  20 |     |     }
  21 |     | 
  22 |     |     /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
  23 |     |     /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).
  24 |     |     /// @param sqrtRatioAX96 A sqrt price
  25 |     |     /// @param sqrtRatioBX96 Another sqrt price
  26 |     |     /// @param amount0 The amount0 being sent in
  27 |     |     /// @return liquidity The amount of returned liquidity
  28 |     |     function getLiquidityForAmount0(
  29 |     |         uint160 sqrtRatioAX96,
  30 |     |         uint160 sqrtRatioBX96,
  31 |     |         uint256 amount0
  32 |     |     ) internal pure returns (uint128 liquidity) {
  33 |     |         if (sqrtRatioAX96 > sqrtRatioBX96)
  34 |     |             (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  35 |     |         uint256 intermediate =
  36 |     |             FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96); //audit Can't oveflow revert ? 
  37 |     |         return
  38 |     |             toUint128(
  39 |     |                 FullMath.mulDiv(
  40 |     |                     amount0,
  41 |     |                     intermediate,
  42 |     |                     sqrtRatioBX96 - sqrtRatioAX96
  43 |     |                 )
  44 |     |             );
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
  48 |     |     /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
  49 |     |     /// @param sqrtRatioAX96 A sqrt price
  50 |     |     /// @param sqrtRatioBX96 Another sqrt price
  51 |     |     /// @param amount1 The amount1 being sent in
  52 |     |     /// @return liquidity The amount of returned liquidity
  53 |     |     function getLiquidityForAmount1(
  54 |     |         uint160 sqrtRatioAX96,
  55 |     |         uint160 sqrtRatioBX96,
  56 |     |         uint256 amount1
  57 |     |     ) internal pure returns (uint128 liquidity) {
  58 |     |         if (sqrtRatioAX96 > sqrtRatioBX96)
  59 |     |             (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  60 |     |         return
  61 |     |             toUint128(
  62 |     |                 FullMath.mulDiv(
  63 |     |                     amount1,
  64 |     |                     FixedPoint96.Q96,
  65 |     |                     sqrtRatioBX96 - sqrtRatioAX96
  66 |     |                 )
  67 |     |             );
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
  71 |     |     /// pool prices and the prices at the tick boundaries
  72 |     |     function getLiquidityForAmounts(
  73 |     |         uint160 sqrtRatioX96,
  74 |     |         uint160 sqrtRatioAX96,
  75 |     |         uint160 sqrtRatioBX96,
  76 |     |         uint256 amount0,
  77 |     |         uint256 amount1
  78 |     |     ) internal pure returns (uint128 liquidity) {
  79 |     |         if (sqrtRatioAX96 > sqrtRatioBX96)
  80 |     |             (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  81 |     | 
  82 |     |         if (sqrtRatioX96 <= sqrtRatioAX96) {
  83 |     |             liquidity = getLiquidityForAmount0(
  84 |     |                 sqrtRatioAX96,
  85 |     |                 sqrtRatioBX96,
  86 |     |                 amount0
  87 |     |             );
  88 |     |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
  89 |     |             uint128 liquidity0 =
  90 |     |                 getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
  91 |     |             uint128 liquidity1 =
  92 |     |                 getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
  93 |     | 
  94 |     |             liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
  95 |     |         } else {
  96 |     |             liquidity = getLiquidityForAmount1(
  97 |     |                 sqrtRatioAX96,
  98 |     |                 sqrtRatioBX96,
  99 |     |                 amount1
 100 |     |             );
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
 105 |     |     /// @param sqrtRatioAX96 A sqrt price
 106 |     |     /// @param sqrtRatioBX96 Another sqrt price
 107 |     |     /// @param liquidity The liquidity being valued
 108 |     |     /// @return amount0 The amount0
 109 |     |     function getAmount0ForLiquidity(
 110 |     |         uint160 sqrtRatioAX96,
 111 |     |         uint160 sqrtRatioBX96,
 112 |     |         uint128 liquidity
 113 |     |     ) internal pure returns (uint256 amount0) {
 114 |     |         if (sqrtRatioAX96 > sqrtRatioBX96)
 115 |     |             (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 116 |     | 
 117 |     |         return
 118 |     |             FullMath.mulDiv(
 119 |     |                 uint256(liquidity) << FixedPoint96.RESOLUTION,
 120 |     |                 sqrtRatioBX96 - sqrtRatioAX96,
 121 |     |                 sqrtRatioBX96
 122 |     |             ) / sqrtRatioAX96;
 123 |     |     }
 124 |     | 
 125 |     |     /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
 126 |     |     /// @param sqrtRatioAX96 A sqrt price
 127 |     |     /// @param sqrtRatioBX96 Another sqrt price
 128 |     |     /// @param liquidity The liquidity being valued
 129 |     |     /// @return amount1 The amount1
 130 |     |     function getAmount1ForLiquidity(
 131 |     |         uint160 sqrtRatioAX96,
 132 |     |         uint160 sqrtRatioBX96,
 133 |     |         uint128 liquidity
 134 |     |     ) internal pure returns (uint256 amount1) {
 135 |     |         if (sqrtRatioAX96 > sqrtRatioBX96)
 136 |     |             (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 137 |     | 
 138 |     |         return
 139 |     |             FullMath.mulDiv(
 140 |     |                 liquidity,
 141 |     |                 sqrtRatioBX96 - sqrtRatioAX96,
 142 |     |                 FixedPoint96.Q96
 143 |     |             );
 144 |     |     }
 145 |     | 
 146 |     |     /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
 147 |     |     /// pool prices and the prices at the tick boundaries
 148 |     |     function getAmountsForLiquidity(
 149 |     |         uint160 sqrtRatioX96,
 150 |     |         uint160 sqrtRatioAX96,
 151 |     |         uint160 sqrtRatioBX96,
 152 |     |         uint128 liquidity
 153 |     |     ) internal pure returns (uint256 amount0, uint256 amount1) {
 154 |     |         if (sqrtRatioAX96 > sqrtRatioBX96)
 155 |     |             (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 156 |     | 
 157 |     |         if (sqrtRatioX96 <= sqrtRatioAX96) {
 158 |     |             amount0 = getAmount0ForLiquidity(
 159 |     |                 sqrtRatioAX96,
 160 |     |                 sqrtRatioBX96,
 161 |     |                 liquidity
 162 |     |             );
 163 |     |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
 164 |     |             amount0 = getAmount0ForLiquidity(
 165 |     |                 sqrtRatioX96,
 166 |     |                 sqrtRatioBX96,
 167 |     |                 liquidity
 168 |     |             );
 169 |     |             amount1 = getAmount1ForLiquidity(
 170 |     |                 sqrtRatioAX96,
 171 |     |                 sqrtRatioX96,
 172 |     |                 liquidity
 173 |     |             );
 174 |     |         } else {
 175 |     |             amount1 = getAmount1ForLiquidity(
 176 |     |                 sqrtRatioAX96,
 177 |     |                 sqrtRatioBX96,
 178 |     |                 liquidity
 179 |     |             );
 180 |     |         }
 181 |     |     }
 182 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/Path.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | //audit-info What is that Library? 
  5 |     | import './BytesLib.sol';
  6 |     | 
  7 |     | /// @title Functions for manipulating path data for multihop swaps
  8 |     | library Path {
  9 |     |     using BytesLib for bytes;
 10 |     | 
 11 |     |     /// @dev The length of the bytes encoded address
 12 |     |     uint256 private constant ADDR_SIZE = 20;
 13 |     |     /// @dev The length of the bytes encoded fee
 14 |     |     uint256 private constant FEE_SIZE = 3;
 15 |     | 
 16 |     |     /// @dev The offset of a single token address and pool fee
 17 |     |     uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE; //== 23
 18 |     |     /// @dev The offset of an encoded pool key
 19 |     |     //audit-info Why do they again add the address's size 
 20 |     |     uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE; //== 43
 21 |     |     /// @dev The minimum length of an encoding that contains 2 or more pools
 22 |     |     uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET; //== 66
 23 |     | 
 24 |     |     /// @notice Returns true iff the path contains two or more pools
 25 |     |     /// @param path The encoded swap path
 26 |     |     /// @return True if path contains two or more pools, otherwise false
 27 |     |     function hasMultiplePools(bytes memory path) internal pure returns (bool) {
 28 |     |         return path.length >= MULTIPLE_POOLS_MIN_LENGTH;
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns the number of pools in the path
 32 |     |     /// @param path The encoded swap path
 33 |     |     /// @return The number of pools in the path
 34 |     |     function numPools(bytes memory path) internal pure returns (uint256) {
 35 |     |         // Ignore the first token address. From then on every fee and token offset indicates a pool.
 36 |     |         return ((path.length - ADDR_SIZE) / NEXT_OFFSET);
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Decodes the first pool in path
 40 |     |     /// @param path The bytes encoded swap path
 41 |     |     /// @return tokenA The first token of the given pool
 42 |     |     /// @return tokenB The second token of the given pool
 43 |     |     /// @return fee The fee level of the pool
 44 |     |     function decodeFirstPool(bytes memory path)
 45 |     |     internal
 46 |     |     pure
 47 |     |     returns (
 48 |     |         address tokenA,
 49 |     |         address tokenB,
 50 |     |         uint24 fee
 51 |     |     )
 52 |     |     {
 53 |     |         tokenA = path.toAddress(0);
 54 |     |         fee = path.toUint24(ADDR_SIZE);
 55 |     |         tokenB = path.toAddress(NEXT_OFFSET);
 56 |     |     }
 57 |     | 
 58 |     |     /// @notice Gets the segment corresponding to the first pool in the path
 59 |     |     /// @param path The bytes encoded swap path
 60 |     |     /// @return The segment containing all data necessary to target the first pool in the path
 61 |     |     function getFirstPool(bytes memory path) internal pure returns (bytes memory) {
 62 |     |         return path.slice(0, POP_OFFSET);
 63 |     |     }
 64 |     | 
 65 |     |     /// @notice Skips a token + fee element from the buffer and returns the remainder
 66 |     |     /// @param path The swap path
 67 |     |     /// @return The remaining token + fee elements in the path
 68 |     |     function skipToken(bytes memory path) internal pure returns (bytes memory) {
 69 |     |         return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);
 70 |     |     }
 71 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/TickMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | // @title Math library for computing sqrt prices from ticks and vice versa
  5 |     | // @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
  6 |     | // prices between 2**-128 and 2**128
  7 |     | library TickMath {
  8 |     |   // @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
  9 |     |   int24 internal constant MIN_TICK = -887272;
 10 |     |   // @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
 11 |     |   int24 internal constant MAX_TICK = -MIN_TICK;
 12 |     | 
 13 |     |   // @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
 14 |     |   uint160 internal constant MIN_SQRT_RATIO = 4295128739;
 15 |     |   // @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
 16 |     |   uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
 17 |     | 
 18 |     |   // @notice Calculates sqrt(1.0001^tick) * 2^96
 19 |     |   // @dev Throws if |tick| > max tick
 20 |     |   // @param tick The input tick for the above formula
 21 |     |   // @return sqrtP A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
 22 |     |   // at the given tick
 23 |     |   function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtP) {
 24 |     |     unchecked {
 25 |     |       uint256 absTick = uint256(tick < 0 ? -int256(tick) : int256(tick));
 26 |     |       require(absTick <= uint256(int256(MAX_TICK)), 'T');
 27 |     | 
 28 |     |       // do bitwise comparison, if i-th bit is turned on,
 29 |     |       // multiply ratio by hardcoded values of sqrt(1.0001^-(2^i)) * 2^128
 30 |     |       // where 0 <= i <= 19
 31 |     |       uint256 ratio = (absTick & 0x1 != 0)
 32 |     |         ? 0xfffcb933bd6fad37aa2d162d1a594001
 33 |     |         : 0x100000000000000000000000000000000;
 34 |     |       if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
 35 |     |       if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
 36 |     |       if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
 37 |     |       if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
 38 |     |       if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
 39 |     |       if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
 40 |     |       if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
 41 |     |       if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
 42 |     |       if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
 43 |     |       if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
 44 |     |       if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
 45 |     |       if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
 46 |     |       if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
 47 |     |       if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
 48 |     |       if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
 49 |     |       if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
 50 |     |       if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
 51 |     |       if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
 52 |     |       if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
 53 |     | 
 54 |     |       // take reciprocal for positive tick values
 55 |     |       if (tick > 0) ratio = type(uint256).max / ratio;
 56 |     | 
 57 |     |       // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
 58 |     |       // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
 59 |     |       // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
 60 |     |       sqrtP = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
 61 |     |     }
 62 |     |   }
 63 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/TickUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./Path.sol";
   5 |     | import "./TickMath.sol";
   6 |     | import "./LiquidityAmounts.sol";
   7 |     | 
   8 |     | library TickUtils {
   9 |     |     using Path for bytes;
  10 |     |     using TickMath for int24;
  11 |     |     
  12 |     |     //audit Not sure on what the function is suppose to do. Missing Naspec
  13 |     |     function floor(int24 tick, int24 tickSpacing) internal pure returns (int24) {
  14 |     |         int24 compressed = tick / tickSpacing;
  15 |     |         if (tick < 0 && tick % tickSpacing != 0) compressed--;
  16 |     |         return compressed * tickSpacing;
  17 |     |     }
  18 |     | 
  19 |     |     /// @dev Calc base ticks depending on base threshold and tickspacing
  20 |     |     function baseTicks(
  21 |     |         int24 currentTick,
  22 |     |         int24 baseThreshold,
  23 |     |         int24 tickSpacing
  24 |     |     ) internal pure returns (int24 tickLower, int24 tickUpper) {
  25 |     |         int24 tickFloor = floor(currentTick, tickSpacing);
  26 |     | 
  27 |     |         tickLower = tickFloor - baseThreshold;
  28 |     |         tickUpper = tickFloor + baseThreshold;
  29 |     |     }
  30 |     | 
  31 |     |     function quoteAddLiquidity(int24 _currentTick, int24 _lowerTick, int24 _upperTick, uint256 _amt0, uint256 _amt1) internal pure returns(uint256 _actualAmount0, uint256 _actualAmount1, uint256 _liquidity) {
  32 |     |         // Grab the amount of liquidity for our token balances
  33 |     |         _liquidity = LiquidityAmounts.getLiquidityForAmounts(
  34 |     |                 _currentTick.getSqrtRatioAtTick(),
  35 |     |                 _lowerTick.getSqrtRatioAtTick(),
  36 |     |                 _upperTick.getSqrtRatioAtTick(),
  37 |     |                 _amt0,
  38 |     |                 _amt1
  39 |     |         );
  40 |     |         
  41 |     |         ( _actualAmount0,  _actualAmount1) = LiquidityAmounts.getAmountsForLiquidity(
  42 |     |                 _currentTick.getSqrtRatioAtTick(),
  43 |     |                 _lowerTick.getSqrtRatioAtTick(),
  44 |     |                 _upperTick.getSqrtRatioAtTick(),
  45 |     |                 uint128(_liquidity)
  46 |     |         );
  47 |     |     }
  48 |     | 
  49 |     | 
  50 |     |     //audit-info Get deeper in this function
  51 |     |     function getQuoteAtTick(
  52 |     |         int24 tick,
  53 |     |         uint128 baseAmount,
  54 |     |         address baseToken,
  55 |     |         address quoteToken
  56 |     |     ) internal pure returns (uint256 quoteAmount) {
  57 |     |         uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
  58 |     | 
  59 |     |         // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
  60 |     |         if (sqrtRatioX96 <= type(uint128).max) {
  61 |     |             uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
  62 |     |             quoteAmount = baseToken < quoteToken
  63 |     |                 ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
  64 |     |                 : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
  65 |     |         } else {
  66 |     |             uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
  67 |     |             quoteAmount = baseToken < quoteToken
  68 |     |                 ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
  69 |     |                 : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
  70 |     |         }
  71 |     |     }
  72 |     | 
  73 |     |     // Convert encoded path to token route
  74 |     |     function pathToRoute(bytes memory _path) internal pure returns (address[] memory, uint24[] memory) {
  75 |     |         uint256 numPools = _path.numPools();
  76 |     |         address[] memory route = new address[](numPools + 1);
  77 |     |         uint24[] memory fees = new uint24[](numPools);
  78 |     |         for (uint256 i; i < numPools; i++) {
  79 |     |             (address tokenA, address tokenB, uint24 fee) = _path.decodeFirstPool();
  80 |     |             route[i] = tokenA;
  81 |     |             route[i + 1] = tokenB;
  82 |     |             fees[i] = fee;
  83 |     |             _path = _path.skipToken();
  84 |     |         }
  85 |     |         return (route, fees);
  86 |     |     }
  87 |     | 
  88 |     |     // Convert token route to encoded path
  89 |     |     // uint24 type for fees so path is packed tightly
  90 |     |     function routeToPath(
  91 |     |         address[] memory _route,
  92 |     |         uint24[] memory _fee
  93 |     |     ) internal pure returns (bytes memory path) {
  94 |     |         path = abi.encodePacked(_route[0]);
  95 |     |         uint256 feeLength = _fee.length;
  96 |     |         for (uint256 i = 0; i < feeLength; i++) {
  97 |     |             path = abi.encodePacked(path, _fee[i], _route[i+1]);
  98 |     |         }
  99 |     |     }
 100 |     | 
 101 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/UniV3Utils.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import './Path.sol';
  6 |     | import "../interfaces/uniswap/IUniswapRouterV3.sol";
  7 |     | 
  8 |     | library UniV3Utils {
  9 |     |     using Path for bytes;
 10 |     | 
 11 |     |     // Swap along an encoded path using known amountIn
 12 |     | 
 13 |     |     function swap(
 14 |     |         address _user,
 15 |     |         address _router,
 16 |     |         bytes memory _path,
 17 |     |         uint256 _amountIn
 18 |     |     ) internal returns (uint256 amountOut) {
 19 |     |         IUniswapRouterV3.ExactInputParams memory params = IUniswapRouterV3.ExactInputParams({
 20 |     |             path: _path,
 21 |     |             recipient: _user,
 22 |     |             amountIn: _amountIn,
 23 |     |             amountOutMinimum: 0
 24 |     |         });
 25 |     |         return IUniswapRouterV3(_router).exactInput(params);
 26 |     |     }
 27 |     | 
 28 |     |     function swap(
 29 |     |         address _router,
 30 |     |         bytes memory _path,
 31 |     |         uint256 _amountIn
 32 |     |     ) internal returns (uint256 amountOut) {
 33 |     |         IUniswapRouterV3.ExactInputParams memory params = IUniswapRouterV3.ExactInputParams({
 34 |     |             path: _path,
 35 |     |             recipient: address(this),
 36 |     |             amountIn: _amountIn,
 37 |     |             amountOutMinimum: 0
 38 |     |         });
 39 |     |         return IUniswapRouterV3(_router).exactInput(params);
 40 |     |     }
 41 |     | 
 42 |     |     // Swap along a token route using known fees and amountIn
 43 |     |     function swap(
 44 |     |         address _router,
 45 |     |         address[] memory _route,
 46 |     |         uint24[] memory _fee,
 47 |     |         uint256 _amountIn
 48 |     |     ) internal returns (uint256 amountOut) {
 49 |     |         return swap(_router, routeToPath(_route, _fee), _amountIn);
 50 |     |     }
 51 |     | 
 52 |     |     // Convert encoded path to token route
 53 |     |     function pathToRoute(bytes memory _path) internal pure returns (address[] memory) {
 54 |     |         uint256 numPools = _path.numPools();
 55 |     |         address[] memory route = new address[](numPools + 1);
 56 |     |         for (uint256 i; i < numPools; i++) {
 57 |     |             (address tokenA, address tokenB,) = _path.decodeFirstPool();
 58 |     |             route[i] = tokenA;
 59 |     |             route[i + 1] = tokenB;
 60 |     |             _path = _path.skipToken();
 61 |     |         }
 62 |     |         return route;
 63 |     |     }
 64 |     | 
 65 |     |     // Convert token route to encoded path
 66 |     |     // uint24 type for fees so path is packed tightly
 67 |     |     function routeToPath(
 68 |     |         address[] memory _route,
 69 |     |         uint24[] memory _fee
 70 |     |     ) internal pure returns (bytes memory path) {
 71 |     |         path = abi.encodePacked(_route[0]);
 72 |     |         uint256 feeLength = _fee.length;
 73 |     |         for (uint256 i = 0; i < feeLength; i++) {
 74 |     |             path = abi.encodePacked(path, _fee[i], _route[i+1]);
 75 |     |         }
 76 |     |     }
 77 |     | }
 78 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/VeloSwapUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import './Path.sol';
   6 |     | import "../interfaces/velodrome/IVeloRouter.sol";
   7 |     | 
   8 |     | library VeloSwapUtils {
   9 |     |     struct Route {
  10 |     |         address from;
  11 |     |         address to;
  12 |     |         bool stable;
  13 |     |         address factory;
  14 |     |     }
  15 |     | 
  16 |     |     using Path for bytes;
  17 |     | 
  18 |     |     bytes1 constant V3_SWAP_EXACT_IN = 0x00;
  19 |     |     bytes1 constant V2_SWAP_EXACT_IN = 0x08;
  20 |     | 
  21 |     |     // Swap along an encoded path using known amountIn
  22 |     |     //audit-info Check on Velodrome Finance for Swap Execution.
  23 |     |     //audit-info Also check on Solodit for related issue in Velodrome Integration.
  24 |     |     function swap(
  25 |     |         address _router,
  26 |     |         bytes memory _path,
  27 |     |         uint256 _amountIn,
  28 |     |         bool _isV3
  29 |     |     ) internal {
  30 |     |         if (_isV3) {
  31 |     |             bytes memory input = abi.encode(address(this), _amountIn, 0, _path, true);
  32 |     |             bytes[] memory inputs = new bytes[](1);
  33 |     |             inputs[0] = input;
  34 |     |             IVeloRouter(_router).execute(abi.encodePacked(V3_SWAP_EXACT_IN), inputs, block.timestamp);
  35 |     |         } else {
  36 |     |             address[] memory route = pathToRoute(_path);
  37 |     |             bytes memory input = abi.encode(address(this), _amountIn, 0, route, true);
  38 |     |             bytes[] memory inputs = new bytes[](1);
  39 |     |             inputs[0] = input;
  40 |     | 
  41 |     |             IVeloRouter(_router).execute(abi.encodePacked(V2_SWAP_EXACT_IN), inputs, block.timestamp);
  42 |     |         }
  43 |     |     }
  44 |     | 
  45 |     |     // Swap along an encoded path using known amountIn
  46 |     |     //audit-info Only for V2 then ? 
  47 |     |     function swap(
  48 |     |         address _router,
  49 |     |         IVeloRouter.Route[] memory _route,
  50 |     |         uint256 _amountIn
  51 |     |     ) internal {
  52 |     |         bytes memory input = abi.encode(address(this), _amountIn, 0, _route, true);
  53 |     |         bytes[] memory inputs = new bytes[](1);
  54 |     |         inputs[0] = input;
  55 |     | 
  56 |     |         IVeloRouter(_router).execute(abi.encodePacked(V2_SWAP_EXACT_IN), inputs, block.timestamp);
  57 |     |     }
  58 |     | 
  59 |     |     // Swap along an encoded path using known amountIn
  60 |     |     //audit-info Swap on behalf of someone else ? 
  61 |     |     function swap(
  62 |     |         address _who,
  63 |     |         address _router,
  64 |     |         bytes memory _path,
  65 |     |         uint256 _amountIn,
  66 |     |         bool _isV3
  67 |     |     ) internal {
  68 |     |         if (_isV3) {
  69 |     |             bytes memory input = abi.encode(_who, _amountIn, 0, _path, true);
  70 |     |             bytes[] memory inputs = new bytes[](1);
  71 |     |             inputs[0] = input;
  72 |     |             IVeloRouter(_router).execute(abi.encodePacked(V3_SWAP_EXACT_IN), inputs, block.timestamp);
  73 |     |         } else {
  74 |     |             address[] memory route = pathToRoute(_path);
  75 |     |             bytes memory input = abi.encode(_who, _amountIn, 0, route, true);
  76 |     |             bytes[] memory inputs = new bytes[](1);
  77 |     |             inputs[0] = input;
  78 |     | 
  79 |     |             IVeloRouter(_router).execute(abi.encodePacked(V2_SWAP_EXACT_IN), inputs, block.timestamp);
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 |     |     // Convert encoded path to token route
  84 |     |     function pathToRoute(bytes memory _path) internal pure returns (address[] memory) {
  85 |     |         uint256 numPools = _path.numPools();
  86 |     |         address[] memory route = new address[](numPools + 1);
  87 |     |         for (uint256 i; i < numPools; i++) {
  88 |     |             (address tokenA, address tokenB,) = _path.decodeFirstPool();
  89 |     |             route[i] = tokenA;
  90 |     |             route[i + 1] = tokenB;
  91 |     |             _path = _path.skipToken();
  92 |     |         }
  93 |     |         return route;
  94 |     |     }
  95 |     | 
  96 |     |     // Convert token route to encoded path
  97 |     |     // uint24 type for fees so path is packed tightly
  98 |     |     function routeToPath(
  99 |     |         address[] memory _route,
 100 |     |         uint24[] memory _fee
 101 |     |     ) internal pure returns (bytes memory path) {
 102 |     |         path = abi.encodePacked(_route[0]);
 103 |     |         uint256 feeLength = _fee.length;
 104 |     |         for (uint256 i = 0; i < feeLength; i++) {
 105 |     |             path = abi.encodePacked(path, _fee[i], _route[i+1]);
 106 |     |         }
 107 |     |     }
 108 |     | }
 109 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/vault/BeefyVaultConcLiq.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.23;
   3 |     | 
   4 |     | import {IERC20Metadata} from "@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol";
   5 |     | import {ERC20Upgradeable, IERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
   6 |     | import {SafeERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
   7 |     | import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
   8 |     | import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
   9 |     | import {IStrategyConcLiq} from "../interfaces/beefy/IStrategyConcLiq.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of a vault to deposit funds for yield optimizing.
  13 |     |  * This is the contract that receives funds and that users interface with.
  14 |     |  * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.
  15 |     |  */
  16 |     | contract BeefyVaultConcLiq is ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
  17 |     |     using SafeERC20Upgradeable for IERC20Upgradeable;
  18 |     |     
  19 |     |     /// @notice The strategy currently in use by the vault.
  20 |     |     IStrategyConcLiq public strategy;
  21 |     |    
  22 |     |     /// @notice The initial shares that are burned as part of the first vault deposit. 
  23 |     |     uint256 private constant MINIMUM_SHARES = 10**3;
  24 |     | 
  25 |     |     /// @notice The precision used to calculate the shares.
  26 |     |     uint256 private constant PRECISION = 1e36;
  27 |     | 
  28 |     |     /// @notice The address we are sending the burned shares to.
  29 |     |     address private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;
  30 |     | 
  31 |     |     // Errors
  32 |     |     error NoShares();
  33 |     |     error TooMuchSlippage();
  34 |     |     error NotEnoughTokens();
  35 |     | 
  36 |     |     // Events 
  37 |     |     event Deposit(address indexed user, uint256 shares, uint256 amount0, uint256 amount1);
  38 |     |     event Withdraw(address indexed user, uint256 shares, uint256 amount0, uint256 amount1);
  39 |     | 
  40 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  41 |     |     constructor() {
  42 |     |         _disableInitializers();
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Initializes the vault, sets the strategy name and creates a new token.
  47 |     |      * @param _strategy the address of the strategy.
  48 |     |      * @param _name the name of the vault token.
  49 |     |      * @param _symbol the symbol of the vault token.
  50 |     |      */
  51 |     |      function initialize(
  52 |     |         address _strategy,
  53 |     |         string calldata _name,
  54 |     |         string calldata _symbol
  55 |     |     ) external initializer {
  56 |     |         __ERC20_init(_name, _symbol);
  57 |     |         __Ownable_init();
  58 |     |         __ReentrancyGuard_init();
  59 |     |         strategy = IStrategyConcLiq(_strategy);
  60 |     |     }
  61 |     | 
  62 |     |     /** 
  63 |     |      * @notice returns whether the pool is calm for deposits
  64 |     |      * @return boolean true if the pool is calm 
  65 |     |     */
  66 |     |     function isCalm() external view returns (bool) {
  67 |     |         return strategy.isCalm();
  68 |     |     }
  69 |     | 
  70 |     |     /** 
  71 |     |      * @notice returns the concentrated liquidity pool address
  72 |     |      * @return _want the address of the concentrated liquidity pool
  73 |     |     */
  74 |     |     function want() external view returns (address _want) {
  75 |     |         return strategy.pool();
  76 |     |     }
  77 |     | 
  78 |     |     /** @notice returns the tokens that the strategy wants
  79 |     |      * @return token0 the address of the first token
  80 |     |      * @return token1 the address of the second token
  81 |     |     */
  82 |     |     function wants() public view returns (address token0, address token1) {
  83 |     |         token0 = strategy.lpToken0();
  84 |     |         token1 = strategy.lpToken1();
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @notice It calculates the total underlying value of {tokens} held by the system.
  89 |     |      * It takes into account the vault contract balance, the strategy contract balance
  90 |     |      *  and the balance deployed in other contracts as part of the strategy.
  91 |     |      * @return amount0 the amount of token0
  92 |     |      * @return amount1 the amount of token1
  93 |     |      */
  94 |     |     function balances() public view returns (uint amount0, uint amount1) {
  95 |     |         (amount0, amount1) = IStrategyConcLiq(strategy).balances();
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @notice Returns the amount of token0 and token1 that a number of shares represents.
 100 |     |      * @param _shares the number of shares to convert to tokens.
 101 |     |      * @return amount0 the amount of token0 a user will recieve for the shares.
 102 |     |      * @return amount1 the amount of token1 a user will recieve for the shares.
 103 |     |      */
 104 |     |     function previewWithdraw(uint256 _shares) external view returns (uint256 amount0, uint256 amount1) {
 105 |     |         (uint bal0, uint bal1) = balances();
 106 |     | 
 107 |     |         uint256 _totalSupply = totalSupply();
 108 |     |         amount0 = (bal0 * _shares) / _totalSupply;
 109 |     |         amount1 = (bal1 * _shares) / _totalSupply;
 110 |     |     }
 111 |     | 
 112 |     |       /**
 113 |     |      * @notice Get a expected shares amount for token deposits. 
 114 |     |      * @param _amount0 the amount of token0 to deposit.
 115 |     |      * @param _amount1 the amount of token1 to deposit.
 116 |     |      * @return shares amount of shares that the deposit will represent.
 117 |     |      */
 118 |     |     function previewDeposit(uint256 _amount0, uint256 _amount1) external view returns (uint256 shares, uint256 amount0, uint256 amount1) {
 119 |     |         uint256 price = strategy.price();
 120 |     | 
 121 |     |         (uint bal0, uint bal1) = balances();
 122 |     | 
 123 |     |         (amount0, amount1) = _getTokensRequired(price, _amount0, _amount1, bal0, bal1);
 124 |     | 
 125 |     |         uint256 _totalSupply = totalSupply();
 126 |     | 
 127 |     |         if (_totalSupply == 0) {
 128 |     |             bal0 = _amount0;
 129 |     |             bal1 = _amount1;
 130 |     |         }
 131 |     | 
 132 |     |         shares = amount1 + (amount0 * price / PRECISION); 
 133 |     | 
 134 |     |         if (_totalSupply > 0) {
 135 |     |             // How much of wants() do we have in token 1 equivalents;
 136 |     |             uint256 token1EquivalentBalance = (((bal0 * price) + PRECISION - 1) / PRECISION) + bal1;
 137 |     |             shares = shares * _totalSupply / token1EquivalentBalance;
 138 |     |         } else {
 139 |     |             // First user donates MINIMUM_SHARES for security of the vault. 
 140 |     |             shares =  shares - MINIMUM_SHARES;
 141 |     |         }
 142 |     |     }
 143 |     | 
 144 |     |     /// @notice Get the amount of tokens required to deposit to reach the desired balance of the strategy.
 145 |     |     function _getTokensRequired(uint256 _price, uint256 _amount0, uint256 _amount1, uint256 _bal0, uint256 _bal1) private pure returns (uint256 depositAmount0, uint256 depositAmount1) {
 146 |     |         // get the amount of bal0 that is equivalent to bal1
 147 |     |         if (_bal0 == 0 && _bal1 == 0) return (_amount0, _amount1);
 148 |     | 
 149 |     |         uint256 bal0InBal1 = (_bal0 * _price) / PRECISION;
 150 |     | 
 151 |     |         // check which side is lower and supply as much as possible
 152 |     |         if (_bal1 < bal0InBal1) {
 153 |     |             uint256 finalBalanceForAmount1 = _bal1 + _amount1;
 154 |     |             uint256 owedAmount0 = finalBalanceForAmount1 > bal0InBal1 
 155 |     |                 ? (finalBalanceForAmount1 - bal0InBal1) * PRECISION / _price 
 156 |     |                 : 0;
 157 |     |             if (owedAmount0 > _amount0) {
 158 |     |                 depositAmount0 = _amount0;
 159 |     |                 depositAmount1 = _amount1 - ( (owedAmount0 - _amount0) * _price / PRECISION );
 160 |     |             } else {
 161 |     |                 depositAmount0 = owedAmount0;
 162 |     |                 depositAmount1 = _amount1;
 163 |     |             }
 164 |     |         } else {
 165 |     |             uint256 finalBalanceForAmount0 = bal0InBal1 + ( _amount0 * _price / PRECISION );
 166 |     |             uint256 owedAmount1 = finalBalanceForAmount0 > _bal1 
 167 |     |                 ? finalBalanceForAmount0 - _bal1
 168 |     |                 : 0;
 169 |     |             if (owedAmount1 > _amount1) {
 170 |     |                 depositAmount0 = _amount0 - ( (owedAmount1 - _amount1) * PRECISION / _price );
 171 |     |                 depositAmount1 = _amount1;
 172 |     |             } else {
 173 |     |                 depositAmount0 = _amount0;
 174 |     |                 depositAmount1 = owedAmount1;
 175 |     |             }
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /**
 180 |     |      * @notice The entrypoint of funds into the system. People deposit with this function
 181 |     |      * into the vault. The vault is then in charge of sending funds into the strategy.
 182 |     |      * @dev Use previewDeposit to find the proper ratio to deposit into the vault. 
 183 |     |      * @param _amount0 the amount of token0 to deposit.
 184 |     |      * @param _amount1 the amount of token1 to deposit.
 185 |     |      * @param _minShares the minimum amount of shares that the user wants to recieve with slippage.
 186 |     |      */
 187 |     |     function deposit(uint256 _amount0, uint256 _amount1, uint256 _minShares) public nonReentrant {
 188 |     |         (address token0, address token1) = wants();
 189 |     |         
 190 |     |         // Have the strategy remove all liquidity from the pool.
 191 |     |         strategy.beforeAction();
 192 |     | 
 193 |     |         /// @dev Do not allow deposits of inflationary tokens.
 194 |     |         // Transfer funds from user and send to strategy.
 195 |     |         (uint256 _bal0, uint256 _bal1) = balances();
 196 |     |         uint256 price = strategy.price();
 197 |     |         (uint256 amount0, uint256 amount1) = _getTokensRequired(price, _amount0, _amount1, _bal0, _bal1);
 198 |     |         if (amount0 > _amount0 || amount1 > _amount1) revert NotEnoughTokens();
 199 |     |         
 200 |     |         if (amount0 > 0) IERC20Upgradeable(token0).safeTransferFrom(msg.sender, address(strategy), amount0);
 201 |     |         if (amount1 > 0) IERC20Upgradeable(token1).safeTransferFrom(msg.sender, address(strategy), amount1);
 202 |     |         (uint256 _after0, uint256 _after1) = balances();
 203 |     |         strategy.deposit();
 204 |     |         
 205 |     |         amount0 = _after0 - _bal0;
 206 |     |         amount1 = _after1 - _bal1;
 207 |     | 
 208 |     |         uint256 shares = amount1 + (amount0 * price / PRECISION);
 209 |     | 
 210 |     |         uint256 _totalSupply = totalSupply();
 211 |     |         if (_totalSupply > 0) {
 212 |     |             // How much of wants() do we have in token 1 equivalents;
 213 |     |             uint256 token1EquivalentBalance = (((_bal0 * price) + PRECISION - 1) / PRECISION) + _bal1;
 214 |     |             shares = shares * _totalSupply / token1EquivalentBalance;
 215 |     |         } else {
 216 |     |             // First user donates MINIMUM_SHARES for security of the vault. 
 217 |     |             shares =  shares - MINIMUM_SHARES;
 218 |     |             _mint(BURN_ADDRESS, MINIMUM_SHARES); // permanently lock the first MINIMUM_SHARES
 219 |     |         }
 220 |     | 
 221 |     |         if (shares < _minShares) revert TooMuchSlippage();
 222 |     |         if (shares == 0) revert NoShares();
 223 |     | 
 224 |     |         _mint(msg.sender, shares);
 225 |     |         emit Deposit(msg.sender, shares, amount0, amount1);
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @dev A helper function to call withdraw() with all the sender's funds.
 230 |     |      * @param _minAmount0 the minimum amount of token0 that the user wants to recieve with slippage.
 231 |     |      * @param _minAmount1 the minimum amount of token1 that the user wants to recieve with slippage.
 232 |     |      */
 233 |     |     function withdrawAll(uint256 _minAmount0, uint256 _minAmount1) external {
 234 |     |         withdraw(balanceOf(msg.sender), _minAmount0, _minAmount1);
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @notice Function to exit the system. The vault will withdraw the required tokens
 239 |     |      * from the strategy and pay up the token holder. A proportional number of IOU
 240 |     |      * tokens are burned in the process.
 241 |     |      * @param _shares the number of shares to withdraw.
 242 |     |      * @param _minAmount0 the minimum amount of token0 that the user wants to recieve with slippage.
 243 |     |      * @param _minAmount1 the minimum amount of token1 that the user wants to recieve with slippage.
 244 |     |      */
 245 |     |     function withdraw(uint256 _shares, uint256 _minAmount0, uint256 _minAmount1) public {
 246 |     |         if (_shares == 0) revert NoShares();
 247 |     |         
 248 |     |         // Withdraw All Liquidity to Strat for Accounting.
 249 |     |         strategy.beforeAction();
 250 |     | 
 251 |     |         uint256 _totalSupply = totalSupply();
 252 |     |         _burn(msg.sender, _shares);
 253 |     | 
 254 |     |         (uint256 _bal0, uint256 _bal1) = balances();
 255 |     | 
 256 |     |         uint256 _amount0 = (_bal0 * _shares) / _totalSupply;
 257 |     |         uint256 _amount1 = (_bal1 * _shares) / _totalSupply;
 258 |     | 
 259 |     |         strategy.withdraw(_amount0, _amount1);
 260 |     | 
 261 |     |         if (
 262 |     |             _amount0 < _minAmount0 || 
 263 |     |             _amount1 < _minAmount1 ||
 264 |     |             (_amount0 == 0 && _amount1 == 0)
 265 |     |         ) revert TooMuchSlippage();
 266 |     | 
 267 |     |         (address token0, address token1) = wants();
 268 |     |         IERC20Upgradeable(token0).safeTransfer(msg.sender, _amount0);
 269 |     |         IERC20Upgradeable(token1).safeTransfer(msg.sender, _amount1);
 270 |     | 
 271 |     |         emit Withdraw(msg.sender, _shares, _amount0, _amount1);
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev Rescues random funds stuck that the strat can't handle.
 276 |     |      * @param _token address of the token to rescue.
 277 |     |      */
 278 |     |     function inCaseTokensGetStuck(address _token) external onlyOwner {
 279 |     |         uint256 amount = IERC20Upgradeable(_token).balanceOf(address(this));
 280 |     |         IERC20Upgradeable(_token).safeTransfer(msg.sender, amount);
 281 |     |     }
 282 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/vault/BeefyVaultConcLiqFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.23;
  3 |     | 
  4 |     | import {BeefyVaultConcLiq} from "./BeefyVaultConcLiq.sol";
  5 |     | import {ClonesUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol";
  6 |     | 
  7 |     | // Beefy Finance Vault ConcLiq Proxy Factory
  8 |     | // Minimal proxy pattern for creating new Beefy concentrated liquidity vaults
  9 | *   | contract BeefyVaultConcLiqFactory {
 10 |     |   using ClonesUpgradeable for address;
 11 |     | 
 12 |     |   /// @notice Contract template for deploying proxied Beefy vaults
 13 | *   |   BeefyVaultConcLiq public instance;
 14 |     | 
 15 |     |   /// @notice Emitted when a new Beefy Vault is created
 16 |     |   event ProxyCreated(address proxy);
 17 |     | 
 18 |     |   /** 
 19 |     |    * @notice Constructor initializes the Beefy Vault template instance
 20 |     |    * @param _instance The address of the Beefy Vault template instance
 21 |     |    */
 22 |     |   constructor(address _instance) {
 23 |     |     if (_instance == address(0)) {
 24 |     |       instance = new BeefyVaultConcLiq();
 25 |     |     } else {
 26 |     |       instance = BeefyVaultConcLiq(_instance);
 27 |     |     }
 28 |     |   }
 29 |     | 
 30 |     |   /**
 31 |     |    * @notice Create a new Beefy Conc Liq Vault as a proxy of the template instance
 32 |     |    * @return A reference to the new proxied Beefy Vault
 33 |     |    */
 34 | *   |   function cloneVault(
 35 | *   |   ) external returns (BeefyVaultConcLiq) {
 36 | *   |     BeefyVaultConcLiq vault = BeefyVaultConcLiq(_cloneContract(address(instance)));
 37 |     |     return vault;
 38 |     |   }
 39 |     | 
 40 |     |   /**
 41 |     |    * Deploys and returns the address of a clone that mimics the behaviour of `implementation`
 42 |     |    * @param implementation The address of the contract to clone
 43 |     |    * @return The address of the newly created clone
 44 |     |   */
 45 | *   |   function _cloneContract(address implementation) private returns (address) {
 46 | *   |     address proxy = implementation.clone();
 47 | *   |     emit ProxyCreated(proxy);
 48 | *   |     return proxy;
 49 |     |   }
 50 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/access/Ownable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which provides a basic access control mechanism, where
  10 |     |  * there is an account (an owner) that can be granted exclusive access to
  11 |     |  * specific functions.
  12 |     |  *
  13 |     |  * The initial owner is set to the address provided by the deployer. This can
  14 |     |  * later be changed with {transferOwnership}.
  15 |     |  *
  16 |     |  * This module is used through inheritance. It will make available the modifier
  17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
  18 |     |  * the owner.
  19 |     |  */
  20 |     | abstract contract Ownable is Context {
  21 |     |     address private _owner;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev The caller account is not authorized to perform an operation.
  25 |     |      */
  26 |     |     error OwnableUnauthorizedAccount(address account);
  27 |     | 
  28 |     |     /**
  29 |     |      * @dev The owner is not a valid owner account. (eg. `address(0)`)
  30 |     |      */
  31 |     |     error OwnableInvalidOwner(address owner);
  32 |     | 
  33 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
  37 |     |      */
  38 |     |     constructor(address initialOwner) {
  39 |     |         if (initialOwner == address(0)) {
  40 |     |             revert OwnableInvalidOwner(address(0));
  41 |     |         }
  42 |     |         _transferOwnership(initialOwner);
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Throws if called by any account other than the owner.
  47 |     |      */
  48 |     |     modifier onlyOwner() {
  49 |     |         _checkOwner();
  50 |     |         _;
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Returns the address of the current owner.
  55 |     |      */
  56 |     |     function owner() public view virtual returns (address) {
  57 |     |         return _owner;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Throws if the sender is not the owner.
  62 |     |      */
  63 |     |     function _checkOwner() internal view virtual {
  64 |     |         if (owner() != _msgSender()) {
  65 |     |             revert OwnableUnauthorizedAccount(_msgSender());
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Leaves the contract without owner. It will not be possible to call
  71 |     |      * `onlyOwner` functions. Can only be called by the current owner.
  72 |     |      *
  73 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
  74 |     |      * thereby disabling any functionality that is only available to the owner.
  75 |     |      */
  76 |     |     function renounceOwnership() public virtual onlyOwner {
  77 |     |         _transferOwnership(address(0));
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  82 |     |      * Can only be called by the current owner.
  83 |     |      */
  84 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
  85 |     |         if (newOwner == address(0)) {
  86 |     |             revert OwnableInvalidOwner(address(0));
  87 |     |         }
  88 |     |         _transferOwnership(newOwner);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  93 |     |      * Internal function without access restriction.
  94 |     |      */
  95 |     |     function _transferOwnership(address newOwner) internal virtual {
  96 |     |         address oldOwner = _owner;
  97 |     |         _owner = newOwner;
  98 |     |         emit OwnershipTransferred(oldOwner, newOwner);
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 |     |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 |     |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 |     |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC1155 Errors
 111 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  */
  34 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  35 |     |     mapping(address account => uint256) private _balances;
  36 |     | 
  37 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  38 |     | 
  39 |     |     uint256 private _totalSupply;
  40 |     | 
  41 |     |     string private _name;
  42 |     |     string private _symbol;
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Sets the values for {name} and {symbol}.
  46 |     |      *
  47 |     |      * All two of these values are immutable: they can only be set once during
  48 |     |      * construction.
  49 |     |      */
  50 |     |     constructor(string memory name_, string memory symbol_) {
  51 |     |         _name = name_;
  52 |     |         _symbol = symbol_;
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Returns the name of the token.
  57 |     |      */
  58 |     |     function name() public view virtual returns (string memory) {
  59 |     |         return _name;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  64 |     |      * name.
  65 |     |      */
  66 |     |     function symbol() public view virtual returns (string memory) {
  67 |     |         return _symbol;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the number of decimals used to get its user representation.
  72 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  73 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  74 |     |      *
  75 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  76 |     |      * Ether and Wei. This is the default value returned by this function, unless
  77 |     |      * it's overridden.
  78 |     |      *
  79 |     |      * NOTE: This information is only used for _display_ purposes: it in
  80 |     |      * no way affects any of the arithmetic of the contract, including
  81 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  82 |     |      */
  83 |     |     function decimals() public view virtual returns (uint8) {
  84 |     |         return 18;
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev See {IERC20-totalSupply}.
  89 |     |      */
  90 |     |     function totalSupply() public view virtual returns (uint256) {
  91 |     |         return _totalSupply;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev See {IERC20-balanceOf}.
  96 |     |      */
  97 |     |     function balanceOf(address account) public view virtual returns (uint256) {
  98 |     |         return _balances[account];
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev See {IERC20-transfer}.
 103 |     |      *
 104 |     |      * Requirements:
 105 |     |      *
 106 |     |      * - `to` cannot be the zero address.
 107 |     |      * - the caller must have a balance of at least `value`.
 108 |     |      */
 109 |     |     function transfer(address to, uint256 value) public virtual returns (bool) {
 110 |     |         address owner = _msgSender();
 111 |     |         _transfer(owner, to, value);
 112 |     |         return true;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev See {IERC20-allowance}.
 117 |     |      */
 118 |     |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 119 |     |         return _allowances[owner][spender];
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev See {IERC20-approve}.
 124 |     |      *
 125 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 126 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 127 |     |      *
 128 |     |      * Requirements:
 129 |     |      *
 130 |     |      * - `spender` cannot be the zero address.
 131 |     |      */
 132 |     |     function approve(address spender, uint256 value) public virtual returns (bool) {
 133 |     |         address owner = _msgSender();
 134 |     |         _approve(owner, spender, value);
 135 |     |         return true;
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev See {IERC20-transferFrom}.
 140 |     |      *
 141 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 142 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 143 |     |      *
 144 |     |      * NOTE: Does not update the allowance if the current allowance
 145 |     |      * is the maximum `uint256`.
 146 |     |      *
 147 |     |      * Requirements:
 148 |     |      *
 149 |     |      * - `from` and `to` cannot be the zero address.
 150 |     |      * - `from` must have a balance of at least `value`.
 151 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 152 |     |      * `value`.
 153 |     |      */
 154 |     |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 155 |     |         address spender = _msgSender();
 156 |     |         _spendAllowance(from, spender, value);
 157 |     |         _transfer(from, to, value);
 158 |     |         return true;
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 163 |     |      *
 164 |     |      * This internal function is equivalent to {transfer}, and can be used to
 165 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 166 |     |      *
 167 |     |      * Emits a {Transfer} event.
 168 |     |      *
 169 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 170 |     |      */
 171 |     |     function _transfer(address from, address to, uint256 value) internal {
 172 |     |         if (from == address(0)) {
 173 |     |             revert ERC20InvalidSender(address(0));
 174 |     |         }
 175 |     |         if (to == address(0)) {
 176 |     |             revert ERC20InvalidReceiver(address(0));
 177 |     |         }
 178 |     |         _update(from, to, value);
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 183 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 184 |     |      * this function.
 185 |     |      *
 186 |     |      * Emits a {Transfer} event.
 187 |     |      */
 188 |     |     function _update(address from, address to, uint256 value) internal virtual {
 189 |     |         if (from == address(0)) {
 190 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 191 |     |             _totalSupply += value;
 192 |     |         } else {
 193 |     |             uint256 fromBalance = _balances[from];
 194 |     |             if (fromBalance < value) {
 195 |     |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 196 |     |             }
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 199 |     |                 _balances[from] = fromBalance - value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 |     |         if (to == address(0)) {
 204 |     |             unchecked {
 205 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 206 |     |                 _totalSupply -= value;
 207 |     |             }
 208 |     |         } else {
 209 |     |             unchecked {
 210 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 211 |     |                 _balances[to] += value;
 212 |     |             }
 213 |     |         }
 214 |     | 
 215 |     |         emit Transfer(from, to, value);
 216 |     |     }
 217 |     | 
 218 |     |     /**
 219 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 220 |     |      * Relies on the `_update` mechanism
 221 |     |      *
 222 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 223 |     |      *
 224 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 225 |     |      */
 226 |     |     function _mint(address account, uint256 value) internal {
 227 |     |         if (account == address(0)) {
 228 |     |             revert ERC20InvalidReceiver(address(0));
 229 |     |         }
 230 |     |         _update(address(0), account, value);
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 235 |     |      * Relies on the `_update` mechanism.
 236 |     |      *
 237 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 238 |     |      *
 239 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 240 |     |      */
 241 |     |     function _burn(address account, uint256 value) internal {
 242 |     |         if (account == address(0)) {
 243 |     |             revert ERC20InvalidSender(address(0));
 244 |     |         }
 245 |     |         _update(account, address(0), value);
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.
 250 |     |      *
 251 |     |      * This internal function is equivalent to `approve`, and can be used to
 252 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 253 |     |      *
 254 |     |      * Emits an {Approval} event.
 255 |     |      *
 256 |     |      * Requirements:
 257 |     |      *
 258 |     |      * - `owner` cannot be the zero address.
 259 |     |      * - `spender` cannot be the zero address.
 260 |     |      *
 261 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 262 |     |      */
 263 |     |     function _approve(address owner, address spender, uint256 value) internal {
 264 |     |         _approve(owner, spender, value, true);
 265 |     |     }
 266 |     | 
 267 |     |     /**
 268 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 269 |     |      *
 270 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 271 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 272 |     |      * `Approval` event during `transferFrom` operations.
 273 |     |      *
 274 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 275 |     |      * true using the following override:
 276 |     |      * ```
 277 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 278 |     |      *     super._approve(owner, spender, value, true);
 279 |     |      * }
 280 |     |      * ```
 281 |     |      *
 282 |     |      * Requirements are the same as {_approve}.
 283 |     |      */
 284 |     |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 285 |     |         if (owner == address(0)) {
 286 |     |             revert ERC20InvalidApprover(address(0));
 287 |     |         }
 288 |     |         if (spender == address(0)) {
 289 |     |             revert ERC20InvalidSpender(address(0));
 290 |     |         }
 291 |     |         _allowances[owner][spender] = value;
 292 |     |         if (emitEvent) {
 293 |     |             emit Approval(owner, spender, value);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `value`.
 299 |     |      *
 300 |     |      * Does not update the allowance value in case of infinite allowance.
 301 |     |      * Revert if not enough allowance is available.
 302 |     |      *
 303 |     |      * Does not emit an {Approval} event.
 304 |     |      */
 305 |     |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 306 |     |         uint256 currentAllowance = allowance(owner, spender);
 307 |     |         if (currentAllowance != type(uint256).max) {
 308 |     |             if (currentAllowance < value) {
 309 |     |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 310 |     |             }
 311 |     |             unchecked {
 312 |     |                 _approve(owner, spender, currentAllowance - value, false);
 313 |     |             }
 314 |     |         }
 315 |     |     }
 316 |     | }
 317 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/solmate/lib/ds-test/src/test.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | 
   3 |     | // This program is free software: you can redistribute it and/or modify
   4 |     | // it under the terms of the GNU General Public License as published by
   5 |     | // the Free Software Foundation, either version 3 of the License, or
   6 |     | // (at your option) any later version.
   7 |     | 
   8 |     | // This program is distributed in the hope that it will be useful,
   9 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  10 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11 |     | // GNU General Public License for more details.
  12 |     | 
  13 |     | // You should have received a copy of the GNU General Public License
  14 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15 |     | 
  16 |     | pragma solidity >=0.5.0;
  17 |     | 
  18 |     | contract DSTest {
  19 |     |     event log                    (string);
  20 |     |     event logs                   (bytes);
  21 |     | 
  22 |     |     event log_address            (address);
  23 |     |     event log_bytes32            (bytes32);
  24 |     |     event log_int                (int);
  25 |     |     event log_uint               (uint);
  26 |     |     event log_bytes              (bytes);
  27 |     |     event log_string             (string);
  28 |     | 
  29 |     |     event log_named_address      (string key, address val);
  30 |     |     event log_named_bytes32      (string key, bytes32 val);
  31 |     |     event log_named_decimal_int  (string key, int val, uint decimals);
  32 |     |     event log_named_decimal_uint (string key, uint val, uint decimals);
  33 |     |     event log_named_int          (string key, int val);
  34 |     |     event log_named_uint         (string key, uint val);
  35 |     |     event log_named_bytes        (string key, bytes val);
  36 |     |     event log_named_string       (string key, string val);
  37 |     | 
  38 |     |     bool public IS_TEST = true;
  39 |     |     bool private _failed;
  40 |     | 
  41 |     |     address constant HEVM_ADDRESS =
  42 |     |         address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));
  43 |     | 
  44 |     |     modifier mayRevert() { _; }
  45 |     |     modifier testopts(string memory) { _; }
  46 |     | 
  47 |     |     function failed() public returns (bool) {
  48 |     |         if (_failed) {
  49 |     |             return _failed;
  50 |     |         } else {
  51 |     |             bool globalFailed = false;
  52 |     |             if (hasHEVMContext()) {
  53 |     |                 (, bytes memory retdata) = HEVM_ADDRESS.call(
  54 |     |                     abi.encodePacked(
  55 |     |                         bytes4(keccak256("load(address,bytes32)")),
  56 |     |                         abi.encode(HEVM_ADDRESS, bytes32("failed"))
  57 |     |                     )
  58 |     |                 );
  59 |     |                 globalFailed = abi.decode(retdata, (bool));
  60 |     |             }
  61 |     |             return globalFailed;
  62 |     |         }
  63 |     |     } 
  64 |     | 
  65 |     |     function fail() internal {
  66 |     |         if (hasHEVMContext()) {
  67 |     |             (bool status, ) = HEVM_ADDRESS.call(
  68 |     |                 abi.encodePacked(
  69 |     |                     bytes4(keccak256("store(address,bytes32,bytes32)")),
  70 |     |                     abi.encode(HEVM_ADDRESS, bytes32("failed"), bytes32(uint256(0x01)))
  71 |     |                 )
  72 |     |             );
  73 |     |             status; // Silence compiler warnings
  74 |     |         }
  75 |     |         _failed = true;
  76 |     |     }
  77 |     | 
  78 |     |     function hasHEVMContext() internal view returns (bool) {
  79 |     |         uint256 hevmCodeSize = 0;
  80 |     |         assembly {
  81 |     |             hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)
  82 |     |         }
  83 |     |         return hevmCodeSize > 0;
  84 |     |     }
  85 |     | 
  86 |     |     modifier logs_gas() {
  87 |     |         uint startGas = gasleft();
  88 |     |         _;
  89 |     |         uint endGas = gasleft();
  90 |     |         emit log_named_uint("gas", startGas - endGas);
  91 |     |     }
  92 |     | 
  93 |     |     function assertTrue(bool condition) internal {
  94 |     |         if (!condition) {
  95 |     |             emit log("Error: Assertion Failed");
  96 |     |             fail();
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     function assertTrue(bool condition, string memory err) internal {
 101 |     |         if (!condition) {
 102 |     |             emit log_named_string("Error", err);
 103 |     |             assertTrue(condition);
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address a, address b) internal {
 108 |     |         if (a != b) {
 109 |     |             emit log("Error: a == b not satisfied [address]");
 110 |     |             emit log_named_address("  Expected", b);
 111 |     |             emit log_named_address("    Actual", a);
 112 |     |             fail();
 113 |     |         }
 114 |     |     }
 115 |     |     function assertEq(address a, address b, string memory err) internal {
 116 |     |         if (a != b) {
 117 |     |             emit log_named_string ("Error", err);
 118 |     |             assertEq(a, b);
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     function assertEq(bytes32 a, bytes32 b) internal {
 123 |     |         if (a != b) {
 124 |     |             emit log("Error: a == b not satisfied [bytes32]");
 125 |     |             emit log_named_bytes32("  Expected", b);
 126 |     |             emit log_named_bytes32("    Actual", a);
 127 |     |             fail();
 128 |     |         }
 129 |     |     }
 130 |     |     function assertEq(bytes32 a, bytes32 b, string memory err) internal {
 131 |     |         if (a != b) {
 132 |     |             emit log_named_string ("Error", err);
 133 |     |             assertEq(a, b);
 134 |     |         }
 135 |     |     }
 136 |     |     function assertEq32(bytes32 a, bytes32 b) internal {
 137 |     |         assertEq(a, b);
 138 |     |     }
 139 |     |     function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
 140 |     |         assertEq(a, b, err);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(int a, int b) internal {
 144 |     |         if (a != b) {
 145 |     |             emit log("Error: a == b not satisfied [int]");
 146 |     |             emit log_named_int("  Expected", b);
 147 |     |             emit log_named_int("    Actual", a);
 148 |     |             fail();
 149 |     |         }
 150 |     |     }
 151 |     |     function assertEq(int a, int b, string memory err) internal {
 152 |     |         if (a != b) {
 153 |     |             emit log_named_string("Error", err);
 154 |     |             assertEq(a, b);
 155 |     |         }
 156 |     |     }
 157 |     |     function assertEq(uint a, uint b) internal {
 158 |     |         if (a != b) {
 159 |     |             emit log("Error: a == b not satisfied [uint]");
 160 |     |             emit log_named_uint("  Expected", b);
 161 |     |             emit log_named_uint("    Actual", a);
 162 |     |             fail();
 163 |     |         }
 164 |     |     }
 165 |     |     function assertEq(uint a, uint b, string memory err) internal {
 166 |     |         if (a != b) {
 167 |     |             emit log_named_string("Error", err);
 168 |     |             assertEq(a, b);
 169 |     |         }
 170 |     |     }
 171 |     |     function assertEqDecimal(int a, int b, uint decimals) internal {
 172 |     |         if (a != b) {
 173 |     |             emit log("Error: a == b not satisfied [decimal int]");
 174 |     |             emit log_named_decimal_int("  Expected", b, decimals);
 175 |     |             emit log_named_decimal_int("    Actual", a, decimals);
 176 |     |             fail();
 177 |     |         }
 178 |     |     }
 179 |     |     function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
 180 |     |         if (a != b) {
 181 |     |             emit log_named_string("Error", err);
 182 |     |             assertEqDecimal(a, b, decimals);
 183 |     |         }
 184 |     |     }
 185 |     |     function assertEqDecimal(uint a, uint b, uint decimals) internal {
 186 |     |         if (a != b) {
 187 |     |             emit log("Error: a == b not satisfied [decimal uint]");
 188 |     |             emit log_named_decimal_uint("  Expected", b, decimals);
 189 |     |             emit log_named_decimal_uint("    Actual", a, decimals);
 190 |     |             fail();
 191 |     |         }
 192 |     |     }
 193 |     |     function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
 194 |     |         if (a != b) {
 195 |     |             emit log_named_string("Error", err);
 196 |     |             assertEqDecimal(a, b, decimals);
 197 |     |         }
 198 |     |     }
 199 |     | 
 200 |     |     function assertGt(uint a, uint b) internal {
 201 |     |         if (a <= b) {
 202 |     |             emit log("Error: a > b not satisfied [uint]");
 203 |     |             emit log_named_uint("  Value a", a);
 204 |     |             emit log_named_uint("  Value b", b);
 205 |     |             fail();
 206 |     |         }
 207 |     |     }
 208 |     |     function assertGt(uint a, uint b, string memory err) internal {
 209 |     |         if (a <= b) {
 210 |     |             emit log_named_string("Error", err);
 211 |     |             assertGt(a, b);
 212 |     |         }
 213 |     |     }
 214 |     |     function assertGt(int a, int b) internal {
 215 |     |         if (a <= b) {
 216 |     |             emit log("Error: a > b not satisfied [int]");
 217 |     |             emit log_named_int("  Value a", a);
 218 |     |             emit log_named_int("  Value b", b);
 219 |     |             fail();
 220 |     |         }
 221 |     |     }
 222 |     |     function assertGt(int a, int b, string memory err) internal {
 223 |     |         if (a <= b) {
 224 |     |             emit log_named_string("Error", err);
 225 |     |             assertGt(a, b);
 226 |     |         }
 227 |     |     }
 228 |     |     function assertGtDecimal(int a, int b, uint decimals) internal {
 229 |     |         if (a <= b) {
 230 |     |             emit log("Error: a > b not satisfied [decimal int]");
 231 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 232 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 233 |     |             fail();
 234 |     |         }
 235 |     |     }
 236 |     |     function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
 237 |     |         if (a <= b) {
 238 |     |             emit log_named_string("Error", err);
 239 |     |             assertGtDecimal(a, b, decimals);
 240 |     |         }
 241 |     |     }
 242 |     |     function assertGtDecimal(uint a, uint b, uint decimals) internal {
 243 |     |         if (a <= b) {
 244 |     |             emit log("Error: a > b not satisfied [decimal uint]");
 245 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 246 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 247 |     |             fail();
 248 |     |         }
 249 |     |     }
 250 |     |     function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 251 |     |         if (a <= b) {
 252 |     |             emit log_named_string("Error", err);
 253 |     |             assertGtDecimal(a, b, decimals);
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     function assertGe(uint a, uint b) internal {
 258 |     |         if (a < b) {
 259 |     |             emit log("Error: a >= b not satisfied [uint]");
 260 |     |             emit log_named_uint("  Value a", a);
 261 |     |             emit log_named_uint("  Value b", b);
 262 |     |             fail();
 263 |     |         }
 264 |     |     }
 265 |     |     function assertGe(uint a, uint b, string memory err) internal {
 266 |     |         if (a < b) {
 267 |     |             emit log_named_string("Error", err);
 268 |     |             assertGe(a, b);
 269 |     |         }
 270 |     |     }
 271 |     |     function assertGe(int a, int b) internal {
 272 |     |         if (a < b) {
 273 |     |             emit log("Error: a >= b not satisfied [int]");
 274 |     |             emit log_named_int("  Value a", a);
 275 |     |             emit log_named_int("  Value b", b);
 276 |     |             fail();
 277 |     |         }
 278 |     |     }
 279 |     |     function assertGe(int a, int b, string memory err) internal {
 280 |     |         if (a < b) {
 281 |     |             emit log_named_string("Error", err);
 282 |     |             assertGe(a, b);
 283 |     |         }
 284 |     |     }
 285 |     |     function assertGeDecimal(int a, int b, uint decimals) internal {
 286 |     |         if (a < b) {
 287 |     |             emit log("Error: a >= b not satisfied [decimal int]");
 288 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 289 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 290 |     |             fail();
 291 |     |         }
 292 |     |     }
 293 |     |     function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
 294 |     |         if (a < b) {
 295 |     |             emit log_named_string("Error", err);
 296 |     |             assertGeDecimal(a, b, decimals);
 297 |     |         }
 298 |     |     }
 299 |     |     function assertGeDecimal(uint a, uint b, uint decimals) internal {
 300 |     |         if (a < b) {
 301 |     |             emit log("Error: a >= b not satisfied [decimal uint]");
 302 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 303 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 304 |     |             fail();
 305 |     |         }
 306 |     |     }
 307 |     |     function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 308 |     |         if (a < b) {
 309 |     |             emit log_named_string("Error", err);
 310 |     |             assertGeDecimal(a, b, decimals);
 311 |     |         }
 312 |     |     }
 313 |     | 
 314 |     |     function assertLt(uint a, uint b) internal {
 315 |     |         if (a >= b) {
 316 |     |             emit log("Error: a < b not satisfied [uint]");
 317 |     |             emit log_named_uint("  Value a", a);
 318 |     |             emit log_named_uint("  Value b", b);
 319 |     |             fail();
 320 |     |         }
 321 |     |     }
 322 |     |     function assertLt(uint a, uint b, string memory err) internal {
 323 |     |         if (a >= b) {
 324 |     |             emit log_named_string("Error", err);
 325 |     |             assertLt(a, b);
 326 |     |         }
 327 |     |     }
 328 |     |     function assertLt(int a, int b) internal {
 329 |     |         if (a >= b) {
 330 |     |             emit log("Error: a < b not satisfied [int]");
 331 |     |             emit log_named_int("  Value a", a);
 332 |     |             emit log_named_int("  Value b", b);
 333 |     |             fail();
 334 |     |         }
 335 |     |     }
 336 |     |     function assertLt(int a, int b, string memory err) internal {
 337 |     |         if (a >= b) {
 338 |     |             emit log_named_string("Error", err);
 339 |     |             assertLt(a, b);
 340 |     |         }
 341 |     |     }
 342 |     |     function assertLtDecimal(int a, int b, uint decimals) internal {
 343 |     |         if (a >= b) {
 344 |     |             emit log("Error: a < b not satisfied [decimal int]");
 345 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 346 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 347 |     |             fail();
 348 |     |         }
 349 |     |     }
 350 |     |     function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
 351 |     |         if (a >= b) {
 352 |     |             emit log_named_string("Error", err);
 353 |     |             assertLtDecimal(a, b, decimals);
 354 |     |         }
 355 |     |     }
 356 |     |     function assertLtDecimal(uint a, uint b, uint decimals) internal {
 357 |     |         if (a >= b) {
 358 |     |             emit log("Error: a < b not satisfied [decimal uint]");
 359 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 360 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 361 |     |             fail();
 362 |     |         }
 363 |     |     }
 364 |     |     function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 365 |     |         if (a >= b) {
 366 |     |             emit log_named_string("Error", err);
 367 |     |             assertLtDecimal(a, b, decimals);
 368 |     |         }
 369 |     |     }
 370 |     | 
 371 |     |     function assertLe(uint a, uint b) internal {
 372 |     |         if (a > b) {
 373 |     |             emit log("Error: a <= b not satisfied [uint]");
 374 |     |             emit log_named_uint("  Value a", a);
 375 |     |             emit log_named_uint("  Value b", b);
 376 |     |             fail();
 377 |     |         }
 378 |     |     }
 379 |     |     function assertLe(uint a, uint b, string memory err) internal {
 380 |     |         if (a > b) {
 381 |     |             emit log_named_string("Error", err);
 382 |     |             assertLe(a, b);
 383 |     |         }
 384 |     |     }
 385 |     |     function assertLe(int a, int b) internal {
 386 |     |         if (a > b) {
 387 |     |             emit log("Error: a <= b not satisfied [int]");
 388 |     |             emit log_named_int("  Value a", a);
 389 |     |             emit log_named_int("  Value b", b);
 390 |     |             fail();
 391 |     |         }
 392 |     |     }
 393 |     |     function assertLe(int a, int b, string memory err) internal {
 394 |     |         if (a > b) {
 395 |     |             emit log_named_string("Error", err);
 396 |     |             assertLe(a, b);
 397 |     |         }
 398 |     |     }
 399 |     |     function assertLeDecimal(int a, int b, uint decimals) internal {
 400 |     |         if (a > b) {
 401 |     |             emit log("Error: a <= b not satisfied [decimal int]");
 402 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 403 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 404 |     |             fail();
 405 |     |         }
 406 |     |     }
 407 |     |     function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
 408 |     |         if (a > b) {
 409 |     |             emit log_named_string("Error", err);
 410 |     |             assertLeDecimal(a, b, decimals);
 411 |     |         }
 412 |     |     }
 413 |     |     function assertLeDecimal(uint a, uint b, uint decimals) internal {
 414 |     |         if (a > b) {
 415 |     |             emit log("Error: a <= b not satisfied [decimal uint]");
 416 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 417 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 418 |     |             fail();
 419 |     |         }
 420 |     |     }
 421 |     |     function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 422 |     |         if (a > b) {
 423 |     |             emit log_named_string("Error", err);
 424 |     |             assertGeDecimal(a, b, decimals);
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     function assertEq(string memory a, string memory b) internal {
 429 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 430 |     |             emit log("Error: a == b not satisfied [string]");
 431 |     |             emit log_named_string("  Expected", b);
 432 |     |             emit log_named_string("    Actual", a);
 433 |     |             fail();
 434 |     |         }
 435 |     |     }
 436 |     |     function assertEq(string memory a, string memory b, string memory err) internal {
 437 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 438 |     |             emit log_named_string("Error", err);
 439 |     |             assertEq(a, b);
 440 |     |         }
 441 |     |     }
 442 |     | 
 443 |     |     function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
 444 |     |         ok = true;
 445 |     |         if (a.length == b.length) {
 446 |     |             for (uint i = 0; i < a.length; i++) {
 447 |     |                 if (a[i] != b[i]) {
 448 |     |                     ok = false;
 449 |     |                 }
 450 |     |             }
 451 |     |         } else {
 452 |     |             ok = false;
 453 |     |         }
 454 |     |     }
 455 |     |     function assertEq0(bytes memory a, bytes memory b) internal {
 456 |     |         if (!checkEq0(a, b)) {
 457 |     |             emit log("Error: a == b not satisfied [bytes]");
 458 |     |             emit log_named_bytes("  Expected", b);
 459 |     |             emit log_named_bytes("    Actual", a);
 460 |     |             fail();
 461 |     |         }
 462 |     |     }
 463 |     |     function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
 464 |     |         if (!checkEq0(a, b)) {
 465 |     |             emit log_named_string("Error", err);
 466 |     |             assertEq0(a, b);
 467 |     |         }
 468 |     |     }
 469 |     | }
 470 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts/access/Ownable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which provides a basic access control mechanism, where
  10 |     |  * there is an account (an owner) that can be granted exclusive access to
  11 |     |  * specific functions.
  12 |     |  *
  13 |     |  * The initial owner is set to the address provided by the deployer. This can
  14 |     |  * later be changed with {transferOwnership}.
  15 |     |  *
  16 |     |  * This module is used through inheritance. It will make available the modifier
  17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
  18 |     |  * the owner.
  19 |     |  */
  20 |     | abstract contract Ownable is Context {
  21 |     |     address private _owner;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev The caller account is not authorized to perform an operation.
  25 |     |      */
  26 |     |     error OwnableUnauthorizedAccount(address account);
  27 |     | 
  28 |     |     /**
  29 |     |      * @dev The owner is not a valid owner account. (eg. `address(0)`)
  30 |     |      */
  31 |     |     error OwnableInvalidOwner(address owner);
  32 |     | 
  33 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
  37 |     |      */
  38 |     |     constructor(address initialOwner) {
  39 |     |         if (initialOwner == address(0)) {
  40 |     |             revert OwnableInvalidOwner(address(0));
  41 |     |         }
  42 |     |         _transferOwnership(initialOwner);
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Throws if called by any account other than the owner.
  47 |     |      */
  48 |     |     modifier onlyOwner() {
  49 | *   |         _checkOwner();
  50 |     |         _;
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Returns the address of the current owner.
  55 |     |      */
  56 | *   |     function owner() public view virtual returns (address) {
  57 | *   |         return _owner;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Throws if the sender is not the owner.
  62 |     |      */
  63 | *   |     function _checkOwner() internal view virtual {
  64 | *   |         if (owner() != _msgSender()) {
  65 | *   |             revert OwnableUnauthorizedAccount(_msgSender());
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Leaves the contract without owner. It will not be possible to call
  71 |     |      * `onlyOwner` functions. Can only be called by the current owner.
  72 |     |      *
  73 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
  74 |     |      * thereby disabling any functionality that is only available to the owner.
  75 |     |      */
  76 | *   |     function renounceOwnership() public virtual onlyOwner {
  77 |     |         _transferOwnership(address(0));
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  82 |     |      * Can only be called by the current owner.
  83 |     |      */
  84 | *   |     function transferOwnership(address newOwner) public virtual onlyOwner {
  85 | *   |         if (newOwner == address(0)) {
  86 | *   |             revert OwnableInvalidOwner(address(0));
  87 |     |         }
  88 | *   |         _transferOwnership(newOwner);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  93 |     |      * Internal function without access restriction.
  94 |     |      */
  95 |     |     function _transferOwnership(address newOwner) internal virtual {
  96 |     |         address oldOwner = _owner;
  97 |     |         _owner = newOwner;
  98 |     |         emit OwnershipTransferred(oldOwner, newOwner);
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 |     |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 |     |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 |     |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC1155 Errors
 111 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  */
  34 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  35 |     |     mapping(address account => uint256) private _balances;
  36 |     | 
  37 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  38 |     | 
  39 |     |     uint256 private _totalSupply;
  40 |     | 
  41 |     |     string private _name;
  42 |     |     string private _symbol;
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Sets the values for {name} and {symbol}.
  46 |     |      *
  47 |     |      * All two of these values are immutable: they can only be set once during
  48 |     |      * construction.
  49 |     |      */
  50 |     |     constructor(string memory name_, string memory symbol_) {
  51 |     |         _name = name_;
  52 |     |         _symbol = symbol_;
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Returns the name of the token.
  57 |     |      */
  58 |     |     function name() public view virtual returns (string memory) {
  59 |     |         return _name;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  64 |     |      * name.
  65 |     |      */
  66 |     |     function symbol() public view virtual returns (string memory) {
  67 |     |         return _symbol;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the number of decimals used to get its user representation.
  72 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  73 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  74 |     |      *
  75 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  76 |     |      * Ether and Wei. This is the default value returned by this function, unless
  77 |     |      * it's overridden.
  78 |     |      *
  79 |     |      * NOTE: This information is only used for _display_ purposes: it in
  80 |     |      * no way affects any of the arithmetic of the contract, including
  81 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  82 |     |      */
  83 |     |     function decimals() public view virtual returns (uint8) {
  84 |     |         return 18;
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev See {IERC20-totalSupply}.
  89 |     |      */
  90 |     |     function totalSupply() public view virtual returns (uint256) {
  91 |     |         return _totalSupply;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev See {IERC20-balanceOf}.
  96 |     |      */
  97 |     |     function balanceOf(address account) public view virtual returns (uint256) {
  98 |     |         return _balances[account];
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev See {IERC20-transfer}.
 103 |     |      *
 104 |     |      * Requirements:
 105 |     |      *
 106 |     |      * - `to` cannot be the zero address.
 107 |     |      * - the caller must have a balance of at least `value`.
 108 |     |      */
 109 |     |     function transfer(address to, uint256 value) public virtual returns (bool) {
 110 |     |         address owner = _msgSender();
 111 |     |         _transfer(owner, to, value);
 112 |     |         return true;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev See {IERC20-allowance}.
 117 |     |      */
 118 |     |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 119 |     |         return _allowances[owner][spender];
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev See {IERC20-approve}.
 124 |     |      *
 125 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 126 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 127 |     |      *
 128 |     |      * Requirements:
 129 |     |      *
 130 |     |      * - `spender` cannot be the zero address.
 131 |     |      */
 132 |     |     function approve(address spender, uint256 value) public virtual returns (bool) {
 133 |     |         address owner = _msgSender();
 134 |     |         _approve(owner, spender, value);
 135 |     |         return true;
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev See {IERC20-transferFrom}.
 140 |     |      *
 141 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 142 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 143 |     |      *
 144 |     |      * NOTE: Does not update the allowance if the current allowance
 145 |     |      * is the maximum `uint256`.
 146 |     |      *
 147 |     |      * Requirements:
 148 |     |      *
 149 |     |      * - `from` and `to` cannot be the zero address.
 150 |     |      * - `from` must have a balance of at least `value`.
 151 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 152 |     |      * `value`.
 153 |     |      */
 154 |     |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 155 |     |         address spender = _msgSender();
 156 |     |         _spendAllowance(from, spender, value);
 157 |     |         _transfer(from, to, value);
 158 |     |         return true;
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 163 |     |      *
 164 |     |      * This internal function is equivalent to {transfer}, and can be used to
 165 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 166 |     |      *
 167 |     |      * Emits a {Transfer} event.
 168 |     |      *
 169 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 170 |     |      */
 171 |     |     function _transfer(address from, address to, uint256 value) internal {
 172 |     |         if (from == address(0)) {
 173 |     |             revert ERC20InvalidSender(address(0));
 174 |     |         }
 175 |     |         if (to == address(0)) {
 176 |     |             revert ERC20InvalidReceiver(address(0));
 177 |     |         }
 178 |     |         _update(from, to, value);
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 183 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 184 |     |      * this function.
 185 |     |      *
 186 |     |      * Emits a {Transfer} event.
 187 |     |      */
 188 |     |     function _update(address from, address to, uint256 value) internal virtual {
 189 |     |         if (from == address(0)) {
 190 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 191 |     |             _totalSupply += value;
 192 |     |         } else {
 193 |     |             uint256 fromBalance = _balances[from];
 194 |     |             if (fromBalance < value) {
 195 |     |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 196 |     |             }
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 199 |     |                 _balances[from] = fromBalance - value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 |     |         if (to == address(0)) {
 204 |     |             unchecked {
 205 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 206 |     |                 _totalSupply -= value;
 207 |     |             }
 208 |     |         } else {
 209 |     |             unchecked {
 210 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 211 |     |                 _balances[to] += value;
 212 |     |             }
 213 |     |         }
 214 |     | 
 215 |     |         emit Transfer(from, to, value);
 216 |     |     }
 217 |     | 
 218 |     |     /**
 219 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 220 |     |      * Relies on the `_update` mechanism
 221 |     |      *
 222 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 223 |     |      *
 224 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 225 |     |      */
 226 |     |     function _mint(address account, uint256 value) internal {
 227 |     |         if (account == address(0)) {
 228 |     |             revert ERC20InvalidReceiver(address(0));
 229 |     |         }
 230 |     |         _update(address(0), account, value);
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 235 |     |      * Relies on the `_update` mechanism.
 236 |     |      *
 237 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 238 |     |      *
 239 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 240 |     |      */
 241 |     |     function _burn(address account, uint256 value) internal {
 242 |     |         if (account == address(0)) {
 243 |     |             revert ERC20InvalidSender(address(0));
 244 |     |         }
 245 |     |         _update(account, address(0), value);
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.
 250 |     |      *
 251 |     |      * This internal function is equivalent to `approve`, and can be used to
 252 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 253 |     |      *
 254 |     |      * Emits an {Approval} event.
 255 |     |      *
 256 |     |      * Requirements:
 257 |     |      *
 258 |     |      * - `owner` cannot be the zero address.
 259 |     |      * - `spender` cannot be the zero address.
 260 |     |      *
 261 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 262 |     |      */
 263 |     |     function _approve(address owner, address spender, uint256 value) internal {
 264 |     |         _approve(owner, spender, value, true);
 265 |     |     }
 266 |     | 
 267 |     |     /**
 268 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 269 |     |      *
 270 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 271 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 272 |     |      * `Approval` event during `transferFrom` operations.
 273 |     |      *
 274 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 275 |     |      * true using the following override:
 276 |     |      * ```
 277 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 278 |     |      *     super._approve(owner, spender, value, true);
 279 |     |      * }
 280 |     |      * ```
 281 |     |      *
 282 |     |      * Requirements are the same as {_approve}.
 283 |     |      */
 284 |     |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 285 |     |         if (owner == address(0)) {
 286 |     |             revert ERC20InvalidApprover(address(0));
 287 |     |         }
 288 |     |         if (spender == address(0)) {
 289 |     |             revert ERC20InvalidSpender(address(0));
 290 |     |         }
 291 |     |         _allowances[owner][spender] = value;
 292 |     |         if (emitEvent) {
 293 |     |             emit Approval(owner, spender, value);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `value`.
 299 |     |      *
 300 |     |      * Does not update the allowance value in case of infinite allowance.
 301 |     |      * Revert if not enough allowance is available.
 302 |     |      *
 303 |     |      * Does not emit an {Approval} event.
 304 |     |      */
 305 |     |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 306 |     |         uint256 currentAllowance = allowance(owner, spender);
 307 |     |         if (currentAllowance != type(uint256).max) {
 308 |     |             if (currentAllowance < value) {
 309 |     |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 310 |     |             }
 311 |     |             unchecked {
 312 |     |                 _approve(owner, spender, currentAllowance - value, false);
 313 |     |             }
 314 |     |         }
 315 |     |     }
 316 |     | }
 317 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 | *   |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 | *   |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 | *   |     /**
 44 | *   |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 | *   |      * zero by default.
 47 | *   |      *
 48 | *   |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 | *   |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 | *   |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 | *   |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 | *   |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 | *   | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/ContextUpgradeable.sol";
  7 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Contract module which provides a basic access control mechanism, where
 11 |     |  * there is an account (an owner) that can be granted exclusive access to
 12 |     |  * specific functions.
 13 |     |  *
 14 |     |  * By default, the owner account will be the one that deploys the contract. This
 15 |     |  * can later be changed with {transferOwnership}.
 16 |     |  *
 17 | *   |  * This module is used through inheritance. It will make available the modifier
 18 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 19 |     |  * the owner.
 20 |     |  */
 21 |     | abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
 22 |     |     address private _owner;
 23 |     | 
 24 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 25 |     | 
 26 |     |     /**
 27 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 28 |     |      */
 29 |     |     function __Ownable_init() internal onlyInitializing {
 30 |     |         __Ownable_init_unchained();
 31 |     |     }
 32 |     | 
 33 |     |     function __Ownable_init_unchained() internal onlyInitializing {
 34 |     |         _transferOwnership(_msgSender());
 35 |     |     }
 36 |     | 
 37 |     |     /**
 38 | *   |      * @dev Throws if called by any account other than the owner.
 39 |     |      */
 40 |     |     modifier onlyOwner() {
 41 | *   |         _checkOwner();
 42 |     |         _;
 43 |     |     }
 44 |     | 
 45 |     |     /**
 46 |     |      * @dev Returns the address of the current owner.
 47 |     |      */
 48 |     |     function owner() public view virtual returns (address) {
 49 |     |         return _owner;
 50 |     |     }
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Throws if the sender is not the owner.
 54 |     |      */
 55 | *   |     function _checkOwner() internal view virtual {
 56 | *   |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 57 |     |     }
 58 |     | 
 59 |     |     /**
 60 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 61 |     |      * `onlyOwner` functions. Can only be called by the current owner.
 62 |     |      *
 63 | *   |      * NOTE: Renouncing ownership will leave the contract without an owner,
 64 | *   |      * thereby disabling any functionality that is only available to the owner.
 65 |     |      */
 66 | *   |     function renounceOwnership() public virtual onlyOwner {
 67 |     |         _transferOwnership(address(0));
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 72 |     |      * Can only be called by the current owner.
 73 |     |      */
 74 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 75 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 76 |     |         _transferOwnership(newOwner);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 81 |     |      * Internal function without access restriction.
 82 |     |      */
 83 |     |     function _transferOwnership(address newOwner) internal virtual {
 84 |     |         address oldOwner = _owner;
 85 |     |         _owner = newOwner;
 86 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 87 |     |     }
 88 |     | 
 89 |     |     /**
 90 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 91 |     |      * variables without shifting down storage in the inheritance chain.
 92 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 93 |     |      */
 94 |     |     uint256[49] private __gap;
 95 |     | }
 96 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for
  8 |     |  * deploying minimal proxy contracts, also known as "clones".
  9 |     |  *
 10 |     |  * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies
 11 |     |  * > a minimal bytecode implementation that delegates all calls to a known, fixed address.
 12 |     |  *
 13 |     |  * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
 14 |     |  * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
 15 |     |  * deterministic method.
 16 |     |  *
 17 |     |  * _Available since v3.4._
 18 |     |  */
 19 |     | library ClonesUpgradeable {
 20 |     |     /**
 21 |     |      * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
 22 |     |      *
 23 |     |      * This function uses the create opcode, which should never revert.
 24 |     |      */
 25 |     |     function clone(address implementation) internal returns (address instance) {
 26 |     |         /// @solidity memory-safe-assembly
 27 |     |         assembly {
 28 |     |             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
 29 |     |             // of the `implementation` address with the bytecode before the address.
 30 |     |             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
 31 |     |             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
 32 |     |             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
 33 |     |             instance := create(0, 0x09, 0x37)
 34 |     |         }
 35 |     |         require(instance != address(0), "ERC1167: create failed");
 36 |     |     }
 37 |     | 
 38 |     |     /**
 39 |     |      * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
 40 |     |      *
 41 |     |      * This function uses the create2 opcode and a `salt` to deterministically deploy
 42 |     |      * the clone. Using the same `implementation` and `salt` multiple time will revert, since
 43 |     |      * the clones cannot be deployed twice at the same address.
 44 |     |      */
 45 |     |     function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
 46 |     |         /// @solidity memory-safe-assembly
 47 |     |         assembly {
 48 |     |             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
 49 |     |             // of the `implementation` address with the bytecode before the address.
 50 |     |             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
 51 |     |             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
 52 |     |             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
 53 |     |             instance := create2(0, 0x09, 0x37, salt)
 54 |     |         }
 55 |     |         require(instance != address(0), "ERC1167: create2 failed");
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
 60 |     |      */
 61 |     |     function predictDeterministicAddress(
 62 |     |         address implementation,
 63 |     |         bytes32 salt,
 64 |     |         address deployer
 65 |     |     ) internal pure returns (address predicted) {
 66 |     |         /// @solidity memory-safe-assembly
 67 |     |         assembly {
 68 |     |             let ptr := mload(0x40)
 69 |     |             mstore(add(ptr, 0x38), deployer)
 70 |     |             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
 71 |     |             mstore(add(ptr, 0x14), implementation)
 72 |     |             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
 73 |     |             mstore(add(ptr, 0x58), salt)
 74 |     |             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
 75 |     |             predicted := keccak256(add(ptr, 0x43), 0x55)
 76 |     |         }
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
 81 |     |      */
 82 |     |     function predictDeterministicAddress(
 83 |     |         address implementation,
 84 |     |         bytes32 salt
 85 |     |     ) internal view returns (address predicted) {
 86 |     |         return predictDeterministicAddress(implementation, salt, address(this));
 87 |     |     }
 88 |     | }
 89 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.2;
   5 |     | 
   6 |     | import "../../utils/AddressUpgradeable.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
  10 |     |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
  11 |     |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
  12 |     |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
  13 |     |  *
  14 |     |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
  15 |     |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
  16 |     |  * case an upgrade adds a module that needs to be initialized.
  17 |     |  *
  18 |     |  * For example:
  19 |     |  *
  20 |     |  * [.hljs-theme-light.nopadding]
  21 |     |  * ```solidity
  22 |     |  * contract MyToken is ERC20Upgradeable {
  23 |     |  *     function initialize() initializer public {
  24 |     |  *         __ERC20_init("MyToken", "MTK");
  25 |     |  *     }
  26 |     |  * }
  27 |     |  *
  28 |     |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
  29 |     |  *     function initializeV2() reinitializer(2) public {
  30 |     |  *         __ERC20Permit_init("MyToken");
  31 |     |  *     }
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
  36 |     |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
  37 |     |  *
  38 |     |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
  39 |     |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
  40 |     |  *
  41 |     |  * [CAUTION]
  42 |     |  * ====
  43 |     |  * Avoid leaving a contract uninitialized.
  44 |     |  *
  45 |     |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
  46 |     |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
  47 |     |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
  48 |     |  *
  49 |     |  * [.hljs-theme-light.nopadding]
  50 |     |  * ```
  51 |     |  * /// @custom:oz-upgrades-unsafe-allow constructor
  52 |     |  * constructor() {
  53 |     |  *     _disableInitializers();
  54 |     |  * }
  55 |     |  * ```
  56 |     |  * ====
  57 |     |  */
  58 |     | abstract contract Initializable {
  59 |     |     /**
  60 |     |      * @dev Indicates that the contract has been initialized.
  61 |     |      * @custom:oz-retyped-from bool
  62 |     |      */
  63 |     |     uint8 private _initialized;
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Indicates that the contract is in the process of being initialized.
  67 |     |      */
  68 |     |     bool private _initializing;
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Triggered when the contract has been initialized or reinitialized.
  72 |     |      */
  73 |     |     event Initialized(uint8 version);
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
  77 |     |      * `onlyInitializing` functions can be used to initialize parent contracts.
  78 |     |      *
  79 |     |      * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a
  80 |     |      * constructor.
  81 |     |      *
  82 |     |      * Emits an {Initialized} event.
  83 |     |      */
  84 |     |     modifier initializer() {
  85 |     |         bool isTopLevelCall = !_initializing;
  86 |     |         require(
  87 |     |             (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
  88 |     |             "Initializable: contract is already initialized"
  89 |     |         );
  90 |     |         _initialized = 1;
  91 |     |         if (isTopLevelCall) {
  92 |     |             _initializing = true;
  93 |     |         }
  94 |     |         _;
  95 |     |         if (isTopLevelCall) {
  96 |     |             _initializing = false;
  97 |     |             emit Initialized(1);
  98 |     |         }
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
 103 |     |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
 104 |     |      * used to initialize parent contracts.
 105 |     |      *
 106 |     |      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
 107 |     |      * are added through upgrades and that require initialization.
 108 |     |      *
 109 |     |      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
 110 |     |      * cannot be nested. If one is invoked in the context of another, execution will revert.
 111 |     |      *
 112 |     |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
 113 |     |      * a contract, executing them in the right order is up to the developer or operator.
 114 |     |      *
 115 |     |      * WARNING: setting the version to 255 will prevent any future reinitialization.
 116 |     |      *
 117 |     |      * Emits an {Initialized} event.
 118 |     |      */
 119 |     |     modifier reinitializer(uint8 version) {
 120 |     |         require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
 121 |     |         _initialized = version;
 122 |     |         _initializing = true;
 123 |     |         _;
 124 |     |         _initializing = false;
 125 |     |         emit Initialized(version);
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
 130 |     |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
 131 |     |      */
 132 |     |     modifier onlyInitializing() {
 133 |     |         require(_initializing, "Initializable: contract is not initializing");
 134 |     |         _;
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
 139 |     |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
 140 |     |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
 141 |     |      * through proxies.
 142 |     |      *
 143 |     |      * Emits an {Initialized} event the first time it is successfully executed.
 144 |     |      */
 145 |     |     function _disableInitializers() internal virtual {
 146 |     |         require(!_initializing, "Initializable: contract is initializing");
 147 |     |         if (_initialized != type(uint8).max) {
 148 |     |             _initialized = type(uint8).max;
 149 |     |             emit Initialized(type(uint8).max);
 150 |     |         }
 151 |     |     }
 152 |     | 
 153 |     |     /**
 154 |     |      * @dev Returns the highest version that has been initialized. See {reinitializer}.
 155 |     |      */
 156 |     |     function _getInitializedVersion() internal view returns (uint8) {
 157 |     |         return _initialized;
 158 |     |     }
 159 |     | 
 160 |     |     /**
 161 |     |      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
 162 |     |      */
 163 |     |     function _isInitializing() internal view returns (bool) {
 164 |     |         return _initializing;
 165 |     |     }
 166 |     | }
 167 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../utils/ContextUpgradeable.sol";
   7 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Contract module which allows children to implement an emergency stop
  11 |     |  * mechanism that can be triggered by an authorized account.
  12 |     |  *
  13 |     |  * This module is used through inheritance. It will make available the
  14 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  15 |     |  * the functions of your contract. Note that they will not be pausable by
  16 |     |  * simply including this module, only once the modifiers are put in place.
  17 |     |  */
  18 |     | abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {
  19 |     |     /**
  20 |     |      * @dev Emitted when the pause is triggered by `account`.
  21 |     |      */
  22 |     |     event Paused(address account);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Emitted when the pause is lifted by `account`.
  26 |     |      */
  27 |     |     event Unpaused(address account);
  28 |     | 
  29 |     |     bool private _paused;
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Initializes the contract in unpaused state.
  33 |     |      */
  34 |     |     function __Pausable_init() internal onlyInitializing {
  35 |     |         __Pausable_init_unchained();
  36 |     |     }
  37 |     | 
  38 |     |     function __Pausable_init_unchained() internal onlyInitializing {
  39 |     |         _paused = false;
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  44 |     |      *
  45 |     |      * Requirements:
  46 |     |      *
  47 |     |      * - The contract must not be paused.
  48 |     |      */
  49 |     |     modifier whenNotPaused() {
  50 |     |         _requireNotPaused();
  51 |     |         _;
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      *
  59 |     |      * - The contract must be paused.
  60 |     |      */
  61 |     |     modifier whenPaused() {
  62 |     |         _requirePaused();
  63 |     |         _;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  68 |     |      */
  69 |     |     function paused() public view virtual returns (bool) {
  70 |     |         return _paused;
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Throws if the contract is paused.
  75 |     |      */
  76 |     |     function _requireNotPaused() internal view virtual {
  77 |     |         require(!paused(), "Pausable: paused");
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Throws if the contract is not paused.
  82 |     |      */
  83 |     |     function _requirePaused() internal view virtual {
  84 |     |         require(paused(), "Pausable: not paused");
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Triggers stopped state.
  89 |     |      *
  90 |     |      * Requirements:
  91 |     |      *
  92 |     |      * - The contract must not be paused.
  93 |     |      */
  94 |     |     function _pause() internal virtual whenNotPaused {
  95 |     |         _paused = true;
  96 |     |         emit Paused(_msgSender());
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns to normal state.
 101 |     |      *
 102 |     |      * Requirements:
 103 |     |      *
 104 |     |      * - The contract must be paused.
 105 |     |      */
 106 |     |     function _unpause() internal virtual whenPaused {
 107 |     |         _paused = false;
 108 |     |         emit Unpaused(_msgSender());
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 113 |     |      * variables without shifting down storage in the inheritance chain.
 114 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 115 |     |      */
 116 |     |     uint256[49] private __gap;
 117 |     | }
 118 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  9 |     |  *
 10 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 11 |     |  * available, which can be applied to functions to make sure there are no nested
 12 |     |  * (reentrant) calls to them.
 13 |     |  *
 14 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 15 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 16 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 17 |     |  * points to them.
 18 |     |  *
 19 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 20 |     |  * to protect against it, check out our blog post
 21 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 22 |     |  */
 23 |     | abstract contract ReentrancyGuardUpgradeable is Initializable {
 24 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 25 |     |     // word because each write operation emits an extra SLOAD to first read the
 26 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 27 |     |     // back. This is the compiler's defense against contract upgrades and
 28 |     |     // pointer aliasing, and it cannot be disabled.
 29 |     | 
 30 |     |     // The values being non-zero value makes deployment a bit more expensive,
 31 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 32 |     |     // amount. Since refunds are capped to a percentage of the total
 33 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 34 |     |     // increase the likelihood of the full refund coming into effect.
 35 |     |     uint256 private constant _NOT_ENTERED = 1;
 36 |     |     uint256 private constant _ENTERED = 2;
 37 |     | 
 38 |     |     uint256 private _status;
 39 |     | 
 40 |     |     function __ReentrancyGuard_init() internal onlyInitializing {
 41 |     |         __ReentrancyGuard_init_unchained();
 42 |     |     }
 43 |     | 
 44 |     |     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
 45 |     |         _status = _NOT_ENTERED;
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 50 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 51 |     |      * function is not supported. It is possible to prevent this from happening
 52 |     |      * by making the `nonReentrant` function external, and making it call a
 53 |     |      * `private` function that does the actual work.
 54 |     |      */
 55 |     |     modifier nonReentrant() {
 56 |     |         _nonReentrantBefore();
 57 |     |         _;
 58 |     |         _nonReentrantAfter();
 59 |     |     }
 60 |     | 
 61 |     |     function _nonReentrantBefore() private {
 62 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 63 |     |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 64 |     | 
 65 |     |         // Any calls to nonReentrant after this point will fail
 66 |     |         _status = _ENTERED;
 67 |     |     }
 68 |     | 
 69 |     |     function _nonReentrantAfter() private {
 70 |     |         // By storing the original value once again, a refund is triggered (see
 71 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 72 |     |         _status = _NOT_ENTERED;
 73 |     |     }
 74 |     | 
 75 |     |     /**
 76 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 77 |     |      * `nonReentrant` function in the call stack.
 78 |     |      */
 79 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 80 |     |         return _status == _ENTERED;
 81 |     |     }
 82 |     | 
 83 |     |     /**
 84 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 85 |     |      * variables without shifting down storage in the inheritance chain.
 86 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 87 |     |      */
 88 |     |     uint256[49] private __gap;
 89 |     | }
 90 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20Upgradeable.sol";
   7 |     | import "./extensions/IERC20MetadataUpgradeable.sol";
   8 |     | import "../../utils/ContextUpgradeable.sol";
   9 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  17 |     |  *
  18 |     |  * TIP: For a detailed writeup see our guide
  19 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  20 |     |  * to implement supply mechanisms].
  21 |     |  *
  22 |     |  * The default value of {decimals} is 18. To change this, you should override
  23 |     |  * this function so it returns a different value.
  24 |     |  *
  25 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  26 |     |  * instead returning `false` on failure. This behavior is nonetheless
  27 |     |  * conventional and does not conflict with the expectations of ERC20
  28 |     |  * applications.
  29 |     |  *
  30 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  31 |     |  * This allows applications to reconstruct the allowance for all accounts just
  32 |     |  * by listening to said events. Other implementations of the EIP may not emit
  33 |     |  * these events, as it isn't required by the specification.
  34 |     |  *
  35 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  36 |     |  * functions have been added to mitigate the well-known issues around setting
  37 |     |  * allowances. See {IERC20-approve}.
  38 |     |  */
  39 |     | contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {
  40 |     |     mapping(address => uint256) private _balances;
  41 |     | 
  42 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  43 |     | 
  44 |     |     uint256 private _totalSupply;
  45 |     | 
  46 |     |     string private _name;
  47 |     |     string private _symbol;
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Sets the values for {name} and {symbol}.
  51 |     |      *
  52 |     |      * All two of these values are immutable: they can only be set once during
  53 |     |      * construction.
  54 |     |      */
  55 |     |     function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {
  56 |     |         __ERC20_init_unchained(name_, symbol_);
  57 |     |     }
  58 |     | 
  59 |     |     function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
  60 |     |         _name = name_;
  61 |     |         _symbol = symbol_;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev Returns the name of the token.
  66 |     |      */
  67 |     |     function name() public view virtual override returns (string memory) {
  68 |     |         return _name;
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  73 |     |      * name.
  74 |     |      */
  75 |     |     function symbol() public view virtual override returns (string memory) {
  76 |     |         return _symbol;
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Returns the number of decimals used to get its user representation.
  81 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  82 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  83 |     |      *
  84 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  85 |     |      * Ether and Wei. This is the default value returned by this function, unless
  86 |     |      * it's overridden.
  87 |     |      *
  88 |     |      * NOTE: This information is only used for _display_ purposes: it in
  89 |     |      * no way affects any of the arithmetic of the contract, including
  90 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  91 |     |      */
  92 |     |     function decimals() public view virtual override returns (uint8) {
  93 |     |         return 18;
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev See {IERC20-totalSupply}.
  98 |     |      */
  99 |     |     function totalSupply() public view virtual override returns (uint256) {
 100 |     |         return _totalSupply;
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev See {IERC20-balanceOf}.
 105 |     |      */
 106 |     |     function balanceOf(address account) public view virtual override returns (uint256) {
 107 |     |         return _balances[account];
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev See {IERC20-transfer}.
 112 |     |      *
 113 |     |      * Requirements:
 114 |     |      *
 115 |     |      * - `to` cannot be the zero address.
 116 |     |      * - the caller must have a balance of at least `amount`.
 117 |     |      */
 118 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 119 |     |         address owner = _msgSender();
 120 |     |         _transfer(owner, to, amount);
 121 |     |         return true;
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev See {IERC20-allowance}.
 126 |     |      */
 127 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 128 |     |         return _allowances[owner][spender];
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev See {IERC20-approve}.
 133 |     |      *
 134 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 135 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 136 |     |      *
 137 |     |      * Requirements:
 138 |     |      *
 139 |     |      * - `spender` cannot be the zero address.
 140 |     |      */
 141 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 142 |     |         address owner = _msgSender();
 143 |     |         _approve(owner, spender, amount);
 144 |     |         return true;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev See {IERC20-transferFrom}.
 149 |     |      *
 150 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 151 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 152 |     |      *
 153 |     |      * NOTE: Does not update the allowance if the current allowance
 154 |     |      * is the maximum `uint256`.
 155 |     |      *
 156 |     |      * Requirements:
 157 |     |      *
 158 |     |      * - `from` and `to` cannot be the zero address.
 159 |     |      * - `from` must have a balance of at least `amount`.
 160 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 161 |     |      * `amount`.
 162 |     |      */
 163 |     |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 164 |     |         address spender = _msgSender();
 165 |     |         _spendAllowance(from, spender, amount);
 166 |     |         _transfer(from, to, amount);
 167 |     |         return true;
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 172 |     |      *
 173 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 174 |     |      * problems described in {IERC20-approve}.
 175 |     |      *
 176 |     |      * Emits an {Approval} event indicating the updated allowance.
 177 |     |      *
 178 |     |      * Requirements:
 179 |     |      *
 180 |     |      * - `spender` cannot be the zero address.
 181 |     |      */
 182 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 183 |     |         address owner = _msgSender();
 184 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 185 |     |         return true;
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 190 |     |      *
 191 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 192 |     |      * problems described in {IERC20-approve}.
 193 |     |      *
 194 |     |      * Emits an {Approval} event indicating the updated allowance.
 195 |     |      *
 196 |     |      * Requirements:
 197 |     |      *
 198 |     |      * - `spender` cannot be the zero address.
 199 |     |      * - `spender` must have allowance for the caller of at least
 200 |     |      * `subtractedValue`.
 201 |     |      */
 202 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 203 |     |         address owner = _msgSender();
 204 |     |         uint256 currentAllowance = allowance(owner, spender);
 205 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 206 |     |         unchecked {
 207 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 208 |     |         }
 209 |     | 
 210 |     |         return true;
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 215 |     |      *
 216 |     |      * This internal function is equivalent to {transfer}, and can be used to
 217 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 218 |     |      *
 219 |     |      * Emits a {Transfer} event.
 220 |     |      *
 221 |     |      * Requirements:
 222 |     |      *
 223 |     |      * - `from` cannot be the zero address.
 224 |     |      * - `to` cannot be the zero address.
 225 |     |      * - `from` must have a balance of at least `amount`.
 226 |     |      */
 227 |     |     function _transfer(address from, address to, uint256 amount) internal virtual {
 228 |     |         require(from != address(0), "ERC20: transfer from the zero address");
 229 |     |         require(to != address(0), "ERC20: transfer to the zero address");
 230 |     | 
 231 |     |         _beforeTokenTransfer(from, to, amount);
 232 |     | 
 233 |     |         uint256 fromBalance = _balances[from];
 234 |     |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 235 |     |         unchecked {
 236 |     |             _balances[from] = fromBalance - amount;
 237 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 238 |     |             // decrementing then incrementing.
 239 |     |             _balances[to] += amount;
 240 |     |         }
 241 |     | 
 242 |     |         emit Transfer(from, to, amount);
 243 |     | 
 244 |     |         _afterTokenTransfer(from, to, amount);
 245 |     |     }
 246 |     | 
 247 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 248 |     |      * the total supply.
 249 |     |      *
 250 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 251 |     |      *
 252 |     |      * Requirements:
 253 |     |      *
 254 |     |      * - `account` cannot be the zero address.
 255 |     |      */
 256 |     |     function _mint(address account, uint256 amount) internal virtual {
 257 |     |         require(account != address(0), "ERC20: mint to the zero address");
 258 |     | 
 259 |     |         _beforeTokenTransfer(address(0), account, amount);
 260 |     | 
 261 |     |         _totalSupply += amount;
 262 |     |         unchecked {
 263 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 264 |     |             _balances[account] += amount;
 265 |     |         }
 266 |     |         emit Transfer(address(0), account, amount);
 267 |     | 
 268 |     |         _afterTokenTransfer(address(0), account, amount);
 269 |     |     }
 270 |     | 
 271 |     |     /**
 272 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 273 |     |      * total supply.
 274 |     |      *
 275 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 276 |     |      *
 277 |     |      * Requirements:
 278 |     |      *
 279 |     |      * - `account` cannot be the zero address.
 280 |     |      * - `account` must have at least `amount` tokens.
 281 |     |      */
 282 |     |     function _burn(address account, uint256 amount) internal virtual {
 283 |     |         require(account != address(0), "ERC20: burn from the zero address");
 284 |     | 
 285 |     |         _beforeTokenTransfer(account, address(0), amount);
 286 |     | 
 287 |     |         uint256 accountBalance = _balances[account];
 288 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 289 |     |         unchecked {
 290 |     |             _balances[account] = accountBalance - amount;
 291 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 292 |     |             _totalSupply -= amount;
 293 |     |         }
 294 |     | 
 295 |     |         emit Transfer(account, address(0), amount);
 296 |     | 
 297 |     |         _afterTokenTransfer(account, address(0), amount);
 298 |     |     }
 299 |     | 
 300 |     |     /**
 301 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 302 |     |      *
 303 |     |      * This internal function is equivalent to `approve`, and can be used to
 304 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 305 |     |      *
 306 |     |      * Emits an {Approval} event.
 307 |     |      *
 308 |     |      * Requirements:
 309 |     |      *
 310 |     |      * - `owner` cannot be the zero address.
 311 |     |      * - `spender` cannot be the zero address.
 312 |     |      */
 313 |     |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 314 |     |         require(owner != address(0), "ERC20: approve from the zero address");
 315 |     |         require(spender != address(0), "ERC20: approve to the zero address");
 316 |     | 
 317 |     |         _allowances[owner][spender] = amount;
 318 |     |         emit Approval(owner, spender, amount);
 319 |     |     }
 320 |     | 
 321 |     |     /**
 322 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 323 |     |      *
 324 |     |      * Does not update the allowance amount in case of infinite allowance.
 325 |     |      * Revert if not enough allowance is available.
 326 |     |      *
 327 |     |      * Might emit an {Approval} event.
 328 |     |      */
 329 |     |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 330 |     |         uint256 currentAllowance = allowance(owner, spender);
 331 |     |         if (currentAllowance != type(uint256).max) {
 332 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 333 |     |             unchecked {
 334 |     |                 _approve(owner, spender, currentAllowance - amount);
 335 |     |             }
 336 |     |         }
 337 |     |     }
 338 |     | 
 339 |     |     /**
 340 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 341 |     |      * minting and burning.
 342 |     |      *
 343 |     |      * Calling conditions:
 344 |     |      *
 345 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 346 |     |      * will be transferred to `to`.
 347 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 348 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 349 |     |      * - `from` and `to` are never both zero.
 350 |     |      *
 351 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 352 |     |      */
 353 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 354 |     | 
 355 |     |     /**
 356 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 357 |     |      * minting and burning.
 358 |     |      *
 359 |     |      * Calling conditions:
 360 |     |      *
 361 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 362 |     |      * has been transferred to `to`.
 363 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 364 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 365 |     |      * - `from` and `to` are never both zero.
 366 |     |      *
 367 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 368 |     |      */
 369 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 370 |     | 
 371 |     |     /**
 372 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 373 |     |      * variables without shifting down storage in the inheritance chain.
 374 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 375 |     |      */
 376 |     |     uint256[45] private __gap;
 377 |     | }
 378 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20Upgradeable {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20Upgradeable.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20MetadataUpgradeable is IERC20Upgradeable {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 | *   |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20PermitUpgradeable {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20Upgradeable.sol";
   7 |     | import "../extensions/IERC20PermitUpgradeable.sol";
   8 |     | import "../../../utils/AddressUpgradeable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20Upgradeable {
  20 |     |     using AddressUpgradeable for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 |     |     function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 |     |     function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
  35 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  80 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  81 |     |      */
  82 |     |     function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20PermitUpgradeable token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 |     |     function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 |     |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library AddressUpgradeable {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Provides information about the current execution context, including the
  9 |     |  * sender of the transaction and its data. While these are generally available
 10 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 11 |     |  * manner, since when dealing with meta-transactions the account sending and
 12 |     |  * paying for execution may not be the actual sender (as far as an application
 13 |     |  * is concerned).
 14 |     |  *
 15 |     |  * This contract is only required for intermediate, library-like contracts.
 16 |     |  */
 17 |     | abstract contract ContextUpgradeable is Initializable {
 18 |     |     function __Context_init() internal onlyInitializing {
 19 |     |     }
 20 |     | 
 21 |     |     function __Context_init_unchained() internal onlyInitializing {
 22 |     |     }
 23 |     |     function _msgSender() internal view virtual returns (address) {
 24 |     |         return msg.sender;
 25 |     |     }
 26 |     | 
 27 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 28 |     |         return msg.data;
 29 |     |     }
 30 |     | 
 31 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 32 |     |         return 0;
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 37 |     |      * variables without shifting down storage in the inheritance chain.
 38 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 39 |     |      */
 40 |     |     uint256[50] private __gap;
 41 |     | }
 42 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/access/Ownable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which provides a basic access control mechanism, where
  10 |     |  * there is an account (an owner) that can be granted exclusive access to
  11 |     |  * specific functions.
  12 |     |  *
  13 |     |  * The initial owner is set to the address provided by the deployer. This can
  14 |     |  * later be changed with {transferOwnership}.
  15 |     |  *
  16 |     |  * This module is used through inheritance. It will make available the modifier
  17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
  18 |     |  * the owner.
  19 |     |  */
  20 |     | abstract contract Ownable is Context {
  21 |     |     address private _owner;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev The caller account is not authorized to perform an operation.
  25 |     |      */
  26 |     |     error OwnableUnauthorizedAccount(address account);
  27 |     | 
  28 |     |     /**
  29 |     |      * @dev The owner is not a valid owner account. (eg. `address(0)`)
  30 |     |      */
  31 |     |     error OwnableInvalidOwner(address owner);
  32 |     | 
  33 | *   |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  34 |     | 
  35 |     |     /**
  36 | *   |      * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
  37 |     |      */
  38 |     |     constructor(address initialOwner) {
  39 |     |         if (initialOwner == address(0)) {
  40 |     |             revert OwnableInvalidOwner(address(0));
  41 |     |         }
  42 |     |         _transferOwnership(initialOwner);
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Throws if called by any account other than the owner.
  47 |     |      */
  48 |     |     modifier onlyOwner() {
  49 |     |         _checkOwner();
  50 |     |         _;
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Returns the address of the current owner.
  55 |     |      */
  56 |     |     function owner() public view virtual returns (address) {
  57 |     |         return _owner;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Throws if the sender is not the owner.
  62 |     |      */
  63 |     |     function _checkOwner() internal view virtual {
  64 |     |         if (owner() != _msgSender()) {
  65 |     |             revert OwnableUnauthorizedAccount(_msgSender());
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Leaves the contract without owner. It will not be possible to call
  71 | *   |      * `onlyOwner` functions. Can only be called by the current owner.
  72 |     |      *
  73 | *   |      * NOTE: Renouncing ownership will leave the contract without an owner,
  74 |     |      * thereby disabling any functionality that is only available to the owner.
  75 |     |      */
  76 |     |     function renounceOwnership() public virtual onlyOwner {
  77 |     |         _transferOwnership(address(0));
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  82 |     |      * Can only be called by the current owner.
  83 |     |      */
  84 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
  85 |     |         if (newOwner == address(0)) {
  86 | *   |             revert OwnableInvalidOwner(address(0));
  87 |     |         }
  88 | *   |         _transferOwnership(newOwner);
  89 |     |     }
  90 |     | 
  91 | *   |     /**
  92 | *   |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  93 |     |      * Internal function without access restriction.
  94 |     |      */
  95 |     |     function _transferOwnership(address newOwner) internal virtual {
  96 |     |         address oldOwner = _owner;
  97 |     |         _owner = newOwner;
  98 |     |         emit OwnershipTransferred(oldOwner, newOwner);
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 | *   |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 | *   |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 | *   |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 | *   |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 | *   |     /**
  39 | *   |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 | *   |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC1155 Errors
 111 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/ERC1967/ERC1967Utils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IBeacon} from "../beacon/IBeacon.sol";
   7 |     | import {Address} from "../../utils/Address.sol";
   8 |     | import {StorageSlot} from "../../utils/StorageSlot.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev This abstract contract provides getters and event emitting update functions for
  12 |     |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
  13 |     |  */
  14 |     | library ERC1967Utils {
  15 |     |     // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.
  16 |     |     // This will be fixed in Solidity 0.8.21. At that point we should remove these events.
  17 |     |     /**
  18 |     |      * @dev Emitted when the implementation is upgraded.
  19 |     |      */
  20 |     |     event Upgraded(address indexed implementation);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when the admin account has changed.
  24 |     |      */
  25 |     |     event AdminChanged(address previousAdmin, address newAdmin);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Emitted when the beacon is changed.
  29 |     |      */
  30 |     |     event BeaconUpgraded(address indexed beacon);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Storage slot with the address of the current implementation.
  34 |     |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.
  35 |     |      */
  36 |     |     // solhint-disable-next-line private-vars-leading-underscore
  37 |     |     bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev The `implementation` of the proxy is invalid.
  41 |     |      */
  42 |     |     error ERC1967InvalidImplementation(address implementation);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev The `admin` of the proxy is invalid.
  46 |     |      */
  47 |     |     error ERC1967InvalidAdmin(address admin);
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev The `beacon` of the proxy is invalid.
  51 |     |      */
  52 |     |     error ERC1967InvalidBeacon(address beacon);
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev An upgrade function sees `msg.value > 0` that may be lost.
  56 |     |      */
  57 |     |     error ERC1967NonPayable();
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the current implementation address.
  61 |     |      */
  62 |     |     function getImplementation() internal view returns (address) {
  63 |     |         return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Stores a new address in the EIP1967 implementation slot.
  68 |     |      */
  69 |     |     function _setImplementation(address newImplementation) private {
  70 |     |         if (newImplementation.code.length == 0) {
  71 |     |             revert ERC1967InvalidImplementation(newImplementation);
  72 |     |         }
  73 |     |         StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev Performs implementation upgrade with additional setup call if data is nonempty.
  78 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
  79 |     |      * to avoid stuck value in the contract.
  80 |     |      *
  81 |     |      * Emits an {IERC1967-Upgraded} event.
  82 |     |      */
  83 |     |     function upgradeToAndCall(address newImplementation, bytes memory data) internal {
  84 |     |         _setImplementation(newImplementation);
  85 |     |         emit Upgraded(newImplementation);
  86 |     | 
  87 |     |         if (data.length > 0) {
  88 |     |             Address.functionDelegateCall(newImplementation, data);
  89 |     |         } else {
  90 |     |             _checkNonPayable();
  91 |     |         }
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Storage slot with the admin of the contract.
  96 |     |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.
  97 |     |      */
  98 | *   |     // solhint-disable-next-line private-vars-leading-underscore
  99 | *   |     bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Returns the current admin.
 103 |     |      *
 104 | *   |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using
 105 | *   |      * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
 106 | *   |      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
 107 |     |      */
 108 |     |     function getAdmin() internal view returns (address) {
 109 |     |         return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev Stores a new address in the EIP1967 admin slot.
 114 |     |      */
 115 |     |     function _setAdmin(address newAdmin) private {
 116 |     |         if (newAdmin == address(0)) {
 117 |     |             revert ERC1967InvalidAdmin(address(0));
 118 |     |         }
 119 |     |         StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Changes the admin of the proxy.
 124 |     |      *
 125 |     |      * Emits an {IERC1967-AdminChanged} event.
 126 |     |      */
 127 |     |     function changeAdmin(address newAdmin) internal {
 128 |     |         emit AdminChanged(getAdmin(), newAdmin);
 129 |     |         _setAdmin(newAdmin);
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
 134 |     |      * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.
 135 |     |      */
 136 |     |     // solhint-disable-next-line private-vars-leading-underscore
 137 |     |     bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Returns the current beacon.
 141 |     |      */
 142 |     |     function getBeacon() internal view returns (address) {
 143 |     |         return StorageSlot.getAddressSlot(BEACON_SLOT).value;
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Stores a new beacon in the EIP1967 beacon slot.
 148 |     |      */
 149 |     |     function _setBeacon(address newBeacon) private {
 150 |     |         if (newBeacon.code.length == 0) {
 151 |     |             revert ERC1967InvalidBeacon(newBeacon);
 152 |     |         }
 153 |     | 
 154 |     |         StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;
 155 |     | 
 156 | *   |         address beaconImplementation = IBeacon(newBeacon).implementation();
 157 |     |         if (beaconImplementation.code.length == 0) {
 158 |     |             revert ERC1967InvalidImplementation(beaconImplementation);
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev Change the beacon and trigger a setup call if data is nonempty.
 164 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
 165 |     |      * to avoid stuck value in the contract.
 166 |     |      *
 167 |     |      * Emits an {IERC1967-BeaconUpgraded} event.
 168 |     |      *
 169 |     |      * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since
 170 |     |      * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for
 171 |     |      * efficiency.
 172 |     |      */
 173 |     |     function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {
 174 |     |         _setBeacon(newBeacon);
 175 |     |         emit BeaconUpgraded(newBeacon);
 176 |     | 
 177 |     |         if (data.length > 0) {
 178 |     |             Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
 179 |     |         } else {
 180 |     |             _checkNonPayable();
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract
 186 |     |      * if an upgrade doesn't perform an initialization call.
 187 |     |      */
 188 |     |     function _checkNonPayable() private {
 189 |     |         if (msg.value > 0) {
 190 |     |             revert ERC1967NonPayable();
 191 |     |         }
 192 |     |     }
 193 |     | }
 194 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
  8 |     |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
  9 |     |  * be specified by overriding the virtual {_implementation} function.
 10 |     |  *
 11 |     |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 12 |     |  * different contract through the {_delegate} function.
 13 |     |  *
 14 |     |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
 15 |     |  */
 16 |     | abstract contract Proxy {
 17 |     |     /**
 18 |     |      * @dev Delegates the current call to `implementation`.
 19 |     |      *
 20 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 21 |     |      */
 22 |     |     function _delegate(address implementation) internal virtual {
 23 |     |         assembly {
 24 | *   |             // Copy msg.data. We take full control of memory in this inline assembly
 25 | *   |             // block because it will not return to Solidity code. We overwrite the
 26 |     |             // Solidity scratch pad at memory position 0.
 27 | *   |             calldatacopy(0, 0, calldatasize())
 28 |     | 
 29 |     |             // Call the implementation.
 30 |     |             // out and outsize are 0 because we don't know the size yet.
 31 |     |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 32 |     | 
 33 |     |             // Copy the returned data.
 34 |     |             returndatacopy(0, 0, returndatasize())
 35 |     | 
 36 |     |             switch result
 37 |     |             // delegatecall returns 0 on error.
 38 |     |             case 0 {
 39 |     |                 revert(0, returndatasize())
 40 |     |             }
 41 |     |             default {
 42 |     |                 return(0, returndatasize())
 43 |     |             }
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev This is a virtual function that should be overridden so it returns the address to which the fallback
 49 |     |      * function and {_fallback} should delegate.
 50 |     |      */
 51 |     |     function _implementation() internal view virtual returns (address);
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Delegates the current call to the address returned by `_implementation()`.
 55 |     |      *
 56 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 57 |     |      */
 58 |     |     function _fallback() internal virtual {
 59 |     |         _delegate(_implementation());
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
 64 |     |      * function in the contract matches the call data.
 65 |     |      */
 66 |     |     fallback() external payable virtual {
 67 |     |         _fallback();
 68 |     |     }
 69 |     | }
 70 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/beacon/BeaconProxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/BeaconProxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IBeacon} from "./IBeacon.sol";
  7 |     | import {Proxy} from "../Proxy.sol";
  8 |     | import {ERC1967Utils} from "../ERC1967/ERC1967Utils.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.
 12 |     |  *
 13 |     |  * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an
 14 |     |  * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by
 15 |     |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] so that it can be accessed externally.
 16 |     |  *
 17 |     |  * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust
 18 |     |  * the beacon to not upgrade the implementation maliciously.
 19 |     |  *
 20 |     |  * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in
 21 |     |  * an inconsistent state where the beacon storage slot does not match the beacon address.
 22 |     |  */
 23 |     | contract BeaconProxy is Proxy {
 24 |     |     // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.
 25 |     |     address private immutable _beacon;
 26 |     | 
 27 |     |     /**
 28 |     |      * @dev Initializes the proxy with `beacon`.
 29 |     |      *
 30 |     |      * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This
 31 |     |      * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity
 32 |     |      * constructor.
 33 |     |      *
 34 |     |      * Requirements:
 35 |     |      *
 36 |     |      * - `beacon` must be a contract with the interface {IBeacon}.
 37 |     |      * - If `data` is empty, `msg.value` must be zero.
 38 |     |      */
 39 |     |     constructor(address beacon, bytes memory data) payable {
 40 |     |         ERC1967Utils.upgradeBeaconToAndCall(beacon, data);
 41 |     |         _beacon = beacon;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the current implementation address of the associated beacon.
 46 |     |      */
 47 |     |     function _implementation() internal view virtual override returns (address) {
 48 |     |         return IBeacon(_getBeacon()).implementation();
 49 |     |     }
 50 |     | 
 51 |     |     /**
 52 |     |      * @dev Returns the beacon.
 53 |     |      */
 54 |     |     function _getBeacon() internal view virtual returns (address) {
 55 |     |         return _beacon;
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/beacon/IBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
  8 |     |  */
  9 |     | interface IBeacon {
 10 |     |     /**
 11 |     |      * @dev Must return an address that can be used as a delegate call target.
 12 |     |      *
 13 |     |      * {UpgradeableBeacon} will check that this address is a contract.
 14 |     |      */
 15 |     |     function implementation() external view returns (address);
 16 |     | }
 17 | *   | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/beacon/UpgradeableBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/UpgradeableBeacon.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IBeacon} from "./IBeacon.sol";
  7 |     | import {Ownable} from "../../access/Ownable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their
 11 |     |  * implementation contract, which is where they will delegate all function calls.
 12 |     |  *
 13 |     |  * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.
 14 |     |  */
 15 |     | contract UpgradeableBeacon is IBeacon, Ownable {
 16 |     |     address private _implementation;
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev The `implementation` of the beacon is invalid.
 20 |     |      */
 21 |     |     error BeaconInvalidImplementation(address implementation);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Emitted when the implementation returned by the beacon is changed.
 25 |     |      */
 26 |     |     event Upgraded(address indexed implementation);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Sets the address of the initial implementation, and the initial owner who can upgrade the beacon.
 30 |     |      */
 31 |     |     constructor(address implementation_, address initialOwner) Ownable(initialOwner) {
 32 |     |         _setImplementation(implementation_);
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Returns the current implementation address.
 37 |     |      */
 38 |     |     function implementation() public view virtual returns (address) {
 39 |     |         return _implementation;
 40 |     |     }
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Upgrades the beacon to a new implementation.
 44 |     |      *
 45 |     |      * Emits an {Upgraded} event.
 46 |     |      *
 47 |     |      * Requirements:
 48 |     |      *
 49 |     |      * - msg.sender must be the owner of the contract.
 50 |     |      * - `newImplementation` must be a contract.
 51 |     |      */
 52 |     |     function upgradeTo(address newImplementation) public virtual onlyOwner {
 53 |     |         _setImplementation(newImplementation);
 54 |     |     }
 55 |     | 
 56 |     |     /**
 57 |     |      * @dev Sets the implementation contract address for this beacon
 58 |     |      *
 59 |     |      * Requirements:
 60 |     |      *
 61 |     |      * - `newImplementation` must be a contract.
 62 |     |      */
 63 |     |     function _setImplementation(address newImplementation) private {
 64 |     |         if (newImplementation.code.length == 0) {
 65 |     |             revert BeaconInvalidImplementation(newImplementation);
 66 |     |         }
 67 |     |         _implementation = newImplementation;
 68 |     |         emit Upgraded(newImplementation);
 69 |     |     }
 70 |     | }
 71 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  */
  34 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  35 |     |     mapping(address account => uint256) private _balances;
  36 |     | 
  37 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  38 |     | 
  39 |     |     uint256 private _totalSupply;
  40 |     | 
  41 |     |     string private _name;
  42 |     |     string private _symbol;
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Sets the values for {name} and {symbol}.
  46 |     |      *
  47 |     |      * All two of these values are immutable: they can only be set once during
  48 |     |      * construction.
  49 |     |      */
  50 |     |     constructor(string memory name_, string memory symbol_) {
  51 |     |         _name = name_;
  52 |     |         _symbol = symbol_;
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Returns the name of the token.
  57 |     |      */
  58 |     |     function name() public view virtual returns (string memory) {
  59 |     |         return _name;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  64 |     |      * name.
  65 |     |      */
  66 |     |     function symbol() public view virtual returns (string memory) {
  67 |     |         return _symbol;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the number of decimals used to get its user representation.
  72 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  73 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  74 |     |      *
  75 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  76 |     |      * Ether and Wei. This is the default value returned by this function, unless
  77 |     |      * it's overridden.
  78 |     |      *
  79 |     |      * NOTE: This information is only used for _display_ purposes: it in
  80 |     |      * no way affects any of the arithmetic of the contract, including
  81 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  82 |     |      */
  83 |     |     function decimals() public view virtual returns (uint8) {
  84 |     |         return 18;
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev See {IERC20-totalSupply}.
  89 |     |      */
  90 |     |     function totalSupply() public view virtual returns (uint256) {
  91 |     |         return _totalSupply;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev See {IERC20-balanceOf}.
  96 |     |      */
  97 |     |     function balanceOf(address account) public view virtual returns (uint256) {
  98 |     |         return _balances[account];
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev See {IERC20-transfer}.
 103 |     |      *
 104 |     |      * Requirements:
 105 |     |      *
 106 |     |      * - `to` cannot be the zero address.
 107 |     |      * - the caller must have a balance of at least `value`.
 108 |     |      */
 109 |     |     function transfer(address to, uint256 value) public virtual returns (bool) {
 110 |     |         address owner = _msgSender();
 111 |     |         _transfer(owner, to, value);
 112 |     |         return true;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev See {IERC20-allowance}.
 117 |     |      */
 118 |     |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 119 |     |         return _allowances[owner][spender];
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev See {IERC20-approve}.
 124 |     |      *
 125 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 126 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 127 |     |      *
 128 |     |      * Requirements:
 129 |     |      *
 130 |     |      * - `spender` cannot be the zero address.
 131 |     |      */
 132 |     |     function approve(address spender, uint256 value) public virtual returns (bool) {
 133 |     |         address owner = _msgSender();
 134 |     |         _approve(owner, spender, value);
 135 |     |         return true;
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev See {IERC20-transferFrom}.
 140 |     |      *
 141 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 142 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 143 |     |      *
 144 |     |      * NOTE: Does not update the allowance if the current allowance
 145 |     |      * is the maximum `uint256`.
 146 |     |      *
 147 |     |      * Requirements:
 148 |     |      *
 149 |     |      * - `from` and `to` cannot be the zero address.
 150 |     |      * - `from` must have a balance of at least `value`.
 151 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 152 |     |      * `value`.
 153 |     |      */
 154 |     |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 155 |     |         address spender = _msgSender();
 156 |     |         _spendAllowance(from, spender, value);
 157 |     |         _transfer(from, to, value);
 158 |     |         return true;
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 163 |     |      *
 164 |     |      * This internal function is equivalent to {transfer}, and can be used to
 165 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 166 |     |      *
 167 |     |      * Emits a {Transfer} event.
 168 |     |      *
 169 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 170 |     |      */
 171 |     |     function _transfer(address from, address to, uint256 value) internal {
 172 |     |         if (from == address(0)) {
 173 |     |             revert ERC20InvalidSender(address(0));
 174 |     |         }
 175 |     |         if (to == address(0)) {
 176 |     |             revert ERC20InvalidReceiver(address(0));
 177 |     |         }
 178 |     |         _update(from, to, value);
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 183 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 184 |     |      * this function.
 185 |     |      *
 186 |     |      * Emits a {Transfer} event.
 187 |     |      */
 188 |     |     function _update(address from, address to, uint256 value) internal virtual {
 189 |     |         if (from == address(0)) {
 190 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 191 |     |             _totalSupply += value;
 192 |     |         } else {
 193 |     |             uint256 fromBalance = _balances[from];
 194 |     |             if (fromBalance < value) {
 195 |     |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 196 |     |             }
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 199 |     |                 _balances[from] = fromBalance - value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 |     |         if (to == address(0)) {
 204 |     |             unchecked {
 205 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 206 |     |                 _totalSupply -= value;
 207 |     |             }
 208 |     |         } else {
 209 |     |             unchecked {
 210 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 211 |     |                 _balances[to] += value;
 212 |     |             }
 213 |     |         }
 214 |     | 
 215 |     |         emit Transfer(from, to, value);
 216 |     |     }
 217 |     | 
 218 |     |     /**
 219 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 220 |     |      * Relies on the `_update` mechanism
 221 |     |      *
 222 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 223 |     |      *
 224 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 225 |     |      */
 226 |     |     function _mint(address account, uint256 value) internal {
 227 |     |         if (account == address(0)) {
 228 |     |             revert ERC20InvalidReceiver(address(0));
 229 |     |         }
 230 |     |         _update(address(0), account, value);
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 235 |     |      * Relies on the `_update` mechanism.
 236 |     |      *
 237 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 238 |     |      *
 239 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 240 |     |      */
 241 |     |     function _burn(address account, uint256 value) internal {
 242 |     |         if (account == address(0)) {
 243 |     |             revert ERC20InvalidSender(address(0));
 244 |     |         }
 245 |     |         _update(account, address(0), value);
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.
 250 |     |      *
 251 |     |      * This internal function is equivalent to `approve`, and can be used to
 252 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 253 |     |      *
 254 |     |      * Emits an {Approval} event.
 255 |     |      *
 256 |     |      * Requirements:
 257 |     |      *
 258 |     |      * - `owner` cannot be the zero address.
 259 |     |      * - `spender` cannot be the zero address.
 260 |     |      *
 261 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 262 |     |      */
 263 |     |     function _approve(address owner, address spender, uint256 value) internal {
 264 |     |         _approve(owner, spender, value, true);
 265 |     |     }
 266 |     | 
 267 |     |     /**
 268 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 269 |     |      *
 270 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 271 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 272 |     |      * `Approval` event during `transferFrom` operations.
 273 |     |      *
 274 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 275 |     |      * true using the following override:
 276 |     |      * ```
 277 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 278 |     |      *     super._approve(owner, spender, value, true);
 279 |     |      * }
 280 |     |      * ```
 281 |     |      *
 282 |     |      * Requirements are the same as {_approve}.
 283 |     |      */
 284 |     |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 285 |     |         if (owner == address(0)) {
 286 |     |             revert ERC20InvalidApprover(address(0));
 287 |     |         }
 288 |     |         if (spender == address(0)) {
 289 |     |             revert ERC20InvalidSpender(address(0));
 290 |     |         }
 291 |     |         _allowances[owner][spender] = value;
 292 |     |         if (emitEvent) {
 293 |     |             emit Approval(owner, spender, value);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `value`.
 299 |     |      *
 300 |     |      * Does not update the allowance value in case of infinite allowance.
 301 |     |      * Revert if not enough allowance is available.
 302 |     |      *
 303 |     |      * Does not emit an {Approval} event.
 304 |     |      */
 305 |     |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 306 |     |         uint256 currentAllowance = allowance(owner, spender);
 307 |     |         if (currentAllowance != type(uint256).max) {
 308 |     |             if (currentAllowance < value) {
 309 |     |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 310 |     |             }
 311 |     |             unchecked {
 312 |     |                 _approve(owner, spender, currentAllowance - value, false);
 313 |     |             }
 314 |     |         }
 315 |     |     }
 316 |     | }
 317 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 | *   | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "../IERC20.sol";
   7 |     | import {IERC20Permit} from "../extensions/IERC20Permit.sol";
   8 |     | import {Address} from "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev An operation with an ERC20 token failed.
  24 |     |      */
  25 |     |     error SafeERC20FailedOperation(address token);
  26 |     | 
  27 |     |     /**
  28 | *   |      * @dev Indicates a failed `decreaseAllowance` request.
  29 |     |      */
  30 |     |     error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  34 |     |      * non-reverting calls are assumed to be successful.
  35 |     |      */
  36 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  37 |     |         _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  42 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  43 |     |      */
  44 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  45 |     |         _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  50 |     |      * non-reverting calls are assumed to be successful.
  51 |     |      */
  52 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  53 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  54 |     |         forceApprove(token, spender, oldAllowance + value);
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
  59 |     |      * value, non-reverting calls are assumed to be successful.
  60 |     |      */
  61 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
  62 |     |         unchecked {
  63 |     |             uint256 currentAllowance = token.allowance(address(this), spender);
  64 |     |             if (currentAllowance < requestedDecrease) {
  65 |     |                 revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
  66 |     |             }
  67 |     |             forceApprove(token, spender, currentAllowance - requestedDecrease);
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  73 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  74 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  75 |     |      */
  76 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  77 |     |         bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
  78 |     | 
  79 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  80 |     |             _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
  81 |     |             _callOptionalReturn(token, approvalCall);
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
  87 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
  88 |     |      * @param token The token targeted by the call.
  89 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
  90 |     |      */
  91 |     |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
  92 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
  93 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
  94 |     |         // the target address contains contract code and also asserts for success in the low-level call.
  95 |     | 
  96 |     |         bytes memory returndata = address(token).functionCall(data);
  97 |     |         if (returndata.length != 0 && !abi.decode(returndata, (bool))) {
  98 |     |             revert SafeERC20FailedOperation(address(token));
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 104 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 105 |     |      * @param token The token targeted by the call.
 106 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 107 |     |      *
 108 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 109 |     |      */
 110 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 111 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 112 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 113 |     |         // and not revert is the subcall reverts.
 114 |     | 
 115 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 116 |     |         return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;
 117 |     |     }
 118 |     | }
 119 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC721/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC165} from "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC721 compliant contract.
  10 |     |  */
  11 |     | interface IERC721 is IERC165 {
  12 |     |     /**
  13 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
  14 |     |      */
  15 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
  19 |     |      */
  20 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
  24 |     |      */
  25 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Returns the number of tokens in ``owner``'s account.
  29 |     |      */
  30 |     |     function balanceOf(address owner) external view returns (uint256 balance);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Returns the owner of the `tokenId` token.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - `tokenId` must exist.
  38 |     |      */
  39 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      *
  46 |     |      * - `from` cannot be the zero address.
  47 |     |      * - `to` cannot be the zero address.
  48 |     |      * - `tokenId` token must exist and be owned by `from`.
  49 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  50 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
  51 |     |      *   a safe transfer.
  52 |     |      *
  53 |     |      * Emits a {Transfer} event.
  54 |     |      */
  55 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
  59 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
  60 |     |      *
  61 |     |      * Requirements:
  62 |     |      *
  63 |     |      * - `from` cannot be the zero address.
  64 |     |      * - `to` cannot be the zero address.
  65 |     |      * - `tokenId` token must exist and be owned by `from`.
  66 |     |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or
  67 |     |      *   {setApprovalForAll}.
  68 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
  69 |     |      *   a safe transfer.
  70 |     |      *
  71 |     |      * Emits a {Transfer} event.
  72 |     |      */
  73 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) external;
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Transfers `tokenId` token from `from` to `to`.
  77 |     |      *
  78 |     |      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
  79 |     |      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
  80 |     |      * understand this adds an external call which potentially creates a reentrancy vulnerability.
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `from` cannot be the zero address.
  85 |     |      * - `to` cannot be the zero address.
  86 |     |      * - `tokenId` token must be owned by `from`.
  87 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  88 |     |      *
  89 |     |      * Emits a {Transfer} event.
  90 |     |      */
  91 |     |     function transferFrom(address from, address to, uint256 tokenId) external;
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
  95 |     |      * The approval is cleared when the token is transferred.
  96 |     |      *
  97 |     |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
  98 |     |      *
  99 |     |      * Requirements:
 100 |     |      *
 101 |     |      * - The caller must own the token or be an approved operator.
 102 |     |      * - `tokenId` must exist.
 103 |     |      *
 104 |     |      * Emits an {Approval} event.
 105 |     |      */
 106 |     |     function approve(address to, uint256 tokenId) external;
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 110 |     |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
 111 |     |      *
 112 |     |      * Requirements:
 113 |     |      *
 114 |     |      * - The `operator` cannot be the address zero.
 115 |     |      *
 116 |     |      * Emits an {ApprovalForAll} event.
 117 |     |      */
 118 |     |     function setApprovalForAll(address operator, bool approved) external;
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Returns the account approved for `tokenId` token.
 122 |     |      *
 123 |     |      * Requirements:
 124 |     |      *
 125 |     |      * - `tokenId` must exist.
 126 |     |      */
 127 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 131 |     |      *
 132 |     |      * See {setApprovalForAll}
 133 |     |      */
 134 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 135 |     | }
 136 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
  12 |     |      */
  13 |     |     error AddressInsufficientBalance(address account);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev There's no code at `target` (it is not a contract).
  17 |     |      */
  18 |     |     error AddressEmptyCode(address target);
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev A call to an address target failed. The target may have reverted.
  22 |     |      */
  23 |     |     error FailedInnerCall();
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  27 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  28 |     |      *
  29 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  30 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  31 |     |      * imposed by `transfer`, making them unable to receive funds via
  32 |     |      * `transfer`. {sendValue} removes this limitation.
  33 |     |      *
  34 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  35 |     |      *
  36 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  37 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  38 |     |      * {ReentrancyGuard} or the
  39 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  40 |     |      */
  41 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  42 |     |         if (address(this).balance < amount) {
  43 |     |             revert AddressInsufficientBalance(address(this));
  44 |     |         }
  45 |     | 
  46 |     |         (bool success, ) = recipient.call{value: amount}("");
  47 |     |         if (!success) {
  48 |     |             revert FailedInnerCall();
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  54 |     |      * plain `call` is an unsafe replacement for a function call: use this
  55 |     |      * function instead.
  56 |     |      *
  57 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  58 |     |      * up by this function (like regular Solidity function calls). However, if
  59 |     |      * the call reverted with no returned reason, this function reverts with a
  60 |     |      * {FailedInnerCall} error.
  61 |     |      *
  62 |     |      * Returns the raw returned data. To convert to the expected return value,
  63 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  64 |     |      *
  65 |     |      * Requirements:
  66 |     |      *
  67 |     |      * - `target` must be a contract.
  68 |     |      * - calling `target` with `data` must not revert.
  69 |     |      */
  70 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  71 |     |         return functionCallWithValue(target, data, 0);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  76 |     |      * but also transferring `value` wei to `target`.
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - the calling contract must have an ETH balance of at least `value`.
  81 |     |      * - the called Solidity function must be `payable`.
  82 |     |      */
  83 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  84 |     |         if (address(this).balance < value) {
  85 |     |             revert AddressInsufficientBalance(address(this));
  86 |     |         }
  87 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  88 |     |         return verifyCallResultFromTarget(target, success, returndata);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  93 |     |      * but performing a static call.
  94 |     |      */
  95 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  96 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  97 |     |         return verifyCallResultFromTarget(target, success, returndata);
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 102 |     |      * but performing a delegate call.
 103 |     |      */
 104 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 105 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 106 |     |         return verifyCallResultFromTarget(target, success, returndata);
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 111 |     |      * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
 112 |     |      * unsuccessful call.
 113 |     |      */
 114 |     |     function verifyCallResultFromTarget(
 115 |     |         address target,
 116 |     |         bool success,
 117 |     |         bytes memory returndata
 118 |     |     ) internal view returns (bytes memory) {
 119 |     |         if (!success) {
 120 |     |             _revert(returndata);
 121 |     |         } else {
 122 |     |             // only check if target is a contract if the call was successful and the return data is empty
 123 |     |             // otherwise we already know that it was a contract
 124 |     |             if (returndata.length == 0 && target.code.length == 0) {
 125 |     |                 revert AddressEmptyCode(target);
 126 |     |             }
 127 |     |             return returndata;
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 133 |     |      * revert reason or with a default {FailedInnerCall} error.
 134 |     |      */
 135 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 136 |     |         if (!success) {
 137 |     |             _revert(returndata);
 138 |     |         } else {
 139 |     |             return returndata;
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
 145 |     |      */
 146 |     |     function _revert(bytes memory returndata) private pure {
 147 |     |         // Look for revert reason and bubble it up if present
 148 |     |         if (returndata.length > 0) {
 149 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 150 |     |             /// @solidity memory-safe-assembly
 151 |     |             assembly {
 152 |     |                 let returndata_size := mload(returndata)
 153 |     |                 revert(add(32, returndata), returndata_size)
 154 |     |             }
 155 |     |         } else {
 156 |     |             revert FailedInnerCall();
 157 |     |         }
 158 |     |     }
 159 |     | }
 160 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  19 |     |  *
  20 |     |  *     function _getImplementation() internal view returns (address) {
  21 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  22 |     |  *     }
  23 |     |  *
  24 |     |  *     function _setImplementation(address newImplementation) internal {
  25 |     |  *         require(newImplementation.code.length > 0);
  26 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  27 |     |  *     }
  28 |     |  * }
  29 |     |  * ```
  30 |     |  */
  31 |     | library StorageSlot {
  32 |     |     struct AddressSlot {
  33 |     |         address value;
  34 |     |     }
  35 |     | 
  36 |     |     struct BooleanSlot {
  37 |     |         bool value;
  38 |     |     }
  39 |     | 
  40 |     |     struct Bytes32Slot {
  41 |     |         bytes32 value;
  42 |     |     }
  43 |     | 
  44 |     |     struct Uint256Slot {
  45 |     |         uint256 value;
  46 |     |     }
  47 |     | 
  48 |     |     struct StringSlot {
  49 |     |         string value;
  50 |     |     }
  51 |     | 
  52 |     |     struct BytesSlot {
  53 |     |         bytes value;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  58 |     |      */
  59 |     |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  60 |     |         /// @solidity memory-safe-assembly
  61 |     |         assembly {
  62 |     |             r.slot := slot
  63 |     |         }
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
  68 |     |      */
  69 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  70 |     |         /// @solidity memory-safe-assembly
  71 |     |         assembly {
  72 |     |             r.slot := slot
  73 |     |         }
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
  78 |     |      */
  79 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  80 |     |         /// @solidity memory-safe-assembly
  81 |     |         assembly {
  82 |     |             r.slot := slot
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
  88 |     |      */
  89 |     |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  90 |     |         /// @solidity memory-safe-assembly
  91 |     |         assembly {
  92 |     |             r.slot := slot
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Returns an `StringSlot` with member `value` located at `slot`.
  98 |     |      */
  99 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 100 |     |         /// @solidity memory-safe-assembly
 101 |     |         assembly {
 102 |     |             r.slot := slot
 103 |     |         }
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 108 |     |      */
 109 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 110 |     |         /// @solidity memory-safe-assembly
 111 |     |         assembly {
 112 |     |             r.slot := store.slot
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev Returns an `BytesSlot` with member `value` located at `slot`.
 118 |     |      */
 119 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 120 |     |         /// @solidity memory-safe-assembly
 121 |     |         assembly {
 122 |     |             r.slot := slot
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 128 |     |      */
 129 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 130 |     |         /// @solidity memory-safe-assembly
 131 |     |         assembly {
 132 |     |             r.slot := store.slot
 133 |     |         }
 134 |     |     }
 135 |     | }
 136 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/Script.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity >=0.6.0 <0.9.0;
  3 |     | 
  4 |     | import "./Vm.sol";
  5 |     | import "./console.sol";
  6 |     | import "./console2.sol";
  7 |     | 
  8 |     | abstract contract Script {
  9 |     |     address constant private VM_ADDRESS =
 10 |     |         address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));
 11 |     | 
 12 |     |     Vm public constant vm = Vm(VM_ADDRESS);
 13 |     | }
 14 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/Test.sol
   1 |     | // SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | import "./Script.sol";
   5 |     | import "ds-test/test.sol";
   6 |     | 
   7 |     | // Wrappers around Cheatcodes to avoid footguns
   8 |     | abstract contract Test is DSTest, Script {
   9 |     |     using stdStorage for StdStorage;
  10 |     | 
  11 |     |     uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
  12 |     | 
  13 |     |     event WARNING_Deprecated(string msg);
  14 |     | 
  15 |     |     StdStorage internal stdstore;
  16 |     | 
  17 |     |     /*//////////////////////////////////////////////////////////////////////////
  18 |     |                                     STD-CHEATS
  19 |     |     //////////////////////////////////////////////////////////////////////////*/
  20 |     | 
  21 |     |     // Skip forward or rewind time by the specified number of seconds
  22 |     |     function skip(uint256 time) public {
  23 |     |         vm.warp(block.timestamp + time);
  24 |     |     }
  25 |     | 
  26 |     |     function rewind(uint256 time) public {
  27 |     |         vm.warp(block.timestamp - time);
  28 |     |     }
  29 |     | 
  30 |     |     // Setup a prank from an address that has some ether
  31 |     |     function hoax(address who) public {
  32 |     |         vm.deal(who, 1 << 128);
  33 |     |         vm.prank(who);
  34 |     |     }
  35 |     | 
  36 |     |     function hoax(address who, uint256 give) public {
  37 |     |         vm.deal(who, give);
  38 |     |         vm.prank(who);
  39 |     |     }
  40 |     | 
  41 |     |     function hoax(address who, address origin) public {
  42 |     |         vm.deal(who, 1 << 128);
  43 |     |         vm.prank(who, origin);
  44 |     |     }
  45 |     | 
  46 |     |     function hoax(address who, address origin, uint256 give) public {
  47 |     |         vm.deal(who, give);
  48 |     |         vm.prank(who, origin);
  49 |     |     }
  50 |     | 
  51 |     |     // Start perpetual prank from an address that has some ether
  52 |     |     function startHoax(address who) public {
  53 |     |         vm.deal(who, 1 << 128);
  54 |     |         vm.startPrank(who);
  55 |     |     }
  56 |     | 
  57 |     |     function startHoax(address who, uint256 give) public {
  58 |     |         vm.deal(who, give);
  59 |     |         vm.startPrank(who);
  60 |     |     }
  61 |     | 
  62 |     |     // Start perpetual prank from an address that has some ether
  63 |     |     // tx.origin is set to the origin parameter
  64 |     |     function startHoax(address who, address origin) public {
  65 |     |         vm.deal(who, 1 << 128);
  66 |     |         vm.startPrank(who, origin);
  67 |     |     }
  68 |     | 
  69 |     |     function startHoax(address who, address origin, uint256 give) public {
  70 |     |         vm.deal(who, give);
  71 |     |         vm.startPrank(who, origin);
  72 |     |     }
  73 |     | 
  74 |     |     function changePrank(address who) internal {
  75 |     |         vm.stopPrank();
  76 |     |         vm.startPrank(who);
  77 |     |     }
  78 |     | 
  79 |     |     // DEPRECATED: Use `deal` instead
  80 |     |     function tip(address token, address to, uint256 give) public {
  81 |     |         emit WARNING_Deprecated("The `tip` stdcheat has been deprecated. Use `deal` instead.");
  82 |     |         stdstore
  83 |     |             .target(token)
  84 |     |             .sig(0x70a08231)
  85 |     |             .with_key(to)
  86 |     |             .checked_write(give);
  87 |     |     }
  88 |     | 
  89 |     |     // The same as Hevm's `deal`
  90 |     |     // Use the alternative signature for ERC20 tokens
  91 |     |     function deal(address to, uint256 give) public {
  92 |     |         vm.deal(to, give);
  93 |     |     }
  94 |     | 
  95 |     |     // Set the balance of an account for any ERC20 token
  96 |     |     // Use the alternative signature to update `totalSupply`
  97 |     |     function deal(address token, address to, uint256 give) public {
  98 |     |         deal(token, to, give, false);
  99 |     |     }
 100 |     | 
 101 |     |     function deal(address token, address to, uint256 give, bool adjust) public {
 102 |     |         // get current balance
 103 |     |         (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));
 104 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 105 |     | 
 106 |     |         // update balance
 107 |     |         stdstore
 108 |     |             .target(token)
 109 |     |             .sig(0x70a08231)
 110 |     |             .with_key(to)
 111 |     |             .checked_write(give);
 112 |     | 
 113 |     |         // update total supply
 114 |     |         if(adjust){
 115 |     |             (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));
 116 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 117 |     |             if(give < prevBal) {
 118 |     |                 totSup -= (prevBal - give);
 119 |     |             } else {
 120 |     |                 totSup += (give - prevBal);
 121 |     |             }
 122 |     |             stdstore
 123 |     |                 .target(token)
 124 |     |                 .sig(0x18160ddd)
 125 |     |                 .checked_write(totSup);
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     function bound(uint256 x, uint256 min, uint256 max) public returns (uint256 result) {
 130 |     |         require(min <= max, "Test bound(uint256,uint256,uint256): Max is less than min.");
 131 |     | 
 132 |     |         uint256 size = max - min;
 133 |     | 
 134 |     |         if (size == 0)
 135 |     |         {
 136 |     |             result = min;
 137 |     |         }
 138 |     |         else if (size == UINT256_MAX)
 139 |     |         {
 140 |     |             result = x;
 141 |     |         }
 142 |     |         else
 143 |     |         {
 144 |     |             ++size; // make `max` inclusive
 145 |     |             uint256 mod = x % size;
 146 |     |             result = min + mod;
 147 |     |         }
 148 |     | 
 149 |     |         emit log_named_uint("Bound Result", result);
 150 |     |     }
 151 |     | 
 152 |     |     // Deploy a contract by fetching the contract bytecode from
 153 |     |     // the artifacts directory
 154 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 155 |     |     function deployCode(string memory what, bytes memory args)
 156 |     |         public
 157 |     |         returns (address addr)
 158 |     |     {
 159 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 160 |     |         /// @solidity memory-safe-assembly
 161 |     |         assembly {
 162 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 163 |     |         }
 164 |     | 
 165 |     |         require(
 166 |     |             addr != address(0),
 167 |     |             "Test deployCode(string,bytes): Deployment failed."
 168 |     |         );
 169 |     |     }
 170 |     | 
 171 |     |     function deployCode(string memory what)
 172 |     |         public
 173 |     |         returns (address addr)
 174 |     |     {
 175 |     |         bytes memory bytecode = vm.getCode(what);
 176 |     |         /// @solidity memory-safe-assembly
 177 |     |         assembly {
 178 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 179 |     |         }
 180 |     | 
 181 |     |         require(
 182 |     |             addr != address(0),
 183 |     |             "Test deployCode(string): Deployment failed."
 184 |     |         );
 185 |     |     }
 186 |     | 
 187 |     |     /*//////////////////////////////////////////////////////////////////////////
 188 |     |                                     STD-ASSERTIONS
 189 |     |     //////////////////////////////////////////////////////////////////////////*/
 190 |     | 
 191 |     |     function fail(string memory err) internal virtual {
 192 |     |         emit log_named_string("Error", err);
 193 |     |         fail();
 194 |     |     }
 195 |     | 
 196 |     |     function assertFalse(bool data) internal virtual {
 197 |     |         assertTrue(!data);
 198 |     |     }
 199 |     | 
 200 |     |     function assertFalse(bool data, string memory err) internal virtual {
 201 |     |         assertTrue(!data, err);
 202 |     |     }
 203 |     | 
 204 |     |     function assertEq(bool a, bool b) internal {
 205 |     |         if (a != b) {
 206 |     |             emit log                ("Error: a == b not satisfied [bool]");
 207 |     |             emit log_named_string   ("  Expected", b ? "true" : "false");
 208 |     |             emit log_named_string   ("    Actual", a ? "true" : "false");
 209 |     |             fail();
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     function assertEq(bool a, bool b, string memory err) internal {
 214 |     |         if (a != b) {
 215 |     |             emit log_named_string("Error", err);
 216 |     |             assertEq(a, b);
 217 |     |         }
 218 |     |     }
 219 |     | 
 220 |     |     function assertEq(bytes memory a, bytes memory b) internal {
 221 |     |         assertEq0(a, b);
 222 |     |     }
 223 |     | 
 224 |     |     function assertEq(bytes memory a, bytes memory b, string memory err) internal {
 225 |     |         assertEq0(a, b, err);
 226 |     |     }
 227 |     | 
 228 |     |     function assertApproxEqAbs(
 229 |     |         uint256 a,
 230 |     |         uint256 b,
 231 |     |         uint256 maxDelta
 232 |     |     ) internal virtual {
 233 |     |         uint256 delta = stdMath.delta(a, b);
 234 |     | 
 235 |     |         if (delta > maxDelta) {
 236 |     |             emit log            ("Error: a ~= b not satisfied [uint]");
 237 |     |             emit log_named_uint ("  Expected", b);
 238 |     |             emit log_named_uint ("    Actual", a);
 239 |     |             emit log_named_uint (" Max Delta", maxDelta);
 240 |     |             emit log_named_uint ("     Delta", delta);
 241 |     |             fail();
 242 |     |         }
 243 |     |     }
 244 |     | 
 245 |     |     function assertApproxEqAbs(
 246 |     |         uint256 a,
 247 |     |         uint256 b,
 248 |     |         uint256 maxDelta,
 249 |     |         string memory err
 250 |     |     ) internal virtual {
 251 |     |         uint256 delta = stdMath.delta(a, b);
 252 |     | 
 253 |     |         if (delta > maxDelta) {
 254 |     |             emit log_named_string   ("Error", err);
 255 |     |             assertApproxEqAbs(a, b, maxDelta);
 256 |     |         }
 257 |     |     }
 258 |     | 
 259 |     |     function assertApproxEqAbs(
 260 |     |         int256 a,
 261 |     |         int256 b,
 262 |     |         uint256 maxDelta
 263 |     |     ) internal virtual {
 264 |     |         uint256 delta = stdMath.delta(a, b);
 265 |     | 
 266 |     |         if (delta > maxDelta) {
 267 |     |             emit log            ("Error: a ~= b not satisfied [int]");
 268 |     |             emit log_named_int  ("  Expected", b);
 269 |     |             emit log_named_int  ("    Actual", a);
 270 |     |             emit log_named_uint (" Max Delta", maxDelta);
 271 |     |             emit log_named_uint ("     Delta", delta);
 272 |     |             fail();
 273 |     |         }
 274 |     |     }
 275 |     | 
 276 |     |     function assertApproxEqAbs(
 277 |     |         int256 a,
 278 |     |         int256 b,
 279 |     |         uint256 maxDelta,
 280 |     |         string memory err
 281 |     |     ) internal virtual {
 282 |     |         uint256 delta = stdMath.delta(a, b);
 283 |     | 
 284 |     |         if (delta > maxDelta) {
 285 |     |             emit log_named_string   ("Error", err);
 286 |     |             assertApproxEqAbs(a, b, maxDelta);
 287 |     |         }
 288 |     |     }
 289 |     | 
 290 |     |     function assertApproxEqRel(
 291 |     |         uint256 a,
 292 |     |         uint256 b,
 293 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 294 |     |     ) internal virtual {
 295 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 296 |     | 
 297 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 298 |     | 
 299 |     |         if (percentDelta > maxPercentDelta) {
 300 |     |             emit log                    ("Error: a ~= b not satisfied [uint]");
 301 |     |             emit log_named_uint         ("    Expected", b);
 302 |     |             emit log_named_uint         ("      Actual", a);
 303 |     |             emit log_named_decimal_uint (" Max % Delta", maxPercentDelta, 18);
 304 |     |             emit log_named_decimal_uint ("     % Delta", percentDelta, 18);
 305 |     |             fail();
 306 |     |         }
 307 |     |     }
 308 |     | 
 309 |     |     function assertApproxEqRel(
 310 |     |         uint256 a,
 311 |     |         uint256 b,
 312 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 313 |     |         string memory err
 314 |     |     ) internal virtual {
 315 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 316 |     | 
 317 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 318 |     | 
 319 |     |         if (percentDelta > maxPercentDelta) {
 320 |     |             emit log_named_string       ("Error", err);
 321 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 322 |     |         }
 323 |     |     }
 324 |     | 
 325 |     |     function assertApproxEqRel(
 326 |     |         int256 a,
 327 |     |         int256 b,
 328 |     |         uint256 maxPercentDelta
 329 |     |     ) internal virtual {
 330 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 331 |     | 
 332 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 333 |     | 
 334 |     |         if (percentDelta > maxPercentDelta) {
 335 |     |             emit log                   ("Error: a ~= b not satisfied [int]");
 336 |     |             emit log_named_int         ("    Expected", b);
 337 |     |             emit log_named_int         ("      Actual", a);
 338 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 339 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 340 |     |             fail();
 341 |     |         }
 342 |     |     }
 343 |     | 
 344 |     |     function assertApproxEqRel(
 345 |     |         int256 a,
 346 |     |         int256 b,
 347 |     |         uint256 maxPercentDelta,
 348 |     |         string memory err
 349 |     |     ) internal virtual {
 350 |     |         if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.
 351 |     | 
 352 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 353 |     | 
 354 |     |         if (percentDelta > maxPercentDelta) {
 355 |     |             emit log_named_string      ("Error", err);
 356 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 357 |     |         }
 358 |     |     }
 359 |     | }
 360 |     | 
 361 |     | /*//////////////////////////////////////////////////////////////////////////
 362 |     |                                 STD-ERRORS
 363 |     | //////////////////////////////////////////////////////////////////////////*/
 364 |     | 
 365 |     | library stdError {
 366 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
 367 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
 368 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
 369 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 370 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 371 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 372 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 373 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 374 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 375 |     |     // DEPRECATED: Use Hevm's `expectRevert` without any arguments instead
 376 |     |     bytes public constant lowLevelError = bytes(""); // `0x`
 377 |     | }
 378 |     | 
 379 |     | /*//////////////////////////////////////////////////////////////////////////
 380 |     |                                 STD-STORAGE
 381 |     | //////////////////////////////////////////////////////////////////////////*/
 382 |     | 
 383 |     | struct StdStorage {
 384 |     |     mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
 385 |     |     mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;
 386 |     | 
 387 |     |     bytes32[] _keys;
 388 |     |     bytes4 _sig;
 389 |     |     uint256 _depth;
 390 |     |     address _target;
 391 |     |     bytes32 _set;
 392 |     | }
 393 |     | 
 394 |     | library stdStorage {
 395 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);
 396 |     |     event WARNING_UninitedSlot(address who, uint slot);
 397 |     | 
 398 |     |     uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
 399 |     |     int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;
 400 |     | 
 401 |     |     Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));
 402 |     | 
 403 |     |     function sigs(
 404 |     |         string memory sigStr
 405 |     |     )
 406 |     |         internal
 407 |     |         pure
 408 |     |         returns (bytes4)
 409 |     |     {
 410 |     |         return bytes4(keccak256(bytes(sigStr)));
 411 |     |     }
 412 |     | 
 413 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
 414 |     |     // slot complexity:
 415 |     |     //  if flat, will be bytes32(uint256(uint));
 416 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
 417 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
 418 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
 419 |     |     function find(
 420 |     |         StdStorage storage self
 421 |     |     )
 422 |     |         internal
 423 |     |         returns (uint256)
 424 |     |     {
 425 |     |         address who = self._target;
 426 |     |         bytes4 fsig = self._sig;
 427 |     |         uint256 field_depth = self._depth;
 428 |     |         bytes32[] memory ins = self._keys;
 429 |     | 
 430 |     |         // calldata to test against
 431 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
 432 |     |             return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
 433 |     |         }
 434 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
 435 |     |         vm_std_store.record();
 436 |     |         bytes32 fdat;
 437 |     |         {
 438 |     |             (, bytes memory rdat) = who.staticcall(cald);
 439 |     |             fdat = bytesToBytes32(rdat, 32*field_depth);
 440 |     |         }
 441 |     | 
 442 |     |         (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));
 443 |     |         if (reads.length == 1) {
 444 |     |             bytes32 curr = vm_std_store.load(who, reads[0]);
 445 |     |             if (curr == bytes32(0)) {
 446 |     |                 emit WARNING_UninitedSlot(who, uint256(reads[0]));
 447 |     |             }
 448 |     |             if (fdat != curr) {
 449 |     |                 require(false, "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported");
 450 |     |             }
 451 |     |             emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));
 452 |     |             self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);
 453 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
 454 |     |         } else if (reads.length > 1) {
 455 |     |             for (uint256 i = 0; i < reads.length; i++) {
 456 |     |                 bytes32 prev = vm_std_store.load(who, reads[i]);
 457 |     |                 if (prev == bytes32(0)) {
 458 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
 459 |     |                 }
 460 |     |                 // store
 461 |     |                 vm_std_store.store(who, reads[i], bytes32(hex"1337"));
 462 |     |                 bool success;
 463 |     |                 bytes memory rdat;
 464 |     |                 {
 465 |     |                     (success, rdat) = who.staticcall(cald);
 466 |     |                     fdat = bytesToBytes32(rdat, 32*field_depth);
 467 |     |                 }
 468 |     | 
 469 |     |                 if (success && fdat == bytes32(hex"1337")) {
 470 |     |                     // we found which of the slots is the actual one
 471 |     |                     emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));
 472 |     |                     self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);
 473 |     |                     self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
 474 |     |                     vm_std_store.store(who, reads[i], prev);
 475 |     |                     break;
 476 |     |                 }
 477 |     |                 vm_std_store.store(who, reads[i], prev);
 478 |     |             }
 479 |     |         } else {
 480 |     |             require(false, "stdStorage find(StdStorage): No storage use detected for target.");
 481 |     |         }
 482 |     | 
 483 |     |         require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], "stdStorage find(StdStorage): Slot(s) not found.");
 484 |     | 
 485 |     |         delete self._target;
 486 |     |         delete self._sig;
 487 |     |         delete self._keys;
 488 |     |         delete self._depth;
 489 |     | 
 490 |     |         return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
 491 |     |     }
 492 |     | 
 493 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 494 |     |         self._target = _target;
 495 |     |         return self;
 496 |     |     }
 497 |     | 
 498 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 499 |     |         self._sig = _sig;
 500 |     |         return self;
 501 |     |     }
 502 |     | 
 503 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 504 |     |         self._sig = sigs(_sig);
 505 |     |         return self;
 506 |     |     }
 507 |     | 
 508 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 509 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 510 |     |         return self;
 511 |     |     }
 512 |     | 
 513 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 514 |     |         self._keys.push(bytes32(amt));
 515 |     |         return self;
 516 |     |     }
 517 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 518 |     |         self._keys.push(key);
 519 |     |         return self;
 520 |     |     }
 521 |     | 
 522 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 523 |     |         self._depth = _depth;
 524 |     |         return self;
 525 |     |     }
 526 |     | 
 527 |     |     function checked_write(StdStorage storage self, address who) internal {
 528 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 529 |     |     }
 530 |     | 
 531 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 532 |     |         checked_write(self, bytes32(amt));
 533 |     |     }
 534 |     | 
 535 |     |     function checked_write(StdStorage storage self, bool write) internal {
 536 |     |         bytes32 t;
 537 |     |         /// @solidity memory-safe-assembly
 538 |     |         assembly {
 539 |     |             t := write
 540 |     |         }
 541 |     |         checked_write(self, t);
 542 |     |     }
 543 |     | 
 544 |     |     function checked_write(
 545 |     |         StdStorage storage self,
 546 |     |         bytes32 set
 547 |     |     ) internal {
 548 |     |         address who = self._target;
 549 |     |         bytes4 fsig = self._sig;
 550 |     |         uint256 field_depth = self._depth;
 551 |     |         bytes32[] memory ins = self._keys;
 552 |     | 
 553 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
 554 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
 555 |     |             find(self);
 556 |     |         }
 557 |     |         bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);
 558 |     | 
 559 |     |         bytes32 fdat;
 560 |     |         {
 561 |     |             (, bytes memory rdat) = who.staticcall(cald);
 562 |     |             fdat = bytesToBytes32(rdat, 32*field_depth);
 563 |     |         }
 564 |     |         bytes32 curr = vm_std_store.load(who, slot);
 565 |     | 
 566 |     |         if (fdat != curr) {
 567 |     |             require(false, "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported.");
 568 |     |         }
 569 |     |         vm_std_store.store(who, slot, set);
 570 |     |         delete self._target;
 571 |     |         delete self._sig;
 572 |     |         delete self._keys;
 573 |     |         delete self._depth;
 574 |     |     }
 575 |     | 
 576 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 577 |     |         address t = self._target;
 578 |     |         uint256 s = find(self);
 579 |     |         return abi.encode(vm_std_store.load(t, bytes32(s)));
 580 |     |     }
 581 |     | 
 582 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 583 |     |         return abi.decode(read(self), (bytes32));
 584 |     |     }
 585 |     | 
 586 |     | 
 587 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 588 |     |         return abi.decode(read(self), (bool));
 589 |     |     }
 590 |     | 
 591 |     |     function read_address(StdStorage storage self) internal returns (address) {
 592 |     |         return abi.decode(read(self), (address));
 593 |     |     }
 594 |     | 
 595 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 596 |     |         return abi.decode(read(self), (uint256));
 597 |     |     }
 598 |     | 
 599 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 600 |     |         return abi.decode(read(self), (int256));
 601 |     |     }
 602 |     | 
 603 |     |     function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {
 604 |     |         bytes32 out;
 605 |     | 
 606 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 607 |     |         for (uint i = 0; i < max; i++) {
 608 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 609 |     |         }
 610 |     |         return out;
 611 |     |     }
 612 |     | 
 613 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory)
 614 |     |     {
 615 |     |         bytes memory result = new bytes(b.length * 32);
 616 |     |         for (uint256 i = 0; i < b.length; i++) {
 617 |     |             bytes32 k = b[i];
 618 |     |             /// @solidity memory-safe-assembly
 619 |     |             assembly {
 620 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 621 |     |             }
 622 |     |         }
 623 |     | 
 624 |     |         return result;
 625 |     |     }
 626 |     | }
 627 |     | 
 628 |     | /*//////////////////////////////////////////////////////////////////////////
 629 |     |                                 STD-MATH
 630 |     | //////////////////////////////////////////////////////////////////////////*/
 631 |     | 
 632 |     | library stdMath {
 633 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
 634 |     | 
 635 |     |     function abs(int256 a) internal pure returns (uint256) {
 636 |     |         // Required or it will fail when `a = type(int256).min`
 637 |     |         if (a == INT256_MIN)
 638 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 639 |     | 
 640 |     |         return uint256(a >= 0 ? a : -a);
 641 |     |     }
 642 |     | 
 643 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 644 |     |         return a > b
 645 |     |             ? a - b
 646 |     |             : b - a;
 647 |     |     }
 648 |     | 
 649 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 650 |     |         // a and b are of the same sign
 651 |     |         if (a >= 0 && b >= 0 || a < 0 && b < 0) {
 652 |     |             return delta(abs(a), abs(b));
 653 |     |         }
 654 |     | 
 655 |     |         // a and b are of opposite signs
 656 |     |         return abs(a) + abs(b);
 657 |     |     }
 658 |     | 
 659 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 660 |     |         uint256 absDelta = delta(a, b);
 661 |     | 
 662 |     |         return absDelta * 1e18 / b;
 663 |     |     }
 664 |     | 
 665 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 666 |     |         uint256 absDelta = delta(a, b);
 667 |     |         uint256 absB = abs(b);
 668 |     | 
 669 |     |         return absDelta * 1e18 / absB;
 670 |     |     }
 671 |     | }
 672 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/Vm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity >=0.6.0;
  3 |     | pragma experimental ABIEncoderV2;
  4 |     | 
  5 |     | interface Vm {
  6 |     |     // Set block.timestamp (newTimestamp)
  7 |     |     function warp(uint256) external;
  8 |     |     // Set block.height (newHeight)
  9 |     |     function roll(uint256) external;
 10 |     |     // Set block.basefee (newBasefee)
 11 |     |     function fee(uint256) external;
 12 |     |     // Set block.chainid
 13 |     |     function chainId(uint256) external;
 14 |     |     // Loads a storage slot from an address (who, slot)
 15 |     |     function load(address,bytes32) external returns (bytes32);
 16 |     |     // Stores a value to an address' storage slot, (who, slot, value)
 17 |     |     function store(address,bytes32,bytes32) external;
 18 |     |     // Signs data, (privateKey, digest) => (v, r, s)
 19 |     |     function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);
 20 |     |     // Gets address for a given private key, (privateKey) => (address)
 21 |     |     function addr(uint256) external returns (address);
 22 |     |     // Gets the nonce of an account
 23 |     |     function getNonce(address) external returns (uint64);
 24 |     |     // Sets the nonce of an account; must be higher than the current nonce of the account
 25 |     |     function setNonce(address, uint64) external;
 26 |     |     // Performs a foreign function call via terminal, (stringInputs) => (result)
 27 |     |     function ffi(string[] calldata) external returns (bytes memory);
 28 |     |     // Sets the *next* call's msg.sender to be the input address
 29 |     |     function prank(address) external;
 30 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
 31 |     |     function startPrank(address) external;
 32 |     |     // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
 33 |     |     function prank(address,address) external;
 34 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
 35 |     |     function startPrank(address,address) external;
 36 |     |     // Resets subsequent calls' msg.sender to be `address(this)`
 37 |     |     function stopPrank() external;
 38 |     |     // Sets an address' balance, (who, newBalance)
 39 |     |     function deal(address, uint256) external;
 40 |     |     // Sets an address' code, (who, newCode)
 41 |     |     function etch(address, bytes calldata) external;
 42 |     |     // Expects an error on next call
 43 |     |     function expectRevert(bytes calldata) external;
 44 |     |     function expectRevert(bytes4) external;
 45 |     |     function expectRevert() external;
 46 |     |     // Record all storage reads and writes
 47 |     |     function record() external;
 48 |     |     // Gets all accessed reads and write slot from a recording session, for a given address
 49 |     |     function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);
 50 |     |     // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
 51 |     |     // Call this function, then emit an event, then call a function. Internally after the call, we check if
 52 |     |     // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
 53 |     |     function expectEmit(bool,bool,bool,bool) external;
 54 |     |     function expectEmit(bool,bool,bool,bool,address) external;
 55 |     |     // Mocks a call to an address, returning specified data.
 56 |     |     // Calldata can either be strict or a partial match, e.g. if you only
 57 |     |     // pass a Solidity selector to the expected calldata, then the entire Solidity
 58 |     |     // function will be mocked.
 59 |     |     function mockCall(address,bytes calldata,bytes calldata) external;
 60 |     |     // Mocks a call to an address with a specific msg.value, returning specified data.
 61 |     |     // Calldata match takes precedence over msg.value in case of ambiguity.
 62 |     |     function mockCall(address,uint256,bytes calldata,bytes calldata) external;
 63 |     |     // Clears all mocked calls
 64 |     |     function clearMockedCalls() external;
 65 |     |     // Expect a call to an address with the specified calldata.
 66 |     |     // Calldata can either be strict or a partial match
 67 |     |     function expectCall(address,bytes calldata) external;
 68 |     |     // Expect a call to an address with the specified msg.value and calldata
 69 |     |     function expectCall(address,uint256,bytes calldata) external;
 70 |     |     // Gets the code from an artifact file. Takes in the relative path to the json file
 71 |     |     function getCode(string calldata) external returns (bytes memory);
 72 |     |     // Labels an address in call traces
 73 |     |     function label(address, string calldata) external;
 74 |     |     // If the condition is false, discard this run's fuzz inputs and generate new ones
 75 |     |     function assume(bool) external;
 76 |     |     // Set block.coinbase (who)
 77 |     |     function coinbase(address) external;
 78 |     |     // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain
 79 |     |     function broadcast() external;
 80 |     |     // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain
 81 |     |     function broadcast(address) external;
 82 |     |     // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain
 83 |     |     function startBroadcast() external;
 84 |     |     // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain
 85 |     |     function startBroadcast(address) external;
 86 |     |     // Stops collecting onchain transactions
 87 |     |     function stopBroadcast() external;
 88 |     | }
 89 |     | 

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 | *   |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 | *   |     function _sendLogPayload(bytes memory payload) private view {
    8 | *   |         uint256 payloadLength = payload.length;
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 | *   |         assembly {
   12 | *   |             let payloadStart := add(payload, 32)
   13 | *   |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   14 |     |         }
   15 |     |     }
   16 |     | 
   17 |     |     function log() internal view {
   18 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   19 |     |     }
   20 |     | 
   21 |     |     function logInt(int p0) internal view {
   22 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   23 |     |     }
   24 |     | 
   25 |     |     function logUint(uint p0) internal view {
   26 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   27 |     |     }
   28 |     | 
   29 |     |     function logString(string memory p0) internal view {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   31 |     |     }
   32 |     | 
   33 |     |     function logBool(bool p0) internal view {
   34 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logAddress(address p0) internal view {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logBytes(bytes memory p0) internal view {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBytes1(bytes1 p0) internal view {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logBytes2(bytes2 p0) internal view {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes3(bytes3 p0) internal view {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes4(bytes4 p0) internal view {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes5(bytes5 p0) internal view {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes6(bytes6 p0) internal view {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes7(bytes7 p0) internal view {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes8(bytes8 p0) internal view {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes9(bytes9 p0) internal view {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes10(bytes10 p0) internal view {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes11(bytes11 p0) internal view {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes12(bytes12 p0) internal view {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes13(bytes13 p0) internal view {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes14(bytes14 p0) internal view {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes15(bytes15 p0) internal view {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes16(bytes16 p0) internal view {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes17(bytes17 p0) internal view {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes18(bytes18 p0) internal view {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes19(bytes19 p0) internal view {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes20(bytes20 p0) internal view {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes21(bytes21 p0) internal view {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes22(bytes22 p0) internal view {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes23(bytes23 p0) internal view {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes24(bytes24 p0) internal view {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes25(bytes25 p0) internal view {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes26(bytes26 p0) internal view {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes27(bytes27 p0) internal view {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes28(bytes28 p0) internal view {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes29(bytes29 p0) internal view {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes30(bytes30 p0) internal view {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes31(bytes31 p0) internal view {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes32(bytes32 p0) internal view {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function log(uint p0) internal view {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  175 |     |     }
  176 |     | 
  177 | *   |     function log(string memory p0) internal view {
  178 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function log(bool p0) internal view {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(address p0) internal view {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(uint p0, uint p1) internal view {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint p0, string memory p1) internal view {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  195 |     |     }
  196 |     | 
  197 |     |     function log(uint p0, bool p1) internal view {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  199 |     |     }
  200 |     | 
  201 |     |     function log(uint p0, address p1) internal view {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  203 |     |     }
  204 |     | 
  205 |     |     function log(string memory p0, uint p1) internal view {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(string memory p0, string memory p1) internal view {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(string memory p0, bool p1) internal view {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(string memory p0, address p1) internal view {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(bool p0, uint p1) internal view {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(bool p0, string memory p1) internal view {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(bool p0, bool p1) internal view {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(bool p0, address p1) internal view {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(address p0, uint p1) internal view {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(address p0, string memory p1) internal view {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(address p0, bool p1) internal view {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(address p0, address p1) internal view {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(uint p0, uint p1, uint p2) internal view {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  255 |     |     }
  256 |     | 
  257 |     |     function log(uint p0, uint p1, string memory p2) internal view {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  259 |     |     }
  260 |     | 
  261 |     |     function log(uint p0, uint p1, bool p2) internal view {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  263 |     |     }
  264 |     | 
  265 |     |     function log(uint p0, uint p1, address p2) internal view {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  267 |     |     }
  268 |     | 
  269 |     |     function log(uint p0, string memory p1, uint p2) internal view {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, string memory p1, string memory p2) internal view {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, string memory p1, bool p2) internal view {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, string memory p1, address p2) internal view {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, bool p1, uint p2) internal view {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, bool p1, string memory p2) internal view {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, bool p1, bool p2) internal view {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, bool p1, address p2) internal view {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, address p1, uint p2) internal view {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, address p1, string memory p2) internal view {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, address p1, bool p2) internal view {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, address p1, address p2) internal view {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(string memory p0, uint p1, uint p2) internal view {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(string memory p0, uint p1, string memory p2) internal view {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(string memory p0, uint p1, bool p2) internal view {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(string memory p0, uint p1, address p2) internal view {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(string memory p0, string memory p1, uint p2) internal view {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, bool p1, uint p2) internal view {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, bool p1, address p2) internal view {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, address p1, uint p2) internal view {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, address p1, bool p2) internal view {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, address p1, address p2) internal view {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(bool p0, uint p1, uint p2) internal view {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(bool p0, uint p1, string memory p2) internal view {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(bool p0, uint p1, bool p2) internal view {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(bool p0, uint p1, address p2) internal view {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(bool p0, string memory p1, uint p2) internal view {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, string memory p1, address p2) internal view {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, bool p1, uint p2) internal view {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, bool p1, bool p2) internal view {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, bool p1, address p2) internal view {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, address p1, uint p2) internal view {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, address p1, string memory p2) internal view {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, address p1, bool p2) internal view {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, address p1, address p2) internal view {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(address p0, uint p1, uint p2) internal view {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(address p0, uint p1, string memory p2) internal view {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(address p0, uint p1, bool p2) internal view {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(address p0, uint p1, address p2) internal view {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(address p0, string memory p1, uint p2) internal view {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, string memory p1, bool p2) internal view {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, string memory p1, address p2) internal view {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, bool p1, uint p2) internal view {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, bool p1, string memory p2) internal view {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, bool p1, bool p2) internal view {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, bool p1, address p2) internal view {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, address p1, uint p2) internal view {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, address p1, string memory p2) internal view {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, address p1, bool p2) internal view {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, address p1, address p2) internal view {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal view {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  511 |     |     }
  512 |     | 
  513 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal view {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  515 |     |     }
  516 |     | 
  517 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal view {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  519 |     |     }
  520 |     | 
  521 |     |     function log(uint p0, uint p1, uint p2, address p3) internal view {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  523 |     |     }
  524 |     | 
  525 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal view {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal view {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal view {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal view {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal view {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal view {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, bool p2, address p3) internal view {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, address p2, uint p3) internal view {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal view {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, address p2, bool p3) internal view {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, address p2, address p3) internal view {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal view {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal view {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal view {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal view {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal view {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal view {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal view {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal view {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal view {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal view {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, address p2, address p3) internal view {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal view {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal view {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal view {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, bool p1, uint p2, address p3) internal view {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal view {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal view {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal view {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal view {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal view {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal view {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, bool p2, address p3) internal view {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, address p2, uint p3) internal view {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal view {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, address p2, bool p3) internal view {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, address p2, address p3) internal view {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, address p1, uint p2, uint p3) internal view {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal view {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, address p1, uint p2, bool p3) internal view {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, address p1, uint p2, address p3) internal view {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal view {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal view {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal view {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, string memory p2, address p3) internal view {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, bool p2, uint p3) internal view {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal view {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, bool p2, bool p3) internal view {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, bool p2, address p3) internal view {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, address p2, uint p3) internal view {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, address p2, string memory p3) internal view {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, address p2, bool p3) internal view {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, address p2, address p3) internal view {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal view {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal view {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal view {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal view {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal view {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal view {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal view {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal view {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal view {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal view {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, address p2, address p3) internal view {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal view {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal view {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal view {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal view {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal view {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal view {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal view {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal view {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal view {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal view {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, address p1, uint p2, address p3) internal view {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal view {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal view {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, address p2, uint p3) internal view {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal view {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal view {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal view {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(bool p0, uint p1, uint p2, address p3) internal view {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal view {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal view {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal view {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal view {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal view {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal view {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, bool p2, address p3) internal view {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, address p2, uint p3) internal view {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal view {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, address p2, bool p3) internal view {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, address p2, address p3) internal view {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal view {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal view {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal view {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal view {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal view {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal view {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal view {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal view {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, bool p1, uint p2, address p3) internal view {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal view {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal view {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, address p2, uint p3) internal view {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, address p1, uint p2, uint p3) internal view {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal view {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, address p1, uint p2, bool p3) internal view {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, address p1, uint p2, address p3) internal view {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal view {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, bool p2, uint p3) internal view {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, address p2, uint p3) internal view {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(address p0, uint p1, uint p2, uint p3) internal view {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal view {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(address p0, uint p1, uint p2, bool p3) internal view {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(address p0, uint p1, uint p2, address p3) internal view {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal view {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal view {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal view {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, string memory p2, address p3) internal view {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, bool p2, uint p3) internal view {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal view {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, bool p2, bool p3) internal view {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, bool p2, address p3) internal view {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, address p2, uint p3) internal view {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, address p2, string memory p3) internal view {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, address p2, bool p3) internal view {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, address p2, address p3) internal view {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal view {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal view {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal view {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, string memory p1, uint p2, address p3) internal view {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal view {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal view {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, address p2, uint p3) internal view {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, bool p1, uint p2, uint p3) internal view {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal view {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, bool p1, uint p2, bool p3) internal view {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, bool p1, uint p2, address p3) internal view {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal view {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, bool p2, uint p3) internal view {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, address p2, uint p3) internal view {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, address p1, uint p2, uint p3) internal view {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, address p1, uint p2, string memory p3) internal view {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, address p1, uint p2, bool p3) internal view {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, address p1, uint p2, address p3) internal view {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, address p1, string memory p2, uint p3) internal view {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, bool p2, uint p3) internal view {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, address p2, uint p3) internal view {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     | }

/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/console2.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | // The orignal console.sol uses `int` and `uint` for computing function selectors, but it should
    5 |     | // use `int256` and `uint256`. This modified version fixes that. This version is recommended
    6 |     | // over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in
    7 |     | // forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.
    8 |     | // Reference: https://github.com/NomicFoundation/hardhat/issues/2178
    9 |     | 
   10 |     | library console2 {
   11 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
   12 |     | 
   13 |     |     function _sendLogPayload(bytes memory payload) private view {
   14 |     |         uint256 payloadLength = payload.length;
   15 |     |         address consoleAddress = CONSOLE_ADDRESS;
   16 |     |         assembly {
   17 |     |             let payloadStart := add(payload, 32)
   18 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   19 |     |         }
   20 |     |     }
   21 |     | 
   22 |     |     function log() internal view {
   23 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   24 |     |     }
   25 |     | 
   26 |     |     function logInt(int256 p0) internal view {
   27 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   28 |     |     }
   29 |     | 
   30 |     |     function logUint(uint256 p0) internal view {
   31 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   32 |     |     }
   33 |     | 
   34 |     |     function logString(string memory p0) internal view {
   35 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   36 |     |     }
   37 |     | 
   38 |     |     function logBool(bool p0) internal view {
   39 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   40 |     |     }
   41 |     | 
   42 |     |     function logAddress(address p0) internal view {
   43 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   44 |     |     }
   45 |     | 
   46 |     |     function logBytes(bytes memory p0) internal view {
   47 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   48 |     |     }
   49 |     | 
   50 |     |     function logBytes1(bytes1 p0) internal view {
   51 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   52 |     |     }
   53 |     | 
   54 |     |     function logBytes2(bytes2 p0) internal view {
   55 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   56 |     |     }
   57 |     | 
   58 |     |     function logBytes3(bytes3 p0) internal view {
   59 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   60 |     |     }
   61 |     | 
   62 |     |     function logBytes4(bytes4 p0) internal view {
   63 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   64 |     |     }
   65 |     | 
   66 |     |     function logBytes5(bytes5 p0) internal view {
   67 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   68 |     |     }
   69 |     | 
   70 |     |     function logBytes6(bytes6 p0) internal view {
   71 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   72 |     |     }
   73 |     | 
   74 |     |     function logBytes7(bytes7 p0) internal view {
   75 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   76 |     |     }
   77 |     | 
   78 |     |     function logBytes8(bytes8 p0) internal view {
   79 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   80 |     |     }
   81 |     | 
   82 |     |     function logBytes9(bytes9 p0) internal view {
   83 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   84 |     |     }
   85 |     | 
   86 |     |     function logBytes10(bytes10 p0) internal view {
   87 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   88 |     |     }
   89 |     | 
   90 |     |     function logBytes11(bytes11 p0) internal view {
   91 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   92 |     |     }
   93 |     | 
   94 |     |     function logBytes12(bytes12 p0) internal view {
   95 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   96 |     |     }
   97 |     | 
   98 |     |     function logBytes13(bytes13 p0) internal view {
   99 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  100 |     |     }
  101 |     | 
  102 |     |     function logBytes14(bytes14 p0) internal view {
  103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  104 |     |     }
  105 |     | 
  106 |     |     function logBytes15(bytes15 p0) internal view {
  107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  108 |     |     }
  109 |     | 
  110 |     |     function logBytes16(bytes16 p0) internal view {
  111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  112 |     |     }
  113 |     | 
  114 |     |     function logBytes17(bytes17 p0) internal view {
  115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  116 |     |     }
  117 |     | 
  118 |     |     function logBytes18(bytes18 p0) internal view {
  119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  120 |     |     }
  121 |     | 
  122 |     |     function logBytes19(bytes19 p0) internal view {
  123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  124 |     |     }
  125 |     | 
  126 |     |     function logBytes20(bytes20 p0) internal view {
  127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  128 |     |     }
  129 |     | 
  130 |     |     function logBytes21(bytes21 p0) internal view {
  131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  132 |     |     }
  133 |     | 
  134 |     |     function logBytes22(bytes22 p0) internal view {
  135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  136 |     |     }
  137 |     | 
  138 |     |     function logBytes23(bytes23 p0) internal view {
  139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  140 |     |     }
  141 |     | 
  142 |     |     function logBytes24(bytes24 p0) internal view {
  143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  144 |     |     }
  145 |     | 
  146 |     |     function logBytes25(bytes25 p0) internal view {
  147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  148 |     |     }
  149 |     | 
  150 |     |     function logBytes26(bytes26 p0) internal view {
  151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  152 |     |     }
  153 |     | 
  154 |     |     function logBytes27(bytes27 p0) internal view {
  155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  156 |     |     }
  157 |     | 
  158 |     |     function logBytes28(bytes28 p0) internal view {
  159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  160 |     |     }
  161 |     | 
  162 |     |     function logBytes29(bytes29 p0) internal view {
  163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  164 |     |     }
  165 |     | 
  166 |     |     function logBytes30(bytes30 p0) internal view {
  167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  168 |     |     }
  169 |     | 
  170 |     |     function logBytes31(bytes31 p0) internal view {
  171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  172 |     |     }
  173 |     | 
  174 |     |     function logBytes32(bytes32 p0) internal view {
  175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  176 |     |     }
  177 |     | 
  178 |     |     function log(uint256 p0) internal view {
  179 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  180 |     |     }
  181 |     | 
  182 |     |     function log(string memory p0) internal view {
  183 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  184 |     |     }
  185 |     | 
  186 |     |     function log(bool p0) internal view {
  187 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  188 |     |     }
  189 |     | 
  190 |     |     function log(address p0) internal view {
  191 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  192 |     |     }
  193 |     | 
  194 |     |     function log(uint256 p0, uint256 p1) internal view {
  195 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  196 |     |     }
  197 |     | 
  198 |     |     function log(uint256 p0, string memory p1) internal view {
  199 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  200 |     |     }
  201 |     | 
  202 |     |     function log(uint256 p0, bool p1) internal view {
  203 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  204 |     |     }
  205 |     | 
  206 |     |     function log(uint256 p0, address p1) internal view {
  207 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  208 |     |     }
  209 |     | 
  210 |     |     function log(string memory p0, uint256 p1) internal view {
  211 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  212 |     |     }
  213 |     | 
  214 |     |     function log(string memory p0, string memory p1) internal view {
  215 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  216 |     |     }
  217 |     | 
  218 |     |     function log(string memory p0, bool p1) internal view {
  219 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  220 |     |     }
  221 |     | 
  222 |     |     function log(string memory p0, address p1) internal view {
  223 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  224 |     |     }
  225 |     | 
  226 |     |     function log(bool p0, uint256 p1) internal view {
  227 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  228 |     |     }
  229 |     | 
  230 |     |     function log(bool p0, string memory p1) internal view {
  231 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  232 |     |     }
  233 |     | 
  234 |     |     function log(bool p0, bool p1) internal view {
  235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  236 |     |     }
  237 |     | 
  238 |     |     function log(bool p0, address p1) internal view {
  239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  240 |     |     }
  241 |     | 
  242 |     |     function log(address p0, uint256 p1) internal view {
  243 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  244 |     |     }
  245 |     | 
  246 |     |     function log(address p0, string memory p1) internal view {
  247 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  248 |     |     }
  249 |     | 
  250 |     |     function log(address p0, bool p1) internal view {
  251 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  252 |     |     }
  253 |     | 
  254 |     |     function log(address p0, address p1) internal view {
  255 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  256 |     |     }
  257 |     | 
  258 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal view {
  259 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  260 |     |     }
  261 |     | 
  262 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal view {
  263 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  264 |     |     }
  265 |     | 
  266 |     |     function log(uint256 p0, uint256 p1, bool p2) internal view {
  267 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  268 |     |     }
  269 |     | 
  270 |     |     function log(uint256 p0, uint256 p1, address p2) internal view {
  271 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  272 |     |     }
  273 |     | 
  274 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal view {
  275 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  276 |     |     }
  277 |     | 
  278 |     |     function log(uint256 p0, string memory p1, string memory p2) internal view {
  279 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  280 |     |     }
  281 |     | 
  282 |     |     function log(uint256 p0, string memory p1, bool p2) internal view {
  283 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  284 |     |     }
  285 |     | 
  286 |     |     function log(uint256 p0, string memory p1, address p2) internal view {
  287 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  288 |     |     }
  289 |     | 
  290 |     |     function log(uint256 p0, bool p1, uint256 p2) internal view {
  291 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  292 |     |     }
  293 |     | 
  294 |     |     function log(uint256 p0, bool p1, string memory p2) internal view {
  295 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  296 |     |     }
  297 |     | 
  298 |     |     function log(uint256 p0, bool p1, bool p2) internal view {
  299 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  300 |     |     }
  301 |     | 
  302 |     |     function log(uint256 p0, bool p1, address p2) internal view {
  303 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  304 |     |     }
  305 |     | 
  306 |     |     function log(uint256 p0, address p1, uint256 p2) internal view {
  307 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  308 |     |     }
  309 |     | 
  310 |     |     function log(uint256 p0, address p1, string memory p2) internal view {
  311 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  312 |     |     }
  313 |     | 
  314 |     |     function log(uint256 p0, address p1, bool p2) internal view {
  315 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  316 |     |     }
  317 |     | 
  318 |     |     function log(uint256 p0, address p1, address p2) internal view {
  319 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  320 |     |     }
  321 |     | 
  322 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal view {
  323 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  324 |     |     }
  325 |     | 
  326 |     |     function log(string memory p0, uint256 p1, string memory p2) internal view {
  327 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  328 |     |     }
  329 |     | 
  330 |     |     function log(string memory p0, uint256 p1, bool p2) internal view {
  331 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  332 |     |     }
  333 |     | 
  334 |     |     function log(string memory p0, uint256 p1, address p2) internal view {
  335 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  336 |     |     }
  337 |     | 
  338 |     |     function log(string memory p0, string memory p1, uint256 p2) internal view {
  339 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  340 |     |     }
  341 |     | 
  342 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  343 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  344 |     |     }
  345 |     | 
  346 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  347 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  348 |     |     }
  349 |     | 
  350 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  351 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  352 |     |     }
  353 |     | 
  354 |     |     function log(string memory p0, bool p1, uint256 p2) internal view {
  355 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  356 |     |     }
  357 |     | 
  358 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  359 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  360 |     |     }
  361 |     | 
  362 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  363 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  364 |     |     }
  365 |     | 
  366 |     |     function log(string memory p0, bool p1, address p2) internal view {
  367 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  368 |     |     }
  369 |     | 
  370 |     |     function log(string memory p0, address p1, uint256 p2) internal view {
  371 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  372 |     |     }
  373 |     | 
  374 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  375 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  376 |     |     }
  377 |     | 
  378 |     |     function log(string memory p0, address p1, bool p2) internal view {
  379 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  380 |     |     }
  381 |     | 
  382 |     |     function log(string memory p0, address p1, address p2) internal view {
  383 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  384 |     |     }
  385 |     | 
  386 |     |     function log(bool p0, uint256 p1, uint256 p2) internal view {
  387 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  388 |     |     }
  389 |     | 
  390 |     |     function log(bool p0, uint256 p1, string memory p2) internal view {
  391 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  392 |     |     }
  393 |     | 
  394 |     |     function log(bool p0, uint256 p1, bool p2) internal view {
  395 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  396 |     |     }
  397 |     | 
  398 |     |     function log(bool p0, uint256 p1, address p2) internal view {
  399 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  400 |     |     }
  401 |     | 
  402 |     |     function log(bool p0, string memory p1, uint256 p2) internal view {
  403 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  404 |     |     }
  405 |     | 
  406 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  407 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  408 |     |     }
  409 |     | 
  410 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  411 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  412 |     |     }
  413 |     | 
  414 |     |     function log(bool p0, string memory p1, address p2) internal view {
  415 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  416 |     |     }
  417 |     | 
  418 |     |     function log(bool p0, bool p1, uint256 p2) internal view {
  419 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  420 |     |     }
  421 |     | 
  422 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  423 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  424 |     |     }
  425 |     | 
  426 |     |     function log(bool p0, bool p1, bool p2) internal view {
  427 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  428 |     |     }
  429 |     | 
  430 |     |     function log(bool p0, bool p1, address p2) internal view {
  431 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  432 |     |     }
  433 |     | 
  434 |     |     function log(bool p0, address p1, uint256 p2) internal view {
  435 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  436 |     |     }
  437 |     | 
  438 |     |     function log(bool p0, address p1, string memory p2) internal view {
  439 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  440 |     |     }
  441 |     | 
  442 |     |     function log(bool p0, address p1, bool p2) internal view {
  443 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  444 |     |     }
  445 |     | 
  446 |     |     function log(bool p0, address p1, address p2) internal view {
  447 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  448 |     |     }
  449 |     | 
  450 |     |     function log(address p0, uint256 p1, uint256 p2) internal view {
  451 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  452 |     |     }
  453 |     | 
  454 |     |     function log(address p0, uint256 p1, string memory p2) internal view {
  455 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  456 |     |     }
  457 |     | 
  458 |     |     function log(address p0, uint256 p1, bool p2) internal view {
  459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  460 |     |     }
  461 |     | 
  462 |     |     function log(address p0, uint256 p1, address p2) internal view {
  463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  464 |     |     }
  465 |     | 
  466 |     |     function log(address p0, string memory p1, uint256 p2) internal view {
  467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  468 |     |     }
  469 |     | 
  470 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  472 |     |     }
  473 |     | 
  474 |     |     function log(address p0, string memory p1, bool p2) internal view {
  475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  476 |     |     }
  477 |     | 
  478 |     |     function log(address p0, string memory p1, address p2) internal view {
  479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  480 |     |     }
  481 |     | 
  482 |     |     function log(address p0, bool p1, uint256 p2) internal view {
  483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  484 |     |     }
  485 |     | 
  486 |     |     function log(address p0, bool p1, string memory p2) internal view {
  487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  488 |     |     }
  489 |     | 
  490 |     |     function log(address p0, bool p1, bool p2) internal view {
  491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  492 |     |     }
  493 |     | 
  494 |     |     function log(address p0, bool p1, address p2) internal view {
  495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  496 |     |     }
  497 |     | 
  498 |     |     function log(address p0, address p1, uint256 p2) internal view {
  499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  500 |     |     }
  501 |     | 
  502 |     |     function log(address p0, address p1, string memory p2) internal view {
  503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  504 |     |     }
  505 |     | 
  506 |     |     function log(address p0, address p1, bool p2) internal view {
  507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  508 |     |     }
  509 |     | 
  510 |     |     function log(address p0, address p1, address p2) internal view {
  511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  512 |     |     }
  513 |     | 
  514 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  515 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  516 |     |     }
  517 |     | 
  518 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
  519 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  520 |     |     }
  521 |     | 
  522 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
  523 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  524 |     |     }
  525 |     | 
  526 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
  527 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  528 |     |     }
  529 |     | 
  530 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
  531 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  532 |     |     }
  533 |     | 
  534 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
  535 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  536 |     |     }
  537 |     | 
  538 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
  539 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  540 |     |     }
  541 |     | 
  542 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
  543 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  544 |     |     }
  545 |     | 
  546 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
  547 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  548 |     |     }
  549 |     | 
  550 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
  551 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  552 |     |     }
  553 |     | 
  554 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
  555 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  556 |     |     }
  557 |     | 
  558 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
  559 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  560 |     |     }
  561 |     | 
  562 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
  563 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  564 |     |     }
  565 |     | 
  566 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
  567 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  568 |     |     }
  569 |     | 
  570 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
  571 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  572 |     |     }
  573 |     | 
  574 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
  575 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  576 |     |     }
  577 |     | 
  578 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
  579 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  580 |     |     }
  581 |     | 
  582 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
  583 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  584 |     |     }
  585 |     | 
  586 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
  587 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  588 |     |     }
  589 |     | 
  590 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
  591 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  592 |     |     }
  593 |     | 
  594 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
  595 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  596 |     |     }
  597 |     | 
  598 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
  599 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  600 |     |     }
  601 |     | 
  602 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
  603 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  604 |     |     }
  605 |     | 
  606 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
  607 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  608 |     |     }
  609 |     | 
  610 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
  611 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  612 |     |     }
  613 |     | 
  614 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
  615 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  616 |     |     }
  617 |     | 
  618 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
  619 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  620 |     |     }
  621 |     | 
  622 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
  623 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  624 |     |     }
  625 |     | 
  626 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
  627 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  628 |     |     }
  629 |     | 
  630 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
  631 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  632 |     |     }
  633 |     | 
  634 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
  635 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  636 |     |     }
  637 |     | 
  638 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal view {
  639 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  640 |     |     }
  641 |     | 
  642 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
  643 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  644 |     |     }
  645 |     | 
  646 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
  647 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  648 |     |     }
  649 |     | 
  650 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
  651 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  652 |     |     }
  653 |     | 
  654 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
  655 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  656 |     |     }
  657 |     | 
  658 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
  659 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  660 |     |     }
  661 |     | 
  662 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
  663 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  664 |     |     }
  665 |     | 
  666 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
  667 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  668 |     |     }
  669 |     | 
  670 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
  671 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  672 |     |     }
  673 |     | 
  674 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
  675 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  676 |     |     }
  677 |     | 
  678 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
  679 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  680 |     |     }
  681 |     | 
  682 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
  683 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  684 |     |     }
  685 |     | 
  686 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal view {
  687 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  688 |     |     }
  689 |     | 
  690 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
  691 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  692 |     |     }
  693 |     | 
  694 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
  695 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  696 |     |     }
  697 |     | 
  698 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal view {
  699 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  700 |     |     }
  701 |     | 
  702 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal view {
  703 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  704 |     |     }
  705 |     | 
  706 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
  707 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  708 |     |     }
  709 |     | 
  710 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
  711 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  712 |     |     }
  713 |     | 
  714 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
  715 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  716 |     |     }
  717 |     | 
  718 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
  719 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  720 |     |     }
  721 |     | 
  722 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
  723 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  724 |     |     }
  725 |     | 
  726 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
  727 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  728 |     |     }
  729 |     | 
  730 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
  731 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  732 |     |     }
  733 |     | 
  734 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal view {
  735 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  736 |     |     }
  737 |     | 
  738 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
  739 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  740 |     |     }
  741 |     | 
  742 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
  743 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  744 |     |     }
  745 |     | 
  746 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal view {
  747 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  748 |     |     }
  749 |     | 
  750 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal view {
  751 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  752 |     |     }
  753 |     | 
  754 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
  755 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  756 |     |     }
  757 |     | 
  758 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal view {
  759 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  760 |     |     }
  761 |     | 
  762 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal view {
  763 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  764 |     |     }
  765 |     | 
  766 |     |     function log(uint256 p0, address p1, address p2, address p3) internal view {
  767 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  768 |     |     }
  769 |     | 
  770 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  771 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  772 |     |     }
  773 |     | 
  774 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
  775 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  776 |     |     }
  777 |     | 
  778 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
  779 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  780 |     |     }
  781 |     | 
  782 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
  783 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  784 |     |     }
  785 |     | 
  786 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
  787 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  788 |     |     }
  789 |     | 
  790 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
  791 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  792 |     |     }
  793 |     | 
  794 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
  795 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  796 |     |     }
  797 |     | 
  798 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
  799 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  800 |     |     }
  801 |     | 
  802 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
  803 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  804 |     |     }
  805 |     | 
  806 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
  807 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  808 |     |     }
  809 |     | 
  810 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
  811 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  812 |     |     }
  813 |     | 
  814 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
  815 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  816 |     |     }
  817 |     | 
  818 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
  819 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  820 |     |     }
  821 |     | 
  822 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
  823 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  824 |     |     }
  825 |     | 
  826 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
  827 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  828 |     |     }
  829 |     | 
  830 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal view {
  831 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  832 |     |     }
  833 |     | 
  834 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
  835 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  836 |     |     }
  837 |     | 
  838 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
  839 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  840 |     |     }
  841 |     | 
  842 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
  843 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  844 |     |     }
  845 |     | 
  846 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
  847 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  848 |     |     }
  849 |     | 
  850 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
  851 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  852 |     |     }
  853 |     | 
  854 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  855 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  856 |     |     }
  857 |     | 
  858 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  859 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  860 |     |     }
  861 |     | 
  862 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  863 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  864 |     |     }
  865 |     | 
  866 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
  867 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  868 |     |     }
  869 |     | 
  870 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  871 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  872 |     |     }
  873 |     | 
  874 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  875 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  876 |     |     }
  877 |     | 
  878 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  879 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  880 |     |     }
  881 |     | 
  882 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
  883 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  884 |     |     }
  885 |     | 
  886 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  887 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  888 |     |     }
  889 |     | 
  890 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  891 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  892 |     |     }
  893 |     | 
  894 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  895 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  896 |     |     }
  897 |     | 
  898 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
  899 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  900 |     |     }
  901 |     | 
  902 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
  903 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  904 |     |     }
  905 |     | 
  906 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
  907 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  908 |     |     }
  909 |     | 
  910 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
  911 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  912 |     |     }
  913 |     | 
  914 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
  915 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  916 |     |     }
  917 |     | 
  918 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  919 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  920 |     |     }
  921 |     | 
  922 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  923 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  924 |     |     }
  925 |     | 
  926 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  927 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  928 |     |     }
  929 |     | 
  930 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
  931 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  932 |     |     }
  933 |     | 
  934 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  935 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  936 |     |     }
  937 |     | 
  938 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  939 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  940 |     |     }
  941 |     | 
  942 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  943 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  944 |     |     }
  945 |     | 
  946 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
  947 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  948 |     |     }
  949 |     | 
  950 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  951 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  952 |     |     }
  953 |     | 
  954 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  955 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  956 |     |     }
  957 |     | 
  958 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  959 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  960 |     |     }
  961 |     | 
  962 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
  963 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  964 |     |     }
  965 |     | 
  966 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
  967 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  968 |     |     }
  969 |     | 
  970 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
  971 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  972 |     |     }
  973 |     | 
  974 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal view {
  975 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  976 |     |     }
  977 |     | 
  978 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
  979 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
  980 |     |     }
  981 |     | 
  982 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  983 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  984 |     |     }
  985 |     | 
  986 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  987 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  988 |     |     }
  989 |     | 
  990 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  991 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  992 |     |     }
  993 |     | 
  994 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
  995 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
  996 |     |     }
  997 |     | 
  998 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  999 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1000 |     |     }
 1001 |     | 
 1002 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
 1003 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1004 |     |     }
 1005 |     | 
 1006 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1007 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1008 |     |     }
 1009 |     | 
 1010 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal view {
 1011 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1012 |     |     }
 1013 |     | 
 1014 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1015 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1016 |     |     }
 1017 |     | 
 1018 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1019 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1020 |     |     }
 1021 |     | 
 1022 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1023 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1024 |     |     }
 1025 |     | 
 1026 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1027 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1028 |     |     }
 1029 |     | 
 1030 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1031 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1032 |     |     }
 1033 |     | 
 1034 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
 1035 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1036 |     |     }
 1037 |     | 
 1038 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
 1039 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1040 |     |     }
 1041 |     | 
 1042 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1043 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1044 |     |     }
 1045 |     | 
 1046 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
 1047 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1048 |     |     }
 1049 |     | 
 1050 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
 1051 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1052 |     |     }
 1053 |     | 
 1054 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
 1055 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1056 |     |     }
 1057 |     | 
 1058 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
 1059 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1060 |     |     }
 1061 |     | 
 1062 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
 1063 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1064 |     |     }
 1065 |     | 
 1066 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
 1067 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1068 |     |     }
 1069 |     | 
 1070 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal view {
 1071 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1072 |     |     }
 1073 |     | 
 1074 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
 1075 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1076 |     |     }
 1077 |     | 
 1078 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
 1079 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1080 |     |     }
 1081 |     | 
 1082 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal view {
 1083 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1084 |     |     }
 1085 |     | 
 1086 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal view {
 1087 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1088 |     |     }
 1089 |     | 
 1090 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1091 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1092 |     |     }
 1093 |     | 
 1094 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
 1095 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1096 |     |     }
 1097 |     | 
 1098 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
 1099 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1100 |     |     }
 1101 |     | 
 1102 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
 1103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1104 |     |     }
 1105 |     | 
 1106 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
 1107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1108 |     |     }
 1109 |     | 
 1110 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1112 |     |     }
 1113 |     | 
 1114 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1116 |     |     }
 1117 |     | 
 1118 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1120 |     |     }
 1121 |     | 
 1122 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
 1123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1124 |     |     }
 1125 |     | 
 1126 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1128 |     |     }
 1129 |     | 
 1130 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1132 |     |     }
 1133 |     | 
 1134 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1136 |     |     }
 1137 |     | 
 1138 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
 1139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1140 |     |     }
 1141 |     | 
 1142 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1144 |     |     }
 1145 |     | 
 1146 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1148 |     |     }
 1149 |     | 
 1150 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1152 |     |     }
 1153 |     | 
 1154 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
 1155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1156 |     |     }
 1157 |     | 
 1158 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
 1159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1160 |     |     }
 1161 |     | 
 1162 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
 1163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1164 |     |     }
 1165 |     | 
 1166 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal view {
 1167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1168 |     |     }
 1169 |     | 
 1170 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
 1171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1172 |     |     }
 1173 |     | 
 1174 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1176 |     |     }
 1177 |     | 
 1178 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1179 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1180 |     |     }
 1181 |     | 
 1182 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1183 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1184 |     |     }
 1185 |     | 
 1186 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
 1187 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1188 |     |     }
 1189 |     | 
 1190 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1192 |     |     }
 1193 |     | 
 1194 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1195 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1196 |     |     }
 1197 |     | 
 1198 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1199 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1200 |     |     }
 1201 |     | 
 1202 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal view {
 1203 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1204 |     |     }
 1205 |     | 
 1206 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1207 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1208 |     |     }
 1209 |     | 
 1210 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1211 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1212 |     |     }
 1213 |     | 
 1214 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1215 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1216 |     |     }
 1217 |     | 
 1218 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
 1219 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1220 |     |     }
 1221 |     | 
 1222 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
 1223 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1224 |     |     }
 1225 |     | 
 1226 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal view {
 1227 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1228 |     |     }
 1229 |     | 
 1230 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal view {
 1231 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1232 |     |     }
 1233 |     | 
 1234 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
 1235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1236 |     |     }
 1237 |     | 
 1238 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1240 |     |     }
 1241 |     | 
 1242 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1244 |     |     }
 1245 |     | 
 1246 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1248 |     |     }
 1249 |     | 
 1250 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal view {
 1251 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1252 |     |     }
 1253 |     | 
 1254 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1255 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1256 |     |     }
 1257 |     | 
 1258 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1259 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1260 |     |     }
 1261 |     | 
 1262 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1263 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1264 |     |     }
 1265 |     | 
 1266 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal view {
 1267 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1268 |     |     }
 1269 |     | 
 1270 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1271 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1272 |     |     }
 1273 |     | 
 1274 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1275 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1276 |     |     }
 1277 |     | 
 1278 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1279 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1280 |     |     }
 1281 |     | 
 1282 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1283 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1284 |     |     }
 1285 |     | 
 1286 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1287 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1288 |     |     }
 1289 |     | 
 1290 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
 1291 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1292 |     |     }
 1293 |     | 
 1294 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
 1295 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1296 |     |     }
 1297 |     | 
 1298 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1299 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1300 |     |     }
 1301 |     | 
 1302 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
 1303 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1304 |     |     }
 1305 |     | 
 1306 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
 1307 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1308 |     |     }
 1309 |     | 
 1310 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal view {
 1311 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1312 |     |     }
 1313 |     | 
 1314 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
 1315 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1316 |     |     }
 1317 |     | 
 1318 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
 1319 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1320 |     |     }
 1321 |     | 
 1322 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal view {
 1323 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1324 |     |     }
 1325 |     | 
 1326 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal view {
 1327 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1328 |     |     }
 1329 |     | 
 1330 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
 1331 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1332 |     |     }
 1333 |     | 
 1334 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal view {
 1335 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1336 |     |     }
 1337 |     | 
 1338 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal view {
 1339 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1340 |     |     }
 1341 |     | 
 1342 |     |     function log(address p0, uint256 p1, address p2, address p3) internal view {
 1343 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1344 |     |     }
 1345 |     | 
 1346 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1347 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1348 |     |     }
 1349 |     | 
 1350 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
 1351 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1352 |     |     }
 1353 |     | 
 1354 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
 1355 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1356 |     |     }
 1357 |     | 
 1358 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal view {
 1359 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1360 |     |     }
 1361 |     | 
 1362 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
 1363 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1364 |     |     }
 1365 |     | 
 1366 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1367 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1368 |     |     }
 1369 |     | 
 1370 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1371 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1372 |     |     }
 1373 |     | 
 1374 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1375 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1376 |     |     }
 1377 |     | 
 1378 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
 1379 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1380 |     |     }
 1381 |     | 
 1382 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1383 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1384 |     |     }
 1385 |     | 
 1386 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1387 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1388 |     |     }
 1389 |     | 
 1390 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1391 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1392 |     |     }
 1393 |     | 
 1394 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal view {
 1395 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1396 |     |     }
 1397 |     | 
 1398 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1399 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1400 |     |     }
 1401 |     | 
 1402 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1403 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1404 |     |     }
 1405 |     | 
 1406 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1407 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1408 |     |     }
 1409 |     | 
 1410 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
 1411 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1412 |     |     }
 1413 |     | 
 1414 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
 1415 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1416 |     |     }
 1417 |     | 
 1418 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal view {
 1419 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1420 |     |     }
 1421 |     | 
 1422 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal view {
 1423 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1424 |     |     }
 1425 |     | 
 1426 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
 1427 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1428 |     |     }
 1429 |     | 
 1430 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1431 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1432 |     |     }
 1433 |     | 
 1434 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1435 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1436 |     |     }
 1437 |     | 
 1438 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1439 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1440 |     |     }
 1441 |     | 
 1442 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal view {
 1443 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1444 |     |     }
 1445 |     | 
 1446 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1447 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1448 |     |     }
 1449 |     | 
 1450 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1451 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1452 |     |     }
 1453 |     | 
 1454 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1455 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1456 |     |     }
 1457 |     | 
 1458 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal view {
 1459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1460 |     |     }
 1461 |     | 
 1462 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1464 |     |     }
 1465 |     | 
 1466 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1468 |     |     }
 1469 |     | 
 1470 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1472 |     |     }
 1473 |     | 
 1474 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
 1475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1476 |     |     }
 1477 |     | 
 1478 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal view {
 1479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1480 |     |     }
 1481 |     | 
 1482 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal view {
 1483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1484 |     |     }
 1485 |     | 
 1486 |     |     function log(address p0, address p1, uint256 p2, address p3) internal view {
 1487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1488 |     |     }
 1489 |     | 
 1490 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal view {
 1491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1492 |     |     }
 1493 |     | 
 1494 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1496 |     |     }
 1497 |     | 
 1498 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1500 |     |     }
 1501 |     | 
 1502 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1504 |     |     }
 1505 |     | 
 1506 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal view {
 1507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1508 |     |     }
 1509 |     | 
 1510 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1512 |     |     }
 1513 |     | 
 1514 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1516 |     |     }
 1517 |     | 
 1518 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1520 |     |     }
 1521 |     | 
 1522 |     |     function log(address p0, address p1, address p2, uint256 p3) internal view {
 1523 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1524 |     |     }
 1525 |     | 
 1526 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1527 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1528 |     |     }
 1529 |     | 
 1530 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1531 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1532 |     |     }
 1533 |     | 
 1534 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1535 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1536 |     |     }
 1537 |     | 
 1538 |     | }

