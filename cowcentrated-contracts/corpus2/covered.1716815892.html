<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/EchidnaTest2.sol</b>
<code>
  1 |     | <span class='unexecuted'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// import {Test, console} from &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Setup2} from &quot;./Setup2.sol&quot;;</span>
  6 |     | <span class='neutral'>import {CustomActor} from &quot;./test/crytic/CustomActor.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./test/crytic/Hevm.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;./test/crytic/VeldromeLiquidityProvider.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;forge-std/console.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>// Test ETH/USDT Uniswap Strategy. Large decimal token0 and small decimal token1;</span>
 14 | *   | <span class='executed'>contract  EchidnaTest2 is Setup2 {</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    CustomActor normalUser;</span>
 17 |     | <span class='neutral'>    CustomActor attacker;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    bool isSetupCompleted;</span>
 20 |     | <span class='neutral'>    VelodromeLiquidityProvider lpProvider;</span>
 21 | *   | <span class='executed'>    function initialize() public{</span>
 22 | *   | <span class='executed'>        if (!isSetupCompleted)</span>
 23 |     | <span class='neutral'>        {</span>
 24 | *   | <span class='executed'>            setUp();</span>
 25 |     | <span class='unexecuted'>            normalUser = new  CustomActor();</span>
 26 |     | <span class='unexecuted'>            attacker = new CustomActor();</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>            //assigning some extra tokens to users</span>
 29 |     | <span class='neutral'>            ERC20 token0Token = ERC20(token0);</span>
 30 |     | <span class='neutral'>            ERC20 token1Token = ERC20(token1);</span>
 31 |     | <span class='neutral'>            ERC20 nativeToken = ERC20(native);</span>
 32 |     | <span class='neutral'>            </span>
 33 |     | <span class='unexecuted'>            address token0Owner  = Ownable(token0).owner();</span>
 34 |     | <span class='unexecuted'>            address token1Owner  = Ownable(token1).owner();</span>
 35 |     | <span class='unexecuted'>            address nativeOwner  = Ownable(native).owner();</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>            //giving some extra tokens to our attacker</span>
 38 |     | <span class='unexecuted'>            hevm.prank(token0Owner);</span>
 39 |     | <span class='unexecuted'>            token0Token.transfer(address(attacker),1000000*10**token0Token.decimals());</span>
 40 |     | <span class='unexecuted'>            hevm.prank(token1Owner);</span>
 41 |     | <span class='unexecuted'>            token1Token.transfer(address(attacker),1000000*10**token1Token.decimals());</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>            //the following transfer is not needed as the native token is the same as token1</span>
 44 |     | <span class='neutral'>            // hevm.prank(nativeOwner);</span>
 45 |     | <span class='neutral'>            // nativeToken.mint(address(attacker),1000000*10**nativeToken.decimals());</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>            </span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>            //veldrome lp</span>
 50 |     | <span class='unexecuted'>            lpProvider = new VelodromeLiquidityProvider(unirouter,token0,token1,false);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>            isSetupCompleted=true;</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>        </span>
 57 |     | <span class='neutral'>    }</span>
 58 | *   | <span class='executed'>    function testCalmPeriods(uint deposit0,uint deposit1) external {</span>
 59 | *   | <span class='executed'>        console.log(&quot;[+] Testing calm periods. &quot;);</span>
 60 | *   | <span class='executed'>        if(!isSetupCompleted)setUp();</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>        //get current price</span>
 63 |     | <span class='unexecuted'>        uint currentPrice = strategy.price();</span>
 64 |     | <span class='unexecuted'>        console.log(&quot;Price before... &quot;,currentPrice);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        attacker.proxy(address(lpProvider),abi.encodeWithSelector(lpProvider.deposit.selector,deposit0,deposit1,deposit0,deposit1,address(attacker),block.timestamp));</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>        uint newPrice = strategy.price();</span>
 69 |     | <span class='unexecuted'>        console.log(&quot;Price after... &quot;,newPrice);</span>
 70 |     | <span class='neutral'>        </span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>        </span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'>    </span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/Setup2.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;@openzeppelin-4/contracts/token/ERC20/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SafeERC20} from &quot;@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BeefyVaultConcLiq} from &quot;contracts/vault/BeefyVaultConcLiq.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BeefyVaultConcLiqFactory} from &quot;contracts/vault/BeefyVaultConcLiqFactory.sol&quot;;</span>
   8 |     | <span class='neutral'>import {StrategyPassiveManagerVelodrome} from &quot;contracts/strategies/velodrome/StrategyPassiveManagerVelodrome.sol&quot;;</span>
   9 |     | <span class='neutral'>import {StrategyFactory} from &quot;contracts/strategies/StrategyFactory.sol&quot;;</span>
  10 |     | <span class='neutral'>import {BeefyRewardPoolFactory} from &quot;contracts/rewardpool/BeefyRewardPoolFactory.sol&quot;;</span>
  11 |     | <span class='neutral'>import {BeefyRewardPool} from &quot;contracts/rewardpool/BeefyRewardPool.sol&quot;;</span>
  12 |     | <span class='neutral'>import {StratFeeManagerInitializable} from &quot;contracts/strategies/StratFeeManagerInitializable.sol&quot;;</span>
  13 |     | <span class='neutral'>import {IStrategyConcLiq} from &quot;contracts/interfaces/beefy/IStrategyConcLiq.sol&quot;;</span>
  14 |     | <span class='neutral'>import {VeloSwapUtils} from &quot;contracts/utils/VeloSwapUtils.sol&quot;;</span>
  15 |     | <span class='neutral'>import {IVeloPool} from &quot;contracts/interfaces/velodrome/IVeloPool.sol&quot;;</span>
  16 |     | <span class='neutral'>import {IVeloRouter} from &quot;contracts/interfaces/velodrome/IVeloRouter.sol&quot;;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>contract Setup2 {</span>
  19 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    BeefyVaultConcLiq vault;</span>
  22 |     | <span class='neutral'>    BeefyVaultConcLiqFactory vaultFactory;</span>
  23 |     | <span class='neutral'>    StrategyPassiveManagerVelodrome strategy;</span>
  24 |     | <span class='neutral'>    StrategyPassiveManagerVelodrome implementation;</span>
  25 |     | <span class='neutral'>    BeefyRewardPoolFactory rewardPoolFactory;</span>
  26 |     | <span class='neutral'>    BeefyRewardPool rewardPool;</span>
  27 |     | <span class='neutral'>    StrategyFactory factory;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'></span>
  30 | *   | <span class='executed'>    address constant pool = 0x3241738149B24C9164dA14Fa2040159FFC6Dd237;</span>
  31 | *   | <span class='executed'>    address constant gauge = 0x8d8d1CdDD5960276A1CDE360e7b5D210C3387948;</span>
  32 | *   | <span class='executed'>    address constant nftManager = 0xbB5DFE1380333CEE4c2EeBd7202c80dE2256AdF4;</span>
  33 | *   | <span class='executed'>    address constant token0 = 0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85;</span>
  34 |     | <span class='unexecuted'>    address constant token1 = 0x4200000000000000000000000000000000000006;</span>
  35 |     | <span class='neutral'>    address constant native = 0x4200000000000000000000000000000000000006;</span>
  36 | *   | <span class='executed'>    address constant output = 0x9560e827aF36c94D2Ac33a39bCE1Fe78631088Db;</span>
  37 | *   | <span class='executed'>    address constant strategist = 0xb2e4A61D99cA58fB8aaC58Bb2F8A59d63f552fC0;</span>
  38 | *   | <span class='executed'>    address constant beefyFeeRecipient = 0x02Ae4716B9D5d48Db1445814b0eDE39f5c28264B;</span>
  39 | *   | <span class='executed'>    address constant beefyFeeConfig = 0x216EEE15D1e3fAAD34181f66dd0B665f556a638d;</span>
  40 | *   | <span class='executed'>    address constant unirouter = 0xF132bdb9573867cD72f2585C338B923F973EB817;</span>
  41 | *   | <span class='executed'>    address constant quoter = 0xA2DEcF05c16537C702779083Fe067e308463CE45;</span>
  42 | *   | <span class='executed'>    address constant keeper = 0x4fED5491693007f0CD49f4614FFC38Ab6A04B619;</span>
  43 | *   | <span class='executed'>    int24 constant width = 500;</span>
  44 |     | <span class='neutral'>    address constant user = 0x161D61e30284A33Ab1ed227beDcac6014877B3DE;</span>
  45 |     | <span class='unexecuted'>    uint token0Size = 4000e6;</span>
  46 |     | <span class='unexecuted'>    uint token1Size = 1 ether;</span>
  47 |     | <span class='neutral'>    bytes rewardPath;</span>
  48 |     | <span class='neutral'>    bytes tradePath;</span>
  49 |     | <span class='neutral'>    bytes path0;</span>
  50 |     | <span class='neutral'>    bytes path1;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    error NotManager();</span>
  53 |     | <span class='neutral'>    error NotCalm();</span>
  54 |     | <span class='neutral'>    error NotVault();</span>
  55 |     | <span class='neutral'>    error StrategyPaused();</span>
  56 |     | <span class='neutral'>    error NoOutputBal();</span>
  57 |     | <span class='neutral'></span>
  58 | *   | <span class='executed'>    function setUp() virtual public {</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // Deploy Contracts</span>
  62 | *   | <span class='executed'>        BeefyVaultConcLiq vaultImplementation = new BeefyVaultConcLiq();</span>
  63 | *   | <span class='executed'>        vaultFactory = new BeefyVaultConcLiqFactory(address(vaultImplementation));</span>
  64 | *   | <span class='executed'>        vault = vaultFactory.cloneVault();</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>        implementation = new StrategyPassiveManagerVelodrome();</span>
  67 | *   | <span class='executed'>        factory = new StrategyFactory(native, keeper, beefyFeeRecipient, beefyFeeConfig);</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>        BeefyRewardPool rewardPoolImplementation = new BeefyRewardPool();</span>
  70 | *   | <span class='executed'>        rewardPoolFactory = new BeefyRewardPoolFactory(address(rewardPoolImplementation));</span>
  71 | *   | <span class='executed'>        rewardPool = rewardPoolFactory.cloneRewardPool();</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>        rewardPool.initialize(address(vault), &quot;rCowVeloETH-USDC&quot;, &quot;rCowVeloETH-USDC&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // Set up routing for trade paths</span>
  76 | *   | <span class='executed'>        address[] memory lpToken0ToNative = new address[](2);</span>
  77 | *   | <span class='executed'>        lpToken0ToNative[0] = address(token0);</span>
  78 | *   | <span class='executed'>        lpToken0ToNative[1] = native;</span>
  79 |     | <span class='neutral'></span>
  80 | *   | <span class='executed'>        address[] memory lpToken1ToNative = new address[](2);</span>
  81 | *   | <span class='executed'>        lpToken1ToNative[0] = token1;</span>
  82 | *   | <span class='executed'>        lpToken1ToNative[1] = native;</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        address[] memory tradeRoute = new address[](2);</span>
  85 | *   | <span class='executed'>        tradeRoute[0] = native;</span>
  86 | *   | <span class='executed'>        tradeRoute[1] = token0;</span>
  87 |     | <span class='neutral'></span>
  88 | *   | <span class='executed'>        address[] memory rewardRoute = new address[](2);</span>
  89 | *   | <span class='executed'>        rewardRoute[0] = output;</span>
  90 | *   | <span class='executed'>        rewardRoute[1] = native;</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>        uint24[] memory spacing = new uint24[](1);</span>
  93 | *   | <span class='executed'>        spacing[0] = 100;</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>        uint24[] memory veloSpacing = new uint24[](1);</span>
  96 | *   | <span class='executed'>        veloSpacing[0] = 200;</span>
  97 |     | <span class='neutral'></span>
  98 | *   | <span class='executed'>        rewardPath = routeToPath(rewardRoute, veloSpacing);</span>
  99 | *   | <span class='executed'>        path0 = routeToPath(lpToken0ToNative, spacing);</span>
 100 | *   | <span class='executed'>        path1 = &quot;0x&quot;; //routeToPath(lpToken1ToNative, fees);</span>
 101 | *   | <span class='executed'>        tradePath = routeToPath(tradeRoute, spacing);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        // Init the strategy and vault</span>
 104 | *   | <span class='executed'>        StratFeeManagerInitializable.CommonAddresses memory commonAddresses = StratFeeManagerInitializable.CommonAddresses(</span>
 105 | *   | <span class='executed'>            address(vault),</span>
 106 |     | <span class='neutral'>            unirouter,</span>
 107 |     | <span class='neutral'>            strategist,</span>
 108 | *   | <span class='executed'>            address(factory)</span>
 109 |     | <span class='neutral'>        );</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>        factory.addStrategy(&quot;StrategyPassiveManagerVelodrome_v1&quot;, address(implementation));</span>
 112 |     | <span class='neutral'></span>
 113 | *   | <span class='executed'>        bytes[] memory paths = new bytes[](3);</span>
 114 | *   | <span class='executed'>        paths[0] = rewardPath;</span>
 115 | *   | <span class='executed'>        paths[1] = path0;</span>
 116 | *   | <span class='executed'>        paths[2] = path1;</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>        address _strategy = factory.createStrategy(&quot;StrategyPassiveManagerVelodrome_v1&quot;);</span>
 119 | *   | <span class='executed'>        strategy = StrategyPassiveManagerVelodrome(_strategy);</span>
 120 | *r  | <span class='executed'>        strategy.initialize(pool, quoter, nftManager, gauge, address(rewardPool), output, width, paths, commonAddresses);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        rewardPool.setWhitelist(address(strategy), true);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        vault.initialize(address(strategy), &quot;Moo Vault&quot;, &quot;mooVault&quot;);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        strategy.setDeviation(100);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        address _want = vault.want();</span>
 129 |     | <span class='unexecuted'>        assert(_want == pool);</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        address[] memory outputRoute = strategy.outputToNative();</span>
 132 |     | <span class='unexecuted'>        assert(outputRoute.length == 2);</span>
 133 |     | <span class='unexecuted'>        assert(outputRoute[0] == output);</span>
 134 |     | <span class='unexecuted'>        assert(outputRoute[1] == native);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 | *   | <span class='executed'>    function routeToPath(address[] memory _route, uint24[] memory _fee) internal pure returns (bytes memory path) {</span>
 138 | *   | <span class='executed'>        path = abi.encodePacked(_route[0]);</span>
 139 | *   | <span class='executed'>        uint256 feeLength = _fee.length;</span>
 140 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; feeLength; i++) {</span>
 141 | *   | <span class='executed'>            path = abi.encodePacked(path, _fee[i], _route[i + 1]);</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'>}</span>
 145 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IBeefyVaultConcLiq.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IBeefyVaultConcLiq {</span>
  5 |     | <span class='neutral'>    function previewDeposit(uint256 _amount0, uint256 _amount1) external view returns (uint256 shares);</span>
  6 |     | <span class='neutral'>    function previewWithdraw(uint256 shares) external view returns (uint256 amount0, uint256 amount1);</span>
  7 |     | <span class='neutral'>    function strategy() external view returns (address);</span>
  8 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IFeeConfig.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IFeeConfig {</span>
  5 |     | <span class='neutral'>    struct FeeCategory {</span>
  6 |     | <span class='neutral'>        uint256 total;</span>
  7 |     | <span class='neutral'>        uint256 beefy; //audit-info What is this variable ? @mody. percentage for beefy from the fees</span>
  8 |     | <span class='neutral'>        uint256 call;</span>
  9 |     | <span class='neutral'>        uint256 strategist;</span>
 10 |     | <span class='neutral'>        string label;</span>
 11 |     | <span class='neutral'>        bool active;</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>    struct AllFees {</span>
 14 |     | <span class='neutral'>        FeeCategory performance;</span>
 15 |     | <span class='neutral'>        uint256 deposit;</span>
 16 |     | <span class='neutral'>        uint256 withdraw;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>    function getFees(address strategy) external view returns (FeeCategory memory);</span>
 19 |     | <span class='neutral'>    function stratFeeId(address strategy) external view returns (uint256);</span>
 20 |     | <span class='neutral'>    function setStratFeeId(uint256 feeId) external;</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IRewardPool.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IRewardPool {</span>
 5 |     | <span class='neutral'>    function notifyRewardAmount(address token, uint256 reward, uint256 duration) external;</span>
 6 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IStrategyConcLiq.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IStrategyConcLiq {</span>
  5 |     | <span class='neutral'>    function balances() external view returns (uint256, uint256);</span>
  6 |     | <span class='neutral'>    function beforeAction() external;</span>
  7 |     | <span class='neutral'>    function deposit() external;</span>
  8 |     | <span class='neutral'>    function withdraw(uint256 _amount0, uint256 _amount1) external;</span>
  9 |     | <span class='neutral'>    function pool() external view returns (address);</span>
 10 |     | <span class='neutral'>    function lpToken0() external view returns (address);</span>
 11 |     | <span class='neutral'>    function lpToken1() external view returns (address);</span>
 12 |     | <span class='neutral'>    function isCalm() external view returns (bool);</span>
 13 |     | <span class='neutral'>    </span>
 14 |     | <span class='neutral'>    /// @notice The current price of the pool in token1, encoded with 36 decimals.</span>
 15 |     | <span class='neutral'>    /// @return _price The current price of the pool in token1.</span>
 16 |     | <span class='neutral'>    function price() external view returns (uint256 _price);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IStrategyFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IStrategyFactory {</span>
  5 |     | <span class='neutral'>    function native() external view returns (address);</span>
  6 |     | <span class='neutral'>    function globalPause() external view returns (bool);</span>
  7 |     | <span class='neutral'>    function keeper() external view returns (address);</span>
  8 |     | <span class='neutral'>    function beefyFeeRecipient() external view returns (address); //audit-info What is that ?</span>
  9 |     | <span class='neutral'>    function beefyFeeConfig() external view returns (address);    //audit-info What is that ? </span>
 10 |     | <span class='neutral'>    function rebalancers(address) external view returns (bool);   //audit-info What is that ?</span>
 11 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/beefy/IStrategyVelodrome.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Interface for the Uniswap V3 strategy contract.</span>
  5 |     | <span class='neutral'>interface IStrategyVelodrome {</span>
  6 |     | <span class='neutral'>    /// @notice The sqrt price of the pool.</span>
  7 |     | <span class='neutral'>    function sqrtPrice() external view returns (uint160 sqrtPriceX96);</span>
  8 |     | <span class='neutral'>    </span>
  9 |     | <span class='neutral'>    /// @notice The range covered by the strategy.</span>
 10 |     | <span class='neutral'>    function range() external view returns (uint256 lowerPrice, uint256 upperPrice);</span>
 11 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/uniswap/IQuoter.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.23;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IQuoter {</span>
 5 |     | <span class='neutral'>    function quoteExactInput(bytes memory path, uint amountIn) external returns (uint amountOut);</span>
 6 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/uniswap/IUniswapRouterV3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IUniswapRouterV3 {</span>
  7 |     | <span class='neutral'>    struct ExactInputSingleParams {</span>
  8 |     | <span class='neutral'>        address tokenIn;</span>
  9 |     | <span class='neutral'>        address tokenOut;</span>
 10 |     | <span class='neutral'>        uint24 fee;</span>
 11 |     | <span class='neutral'>        address recipient;</span>
 12 |     | <span class='neutral'>        uint256 amountIn;</span>
 13 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 14 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another token</span>
 18 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata</span>
 19 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 20 |     | <span class='neutral'>    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    struct ExactInputParams {</span>
 23 |     | <span class='neutral'>        bytes path;</span>
 24 |     | <span class='neutral'>        address recipient;</span>
 25 |     | <span class='neutral'>        uint256 amountIn;</span>
 26 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path</span>
 30 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata</span>
 31 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 32 |     | <span class='neutral'>    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    struct ExactOutputSingleParams {</span>
 35 |     | <span class='neutral'>        address tokenIn;</span>
 36 |     | <span class='neutral'>        address tokenOut;</span>
 37 |     | <span class='neutral'>        uint24 fee;</span>
 38 |     | <span class='neutral'>        address recipient;</span>
 39 |     | <span class='neutral'>        uint256 amountOut;</span>
 40 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 41 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another token</span>
 45 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata</span>
 46 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 47 |     | <span class='neutral'>    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    struct ExactOutputParams {</span>
 50 |     | <span class='neutral'>        bytes path;</span>
 51 |     | <span class='neutral'>        address recipient;</span>
 52 |     | <span class='neutral'>        uint256 amountOut;</span>
 53 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)</span>
 57 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata</span>
 58 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 59 |     | <span class='neutral'>    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);</span>
 60 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/ICLGauge.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface ICLGauge {</span>
   5 |     | <span class='neutral'>    /// @notice NonfungiblePositionManager used to create nfts this gauge accepts</span>
   6 |     | <span class='neutral'>    function nft() external view returns (address);</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    /// @notice Voter contract gauge receives emissions from</span>
   9 |     | <span class='neutral'>    function voter() external view returns (address);</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    /// @notice Address of the CL pool linked to the gauge</span>
  12 |     | <span class='neutral'>    function pool() external view returns (address);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Address of the factory that created this gauge</span>
  15 |     | <span class='neutral'>    function gaugeFactory() external view returns (address);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Address of the FeesVotingReward contract linked to the gauge</span>
  18 |     | <span class='neutral'>    function feesVotingReward() external view returns (address);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /// @notice Timestamp end of current rewards period</span>
  21 |     | <span class='neutral'>    function periodFinish() external view returns (uint256);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice Current reward rate of rewardToken to distribute per second</span>
  24 |     | <span class='neutral'>    function rewardRate() external view returns (uint256);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice Claimable rewards by tokenId</span>
  27 |     | <span class='neutral'>    function rewards(uint256 tokenId) external view returns (uint256);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /// @notice Most recent timestamp tokenId called updateRewards</span>
  30 |     | <span class='neutral'>    function lastUpdateTime(uint256 tokenId) external view returns (uint256);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice View to see the rewardRate given the timestamp of the start of the epoch</span>
  33 |     | <span class='neutral'>    function rewardRateByEpoch(uint256) external view returns (uint256);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice Cached amount of fees generated from the Pool linked to the Gauge of token0</span>
  36 |     | <span class='neutral'>    function fees0() external view returns (uint256);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice Cached amount of fees generated from the Pool linked to the Gauge of token1</span>
  39 |     | <span class='neutral'>    function fees1() external view returns (uint256);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Cached address of token0, corresponding to token0 of the pool</span>
  42 |     | <span class='neutral'>    function token0() external view returns (address);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /// @notice Cached address of token1, corresponding to token1 of the pool</span>
  45 |     | <span class='neutral'>    function token1() external view returns (address);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Cached tick spacing of the pool.</span>
  48 |     | <span class='neutral'>    function tickSpacing() external view returns (int24);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Total amount of rewardToken to distribute for the current rewards period</span>
  51 |     | <span class='neutral'>    function left() external view returns (uint256 _left);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /// @notice Address of the emissions token</span>
  54 |     | <span class='neutral'>    function rewardToken() external view returns (address);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @notice To provide compatibility support with the old voter</span>
  57 |     | <span class='neutral'>    function isPool() external view returns (bool);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice Returns the rewardGrowthInside of the position at the last user action (deposit, withdraw, getReward)</span>
  60 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
  61 |     | <span class='neutral'>    /// @return The rewardGrowthInside for the position</span>
  62 |     | <span class='neutral'>    function rewardGrowthInside(uint256 tokenId) external view returns (uint256);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice Called on gauge creation by CLGaugeFactory</span>
  65 |     | <span class='neutral'>    /// @param _pool The address of the pool</span>
  66 |     | <span class='neutral'>    /// @param _feesVotingReward The address of the feesVotingReward contract</span>
  67 |     | <span class='neutral'>    /// @param _rewardToken The address of the reward token</span>
  68 |     | <span class='neutral'>    /// @param _voter The address of the voter contract</span>
  69 |     | <span class='neutral'>    /// @param _nft The address of the nft position manager contract</span>
  70 |     | <span class='neutral'>    /// @param _token0 The address of token0 of the pool</span>
  71 |     | <span class='neutral'>    /// @param _token1 The address of token1 of the pool</span>
  72 |     | <span class='neutral'>    /// @param _tickSpacing The tick spacing of the pool</span>
  73 |     | <span class='neutral'>    /// @param _isPool Whether the attached pool is a real pool or not</span>
  74 |     | <span class='neutral'>    function initialize(</span>
  75 |     | <span class='neutral'>        address _pool,</span>
  76 |     | <span class='neutral'>        address _feesVotingReward,</span>
  77 |     | <span class='neutral'>        address _rewardToken,</span>
  78 |     | <span class='neutral'>        address _voter,</span>
  79 |     | <span class='neutral'>        address _nft,</span>
  80 |     | <span class='neutral'>        address _token0,</span>
  81 |     | <span class='neutral'>        address _token1,</span>
  82 |     | <span class='neutral'>        int24 _tickSpacing,</span>
  83 |     | <span class='neutral'>        bool _isPool</span>
  84 |     | <span class='neutral'>    ) external;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @notice Returns the claimable rewards for a given account and tokenId</span>
  87 |     | <span class='neutral'>    /// @dev Throws if account is not the position owner</span>
  88 |     | <span class='neutral'>    /// @dev pool.updateRewardsGrowthGlobal() needs to be called first, to return the correct claimable rewards</span>
  89 |     | <span class='neutral'>    /// @param account The address of the user</span>
  90 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
  91 |     | <span class='neutral'>    /// @return The amount of claimable reward</span>
  92 |     | <span class='neutral'>    function earned(address account, uint256 tokenId) external view returns (uint256);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /// @notice Retrieve rewards for all tokens owned by an account</span>
  95 |     | <span class='neutral'>    /// @dev Throws if not called by the voter</span>
  96 |     | <span class='neutral'>    /// @param account The account of the user</span>
  97 |     | <span class='neutral'>    function getReward(address account) external;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Retrieve rewards for a tokenId</span>
 100 |     | <span class='neutral'>    /// @dev Throws if not called by the position owner</span>
 101 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
 102 |     | <span class='neutral'>    function getReward(uint256 tokenId) external;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @notice Notifies gauge of gauge rewards.</span>
 105 |     | <span class='neutral'>    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.</span>
 106 |     | <span class='neutral'>    function notifyRewardAmount(uint256 amount) external;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @dev Notifies gauge of gauge rewards without distributing its fees.</span>
 109 |     | <span class='neutral'>    ///      Assumes gauge reward tokens is 18 decimals.</span>
 110 |     | <span class='neutral'>    ///      If not 18 decimals, rewardRate may have rounding issues.</span>
 111 |     | <span class='neutral'>    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.</span>
 112 |     | <span class='neutral'>    function notifyRewardWithoutClaim(uint256 amount) external;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /// @notice Used to deposit a CL position into the gauge</span>
 115 |     | <span class='neutral'>    /// @notice Allows the user to receive emissions instead of fees</span>
 116 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
 117 |     | <span class='neutral'>    function deposit(uint256 tokenId) external;</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /// @notice Used to withdraw a CL position from the gauge</span>
 120 |     | <span class='neutral'>    /// @notice Allows the user to receive fees instead of emissions</span>
 121 |     | <span class='neutral'>    /// @notice Outstanding emissions will be collected on withdrawal</span>
 122 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
 123 |     | <span class='neutral'>    function withdraw(uint256 tokenId) external;</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /// @notice Used to increase liquidity of a staked position</span>
 126 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
 127 |     | <span class='neutral'>    /// @param amount0Desired The desired amount of token0 to be staked,</span>
 128 |     | <span class='neutral'>    /// @param amount1Desired The desired amount of token1 to be staked,</span>
 129 |     | <span class='neutral'>    /// @param amount0Min The minimum amount of token0 to spend, which serves as a slippage check,</span>
 130 |     | <span class='neutral'>    /// @param amount1Min The minimum amount of token1 to spend, which serves as a slippage check,</span>
 131 |     | <span class='neutral'>    /// @param deadline The time by which the transaction must be included to effect the change</span>
 132 |     | <span class='neutral'>    /// @return liquidity The new liquidity amount as a result of the increase</span>
 133 |     | <span class='neutral'>    /// @return amount0 The amount of token0 required to obtain new liquidity amount</span>
 134 |     | <span class='neutral'>    /// @return amount1 The amount of token1 required to obtain new liquidity amount</span>
 135 |     | <span class='neutral'>    function increaseStakedLiquidity(</span>
 136 |     | <span class='neutral'>        uint256 tokenId,</span>
 137 |     | <span class='neutral'>        uint256 amount0Desired,</span>
 138 |     | <span class='neutral'>        uint256 amount1Desired,</span>
 139 |     | <span class='neutral'>        uint256 amount0Min,</span>
 140 |     | <span class='neutral'>        uint256 amount1Min,</span>
 141 |     | <span class='neutral'>        uint256 deadline</span>
 142 |     | <span class='neutral'>    ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @notice Used to decrease liquidity of a staked position</span>
 145 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
 146 |     | <span class='neutral'>    /// @param liquidity The amount of liquidity to be unstaked from the gauge</span>
 147 |     | <span class='neutral'>    /// @param amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,</span>
 148 |     | <span class='neutral'>    /// @param amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,</span>
 149 |     | <span class='neutral'>    /// @param deadline The time by which the transaction must be included to effect the change</span>
 150 |     | <span class='neutral'>    /// @return amount0 The amount of token0 decreased from position</span>
 151 |     | <span class='neutral'>    /// @return amount1 The amount of token1 decreased from position</span>
 152 |     | <span class='neutral'>    function decreaseStakedLiquidity(</span>
 153 |     | <span class='neutral'>        uint256 tokenId,</span>
 154 |     | <span class='neutral'>        uint128 liquidity,</span>
 155 |     | <span class='neutral'>        uint256 amount0Min,</span>
 156 |     | <span class='neutral'>        uint256 amount1Min,</span>
 157 |     | <span class='neutral'>        uint256 deadline</span>
 158 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /// @notice Fetch all tokenIds staked by a given account</span>
 161 |     | <span class='neutral'>    /// @param depositor The address of the user</span>
 162 |     | <span class='neutral'>    /// @return The tokenIds of the staked positions</span>
 163 |     | <span class='neutral'>    function stakedValues(address depositor) external view returns (uint256[] memory);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /// @notice Fetch a staked tokenId by index</span>
 166 |     | <span class='neutral'>    /// @param depositor The address of the user</span>
 167 |     | <span class='neutral'>    /// @param index The index of the staked tokenId</span>
 168 |     | <span class='neutral'>    /// @return The tokenId of the staked position</span>
 169 |     | <span class='neutral'>    function stakedByIndex(address depositor, uint256 index) external view returns (uint256);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    /// @notice Check whether a position is staked in the gauge by a certain user</span>
 172 |     | <span class='neutral'>    /// @param depositor The address of the user</span>
 173 |     | <span class='neutral'>    /// @param tokenId The tokenId of the position</span>
 174 |     | <span class='neutral'>    /// @return Whether the position is staked in the gauge</span>
 175 |     | <span class='neutral'>    function stakedContains(address depositor, uint256 tokenId) external view returns (bool);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    /// @notice The amount of positions staked in the gauge by a certain user</span>
 178 |     | <span class='neutral'>    /// @param depositor The address of the user</span>
 179 |     | <span class='neutral'>    /// @return The amount of positions staked in the gauge</span>
 180 |     | <span class='neutral'>    function stakedLength(address depositor) external view returns (uint256);</span>
 181 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/INftPositionManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Non-fungible token for positions</span>
   5 |     | <span class='neutral'>/// @notice Wraps CL positions in a non-fungible token interface which allows for them to be transferred</span>
   6 |     | <span class='neutral'>/// and authorized.</span>
   7 |     | <span class='neutral'>interface INftPositionManager {</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    /// @notice Returns the position information associated with a given token ID.</span>
  10 |     | <span class='neutral'>    /// @dev Throws if the token ID is not valid.</span>
  11 |     | <span class='neutral'>    /// @param tokenId The ID of the token that represents the position</span>
  12 |     | <span class='neutral'>    /// @return nonce The nonce for permits</span>
  13 |     | <span class='neutral'>    /// @return operator The address that is approved for spending</span>
  14 |     | <span class='neutral'>    /// @return token0 The address of the token0 for a specific pool</span>
  15 |     | <span class='neutral'>    /// @return token1 The address of the token1 for a specific pool</span>
  16 |     | <span class='neutral'>    /// @return tickSpacing The tick spacing associated with the pool</span>
  17 |     | <span class='neutral'>    /// @return tickLower The lower end of the tick range for the position</span>
  18 |     | <span class='neutral'>    /// @return tickUpper The higher end of the tick range for the position</span>
  19 |     | <span class='neutral'>    /// @return liquidity The liquidity of the position</span>
  20 |     | <span class='neutral'>    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position</span>
  21 |     | <span class='neutral'>    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position</span>
  22 |     | <span class='neutral'>    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation</span>
  23 |     | <span class='neutral'>    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation</span>
  24 |     | <span class='neutral'>    function positions(uint256 tokenId)</span>
  25 |     | <span class='neutral'>        external</span>
  26 |     | <span class='neutral'>        view</span>
  27 |     | <span class='neutral'>        returns (</span>
  28 |     | <span class='neutral'>            uint96 nonce,</span>
  29 |     | <span class='neutral'>            address operator,</span>
  30 |     | <span class='neutral'>            address token0,</span>
  31 |     | <span class='neutral'>            address token1,</span>
  32 |     | <span class='neutral'>            int24 tickSpacing,</span>
  33 |     | <span class='neutral'>            int24 tickLower,</span>
  34 |     | <span class='neutral'>            int24 tickUpper,</span>
  35 |     | <span class='neutral'>            uint128 liquidity,</span>
  36 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
  37 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
  38 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
  39 |     | <span class='neutral'>            uint128 tokensOwed1</span>
  40 |     | <span class='neutral'>        );</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice Returns the address of the Token Descriptor, that handles generating token URIs for Positions</span>
  43 |     | <span class='neutral'>    function tokenDescriptor() external view returns (address);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice Returns the address of the Owner, that is allowed to set a new TokenDescriptor</span>
  46 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    struct MintParams {</span>
  49 |     | <span class='neutral'>        address token0;</span>
  50 |     | <span class='neutral'>        address token1;</span>
  51 |     | <span class='neutral'>        int24 tickSpacing;</span>
  52 |     | <span class='neutral'>        int24 tickLower;</span>
  53 |     | <span class='neutral'>        int24 tickUpper;</span>
  54 |     | <span class='neutral'>        uint256 amount0Desired;</span>
  55 |     | <span class='neutral'>        uint256 amount1Desired;</span>
  56 |     | <span class='neutral'>        uint256 amount0Min;</span>
  57 |     | <span class='neutral'>        uint256 amount1Min;</span>
  58 |     | <span class='neutral'>        address recipient;</span>
  59 |     | <span class='neutral'>        uint256 deadline;</span>
  60 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /// @notice Creates a new position wrapped in a NFT</span>
  64 |     | <span class='neutral'>    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized</span>
  65 |     | <span class='neutral'>    /// a method does not exist, i.e. the pool is assumed to be initialized.</span>
  66 |     | <span class='neutral'>    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata</span>
  67 |     | <span class='neutral'>    /// @return tokenId The ID of the token that represents the minted position</span>
  68 |     | <span class='neutral'>    /// @return liquidity The amount of liquidity for this position</span>
  69 |     | <span class='neutral'>    /// @return amount0 The amount of token0</span>
  70 |     | <span class='neutral'>    /// @return amount1 The amount of token1</span>
  71 |     | <span class='neutral'>    function mint(MintParams calldata params)</span>
  72 |     | <span class='neutral'>        external</span>
  73 |     | <span class='neutral'>        payable</span>
  74 |     | <span class='neutral'>        returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    struct IncreaseLiquidityParams {</span>
  77 |     | <span class='neutral'>        uint256 tokenId;</span>
  78 |     | <span class='neutral'>        uint256 amount0Desired;</span>
  79 |     | <span class='neutral'>        uint256 amount1Desired;</span>
  80 |     | <span class='neutral'>        uint256 amount0Min;</span>
  81 |     | <span class='neutral'>        uint256 amount1Min;</span>
  82 |     | <span class='neutral'>        uint256 deadline;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`</span>
  86 |     | <span class='neutral'>    /// @param params tokenId The ID of the token for which liquidity is being increased,</span>
  87 |     | <span class='neutral'>    /// amount0Desired The desired amount of token0 to be spent,</span>
  88 |     | <span class='neutral'>    /// amount1Desired The desired amount of token1 to be spent,</span>
  89 |     | <span class='neutral'>    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,</span>
  90 |     | <span class='neutral'>    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,</span>
  91 |     | <span class='neutral'>    /// deadline The time by which the transaction must be included to effect the change</span>
  92 |     | <span class='neutral'>    /// @return liquidity The new liquidity amount as a result of the increase</span>
  93 |     | <span class='neutral'>    /// @return amount0 The amount of token0 to acheive resulting liquidity</span>
  94 |     | <span class='neutral'>    /// @return amount1 The amount of token1 to acheive resulting liquidity</span>
  95 |     | <span class='neutral'>    function increaseLiquidity(IncreaseLiquidityParams calldata params)</span>
  96 |     | <span class='neutral'>        external</span>
  97 |     | <span class='neutral'>        payable</span>
  98 |     | <span class='neutral'>        returns (uint128 liquidity, uint256 amount0, uint256 amount1);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    struct DecreaseLiquidityParams {</span>
 101 |     | <span class='neutral'>        uint256 tokenId;</span>
 102 |     | <span class='neutral'>        uint128 liquidity;</span>
 103 |     | <span class='neutral'>        uint256 amount0Min;</span>
 104 |     | <span class='neutral'>        uint256 amount1Min;</span>
 105 |     | <span class='neutral'>        uint256 deadline;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Decreases the amount of liquidity in a position and accounts it to the position</span>
 109 |     | <span class='neutral'>    /// @param params tokenId The ID of the token for which liquidity is being decreased,</span>
 110 |     | <span class='neutral'>    /// amount The amount by which liquidity will be decreased,</span>
 111 |     | <span class='neutral'>    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,</span>
 112 |     | <span class='neutral'>    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,</span>
 113 |     | <span class='neutral'>    /// deadline The time by which the transaction must be included to effect the change</span>
 114 |     | <span class='neutral'>    /// @return amount0 The amount of token0 accounted to the position&#39;s tokens owed</span>
 115 |     | <span class='neutral'>    /// @return amount1 The amount of token1 accounted to the position&#39;s tokens owed</span>
 116 |     | <span class='neutral'>    /// @dev The use of this function can cause a loss to users of the NonfungiblePositionManager</span>
 117 |     | <span class='neutral'>    /// @dev for tokens that have very high decimals.</span>
 118 |     | <span class='neutral'>    /// @dev The amount of tokens necessary for the loss is: 3.4028237e+38.</span>
 119 |     | <span class='neutral'>    /// @dev This is equivalent to 1e20 value with 18 decimals.</span>
 120 |     | <span class='neutral'>    function decreaseLiquidity(DecreaseLiquidityParams calldata params)</span>
 121 |     | <span class='neutral'>        external</span>
 122 |     | <span class='neutral'>        payable</span>
 123 |     | <span class='neutral'>        returns (uint256 amount0, uint256 amount1);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    struct CollectParams {</span>
 126 |     | <span class='neutral'>        uint256 tokenId;</span>
 127 |     | <span class='neutral'>        address recipient;</span>
 128 |     | <span class='neutral'>        uint128 amount0Max;</span>
 129 |     | <span class='neutral'>        uint128 amount1Max;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient</span>
 133 |     | <span class='neutral'>    /// @notice Used to update staked positions before deposit and withdraw</span>
 134 |     | <span class='neutral'>    /// @param params tokenId The ID of the NFT for which tokens are being collected,</span>
 135 |     | <span class='neutral'>    /// recipient The account that should receive the tokens,</span>
 136 |     | <span class='neutral'>    /// amount0Max The maximum amount of token0 to collect,</span>
 137 |     | <span class='neutral'>    /// amount1Max The maximum amount of token1 to collect</span>
 138 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
 139 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
 140 |     | <span class='neutral'>    //audit can I collect on another user behalf ? </span>
 141 |     | <span class='neutral'>    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens</span>
 144 |     | <span class='neutral'>    /// must be collected first.</span>
 145 |     | <span class='neutral'>    /// @param tokenId The ID of the token that is being burned</span>
 146 |     | <span class='neutral'>    //audit Invariant: liquidity SHOULD be 0 AND collect() SHOULD have been called before.</span>
 147 |     | <span class='neutral'>    function burn(uint256 tokenId) external payable;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice Sets a new Token Descriptor</span>
 150 |     | <span class='neutral'>    /// @param _tokenDescriptor Address of the new Token Descriptor to be chosen</span>
 151 |     | <span class='neutral'>    function setTokenDescriptor(address _tokenDescriptor) external;</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /// @notice Sets a new Owner address</span>
 154 |     | <span class='neutral'>    /// @param _owner Address of the new Owner to be chosen</span>
 155 |     | <span class='neutral'>    function setOwner(address _owner) external;</span>
 156 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/IVeloPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IVeloPool {</span>
   5 |     | <span class='neutral'>    /// @notice The contract that deployed the pool, which must adhere to the IPancakeV3Factory interface</span>
   6 |     | <span class='neutral'>    /// @return The contract address</span>
   7 |     | <span class='neutral'>    function factory() external view returns (address);</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    /// @notice The first of the two tokens of the pool, sorted by address</span>
  10 |     | <span class='neutral'>    /// @return The token contract address</span>
  11 |     | <span class='neutral'>    function token0() external view returns (address);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @notice The second of the two tokens of the pool, sorted by address</span>
  14 |     | <span class='neutral'>    /// @return The token contract address</span>
  15 |     | <span class='neutral'>    function token1() external view returns (address);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
  18 |     | <span class='neutral'>    /// @return The fee</span>
  19 |     | <span class='neutral'>    function fee() external view returns (uint24);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /// @notice The pool tick spacing</span>
  22 |     | <span class='neutral'>    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive</span>
  23 |     | <span class='neutral'>    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...</span>
  24 |     | <span class='neutral'>    /// This value is an int24 to avoid casting even though it is always positive.</span>
  25 |     | <span class='neutral'>    /// @return The tick spacing</span>
  26 |     | <span class='neutral'>    function tickSpacing() external view returns (int24);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @notice The maximum amount of position liquidity that can use any tick in the range</span>
  29 |     | <span class='neutral'>    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and</span>
  30 |     | <span class='neutral'>    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool</span>
  31 |     | <span class='neutral'>    /// @return The max amount of liquidity per tick</span>
  32 |     | <span class='neutral'>    function maxLiquidityPerTick() external view returns (uint128);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
  35 |     | <span class='neutral'>    /// when accessed externally.</span>
  36 |     | <span class='neutral'>    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
  37 |     | <span class='neutral'>    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
  38 |     | <span class='neutral'>    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
  39 |     | <span class='neutral'>    /// boundary.</span>
  40 |     | <span class='neutral'>    /// observationIndex The index of the last oracle observation that was written,</span>
  41 |     | <span class='neutral'>    /// observationCardinality The current maximum number of observations stored in the pool,</span>
  42 |     | <span class='neutral'>    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
  43 |     | <span class='neutral'>    /// feeProtocol The protocol fee for both tokens of the pool.</span>
  44 |     | <span class='neutral'>    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
  45 |     | <span class='neutral'>    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
  46 |     | <span class='neutral'>    /// unlocked Whether the pool is currently locked to reentrancy</span>
  47 |     | <span class='neutral'>    function slot0()</span>
  48 |     | <span class='neutral'>        external</span>
  49 |     | <span class='neutral'>        view</span>
  50 |     | <span class='neutral'>        returns (</span>
  51 |     | <span class='neutral'>            uint160 sqrtPriceX96,</span>
  52 |     | <span class='neutral'>            int24 tick,</span>
  53 |     | <span class='neutral'>            uint16 observationIndex,</span>
  54 |     | <span class='neutral'>            uint16 observationCardinality,</span>
  55 |     | <span class='neutral'>            uint16 observationCardinalityNext,</span>
  56 |     | <span class='neutral'>            bool unlocked</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool</span>
  60 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  61 |     | <span class='neutral'>    function feeGrowthGlobal0X128() external view returns (uint256);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool</span>
  64 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  65 |     | <span class='neutral'>    function feeGrowthGlobal1X128() external view returns (uint256);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @notice The amounts of token0 and token1 that are owed to the protocol</span>
  68 |     | <span class='neutral'>    /// @dev Protocol fees will never exceed uint128 max in either token</span>
  69 |     | <span class='neutral'>    function protocolFees() external view returns (uint128 token0, uint128 token1);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /// @notice The currently in range liquidity available to the pool</span>
  72 |     | <span class='neutral'>    /// @dev This value has no relationship to the total liquidity across all ticks</span>
  73 |     | <span class='neutral'>    function liquidity() external view returns (uint128);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /// @notice Look up information about a specific tick in the pool</span>
  76 |     | <span class='neutral'>    /// @param tick The tick to look up</span>
  77 |     | <span class='neutral'>    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or</span>
  78 |     | <span class='neutral'>    /// tick upper,</span>
  79 |     | <span class='neutral'>    /// liquidityNet how much liquidity changes when the pool price crosses the tick,</span>
  80 |     | <span class='neutral'>    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,</span>
  81 |     | <span class='neutral'>    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,</span>
  82 |     | <span class='neutral'>    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick</span>
  83 |     | <span class='neutral'>    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,</span>
  84 |     | <span class='neutral'>    /// secondsOutside the seconds spent on the other side of the tick from the current tick,</span>
  85 |     | <span class='neutral'>    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.</span>
  86 |     | <span class='neutral'>    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.</span>
  87 |     | <span class='neutral'>    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for</span>
  88 |     | <span class='neutral'>    /// a specific position.</span>
  89 |     | <span class='neutral'>    function ticks(int24 tick)</span>
  90 |     | <span class='neutral'>        external</span>
  91 |     | <span class='neutral'>        view</span>
  92 |     | <span class='neutral'>        returns (</span>
  93 |     | <span class='neutral'>            uint128 liquidityGross,</span>
  94 |     | <span class='neutral'>            int128 liquidityNet,</span>
  95 |     | <span class='neutral'>            uint256 feeGrowthOutside0X128,</span>
  96 |     | <span class='neutral'>            uint256 feeGrowthOutside1X128,</span>
  97 |     | <span class='neutral'>            int56 tickCumulativeOutside,</span>
  98 |     | <span class='neutral'>            uint160 secondsPerLiquidityOutsideX128,</span>
  99 |     | <span class='neutral'>            uint32 secondsOutside,</span>
 100 |     | <span class='neutral'>            bool initialized</span>
 101 |     | <span class='neutral'>        );</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information</span>
 104 |     | <span class='neutral'>    function tickBitmap(int16 wordPosition) external view returns (uint256);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /// @notice Returns the information about a position by the position&#39;s key</span>
 107 |     | <span class='neutral'>    /// @param key The position&#39;s key is a hash of a preimage composed by the owner, tickLower and tickUpper</span>
 108 |     | <span class='neutral'>    /// @return _liquidity The amount of liquidity in the position,</span>
 109 |     | <span class='neutral'>    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,</span>
 110 |     | <span class='neutral'>    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,</span>
 111 |     | <span class='neutral'>    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,</span>
 112 |     | <span class='neutral'>    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke</span>
 113 |     | <span class='neutral'>    function positions(bytes32 key)</span>
 114 |     | <span class='neutral'>        external</span>
 115 |     | <span class='neutral'>        view</span>
 116 |     | <span class='neutral'>        returns (</span>
 117 |     | <span class='neutral'>            uint128 _liquidity,</span>
 118 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
 119 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
 120 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
 121 |     | <span class='neutral'>            uint128 tokensOwed1</span>
 122 |     | <span class='neutral'>        );</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /// @notice Returns data about a specific observation index</span>
 125 |     | <span class='neutral'>    /// @param index The element of the observations array to fetch</span>
 126 |     | <span class='neutral'>    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time</span>
 127 |     | <span class='neutral'>    /// ago, rather than at a specific index in the array.</span>
 128 |     | <span class='neutral'>    /// @return blockTimestamp The timestamp of the observation,</span>
 129 |     | <span class='neutral'>    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,</span>
 130 |     | <span class='neutral'>    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,</span>
 131 |     | <span class='neutral'>    /// Returns initialized whether the observation has been initialized and the values are safe to use</span>
 132 |     | <span class='neutral'>    function observations(uint256 index)</span>
 133 |     | <span class='neutral'>        external</span>
 134 |     | <span class='neutral'>        view</span>
 135 |     | <span class='neutral'>        returns (</span>
 136 |     | <span class='neutral'>            uint32 blockTimestamp,</span>
 137 |     | <span class='neutral'>            int56 tickCumulative,</span>
 138 |     | <span class='neutral'>            uint160 secondsPerLiquidityCumulativeX128,</span>
 139 |     | <span class='neutral'>            bool initialized</span>
 140 |     | <span class='neutral'>        );</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /// @notice Collects tokens owed to a position</span>
 143 |     | <span class='neutral'>    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.</span>
 144 |     | <span class='neutral'>    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or</span>
 145 |     | <span class='neutral'>    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the</span>
 146 |     | <span class='neutral'>    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.</span>
 147 |     | <span class='neutral'>    /// @param recipient The address which should receive the fees collected</span>
 148 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to collect fees</span>
 149 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to collect fees</span>
 150 |     | <span class='neutral'>    /// @param amount0Requested How much token0 should be withdrawn from the fees owed</span>
 151 |     | <span class='neutral'>    /// @param amount1Requested How much token1 should be withdrawn from the fees owed</span>
 152 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
 153 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
 154 |     | <span class='neutral'>    function collect(</span>
 155 |     | <span class='neutral'>        address recipient,</span>
 156 |     | <span class='neutral'>        int24 tickLower,</span>
 157 |     | <span class='neutral'>        int24 tickUpper,</span>
 158 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 159 |     | <span class='neutral'>        uint128 amount1Requested</span>
 160 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position</span>
 163 |     | <span class='neutral'>    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0</span>
 164 |     | <span class='neutral'>    /// @dev Fees must be collected separately via a call to #collect</span>
 165 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to burn liquidity</span>
 166 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to burn liquidity</span>
 167 |     | <span class='neutral'>    /// @param amount How much liquidity to burn</span>
 168 |     | <span class='neutral'>    /// @return amount0 The amount of token0 sent to the recipient</span>
 169 |     | <span class='neutral'>    /// @return amount1 The amount of token1 sent to the recipient</span>
 170 |     | <span class='neutral'>    function burn(</span>
 171 |     | <span class='neutral'>        int24 tickLower,</span>
 172 |     | <span class='neutral'>        int24 tickUpper,</span>
 173 |     | <span class='neutral'>        uint128 amount</span>
 174 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position</span>
 177 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback</span>
 178 |     | <span class='neutral'>    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends</span>
 179 |     | <span class='neutral'>    /// on tickLower, tickUpper, the amount of liquidity, and the current price.</span>
 180 |     | <span class='neutral'>    /// @param recipient The address for which the liquidity will be created</span>
 181 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position in which to add liquidity</span>
 182 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position in which to add liquidity</span>
 183 |     | <span class='neutral'>    /// @param amount The amount of liquidity to mint</span>
 184 |     | <span class='neutral'>    /// @param data Any data that should be passed through to the callback</span>
 185 |     | <span class='neutral'>    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
 186 |     | <span class='neutral'>    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
 187 |     | <span class='neutral'>    function mint(</span>
 188 |     | <span class='neutral'>        address recipient,</span>
 189 |     | <span class='neutral'>        int24 tickLower,</span>
 190 |     | <span class='neutral'>        int24 tickUpper,</span>
 191 |     | <span class='neutral'>        uint128 amount,</span>
 192 |     | <span class='neutral'>        bytes calldata data</span>
 193 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp</span>
 196 |     | <span class='neutral'>    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing</span>
 197 |     | <span class='neutral'>    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,</span>
 198 |     | <span class='neutral'>    /// you must call it with secondsAgos = [3600, 0].</span>
 199 |     | <span class='neutral'>    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 200 |     | <span class='neutral'>    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 201 |     | <span class='neutral'>    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 202 |     | <span class='neutral'>    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 203 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 204 |     | <span class='neutral'>    /// timestamp</span>
 205 |     | <span class='neutral'>    function observe(uint32[] calldata secondsAgos)</span>
 206 |     | <span class='neutral'>        external</span>
 207 |     | <span class='neutral'>        view</span>
 208 |     | <span class='neutral'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext)</span>
 211 |     | <span class='neutral'>        external;</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    </span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/interfaces/velodrome/IVeloRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IVeloRouter {</span>
  5 |     | <span class='neutral'>        struct Route {</span>
  6 |     | <span class='neutral'>            address from;</span>
  7 |     | <span class='neutral'>            address to;</span>
  8 |     | <span class='neutral'>            bool stable;</span>
  9 |     | <span class='neutral'>            address factory;</span>
 10 |     | <span class='neutral'>        }</span>
 11 |     | <span class='neutral'>        </span>
 12 |     | <span class='neutral'>        function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external;</span>
 13 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/rewardpool/BeefyRewardPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import { ERC20Upgradeable } from &quot;@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol&quot;;</span>
   6 |     | <span class='neutral'>import { OwnableUpgradeable } from &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import { SafeERC20Upgradeable, IERC20Upgradeable, IERC20PermitUpgradeable } from &quot;@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/// @title Reward pool for BIFI</span>
  10 |     | <span class='neutral'>/// @author kexley, Beefy</span>
  11 |     | <span class='neutral'>/// @notice Multi-reward staking contract for BIFI</span>
  12 |     | <span class='neutral'>/// @dev Multiple rewards can be added to this contract by the owner. A receipt token is issued for </span>
  13 |     | <span class='neutral'>/// staking and is used for withdrawing the staked BIFI.</span>
  14 | *   | <span class='executed'>contract BeefyRewardPool is ERC20Upgradeable, OwnableUpgradeable {</span>
  15 |     | <span class='neutral'>    using SafeERC20Upgradeable for IERC20Upgradeable;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @dev Information for a particular reward</span>
  18 |     | <span class='neutral'>    /// @param periodFinish End timestamp of reward distribution</span>
  19 |     | <span class='neutral'>    /// @param duration Distribution length of time in seconds</span>
  20 |     | <span class='neutral'>    /// @param lastUpdateTime Latest timestamp of an update</span>
  21 |     | <span class='neutral'>    /// @param rate Distribution speed in wei per second</span>
  22 |     | <span class='neutral'>    /// @param rewardPerTokenStored Stored reward value per staked token in 18 decimals</span>
  23 |     | <span class='neutral'>    /// @param userRewardPerTokenPaid Stored reward value per staked token in 18 decimals at the </span>
  24 |     | <span class='neutral'>    /// last time a user was paid the reward</span>
  25 |     | <span class='neutral'>    /// @param earned Value of reward still owed to the user</span>
  26 |     | <span class='neutral'>    struct RewardInfo {</span>
  27 |     | <span class='neutral'>        uint256 periodFinish;</span>
  28 |     | <span class='neutral'>        uint256 duration;</span>
  29 |     | <span class='neutral'>        uint256 lastUpdateTime;</span>
  30 |     | <span class='neutral'>        uint256 rate;</span>
  31 |     | <span class='neutral'>        uint256 rewardPerTokenStored;</span>
  32 |     | <span class='neutral'>        mapping(address =&gt; uint256) userRewardPerTokenPaid;</span>
  33 |     | <span class='neutral'>        mapping(address =&gt; uint256) earned;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @notice BIFI token address</span>
  37 |     | <span class='unexecuted'>    IERC20Upgradeable public stakedToken;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @notice Array of reward addresses</span>
  40 |     | <span class='unexecuted'>    address[] public rewards;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice Whitelist of manager addresses</span>
  43 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public whitelisted;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @dev Limit to the number of rewards an owner can add</span>
  46 |     | <span class='neutral'>    uint256 private rewardMax;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /// @dev Location of a reward in the reward array</span>
  49 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _index;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @dev Each reward address has a new unique identifier each time it is initialized. This is </span>
  52 |     | <span class='neutral'>    /// to prevent old mappings from being reused when removing and re-adding a reward.</span>
  53 |     | <span class='neutral'>    mapping(address =&gt; bytes32) private _id;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @dev Each identifier relates to reward information</span>
  56 |     | <span class='neutral'>    mapping(bytes32 =&gt; RewardInfo) private _rewardInfo;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice User has staked an amount</span>
  59 |     | <span class='neutral'>    event Staked(address indexed user, uint256 amount);</span>
  60 |     | <span class='neutral'>    /// @notice User has withdrawn an amount</span>
  61 |     | <span class='neutral'>    event Withdrawn(address indexed user, uint256 amount);</span>
  62 |     | <span class='neutral'>    /// @notice A reward has been paid to the user</span>
  63 |     | <span class='neutral'>    event RewardPaid(address indexed user, address indexed reward, uint256 amount);</span>
  64 |     | <span class='neutral'>    /// @notice A new reward has been added to be distributed</span>
  65 |     | <span class='neutral'>    event AddReward(address reward);</span>
  66 |     | <span class='neutral'>    /// @notice More of an existing reward has been added to be distributed</span>
  67 |     | <span class='neutral'>    event NotifyReward(address indexed reward, uint256 amount, uint256 duration);</span>
  68 |     | <span class='neutral'>    /// @notice A reward has been removed from distribution and sent to the recipient</span>
  69 |     | <span class='neutral'>    event RemoveReward(address reward, address recipient);</span>
  70 |     | <span class='neutral'>    /// @notice The owner has removed tokens that are not supported by this contract</span>
  71 |     | <span class='neutral'>    event RescueTokens(address token, address recipient);</span>
  72 |     | <span class='neutral'>    /// @notice An address has been added to or removed from the whitelist</span>
  73 |     | <span class='neutral'>    event SetWhitelist(address manager, bool whitelist);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /// @notice Caller is not a manager</span>
  76 |     | <span class='neutral'>    error NotManager(address caller);</span>
  77 |     | <span class='neutral'>    /// @notice The staked token cannot be added as a reward</span>
  78 |     | <span class='neutral'>    error StakedTokenIsNotAReward();</span>
  79 |     | <span class='neutral'>    /// @notice The duration is too short to be set</span>
  80 |     | <span class='neutral'>    error ShortDuration(uint256 duration);</span>
  81 |     | <span class='neutral'>    /// @notice There are already too many rewards</span>
  82 |     | <span class='neutral'>    error TooManyRewards();</span>
  83 |     | <span class='neutral'>    /// @notice The reward has not been found in the array</span>
  84 |     | <span class='neutral'>    error RewardNotFound(address reward);</span>
  85 |     | <span class='neutral'>    /// @notice The owner cannot withdraw the staked token</span>
  86 |     | <span class='neutral'>    error WithdrawingStakedToken();</span>
  87 |     | <span class='neutral'>    /// @notice the owner cannot withdraw an existing reward without first removing it from the array</span>
  88 |     | <span class='neutral'>    error WithdrawingRewardToken(address reward);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /// @dev Triggers reward updates on every user interaction</span>
  91 |     | <span class='neutral'>    /// @param _user Address of the user making an interaction</span>
  92 |     | <span class='neutral'>    modifier update(address _user) {</span>
  93 |     | <span class='unexecuted'>        _update(_user);</span>
  94 |     | <span class='neutral'>        _;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @dev Only a manager can call these modified functions</span>
  98 |     | <span class='neutral'>    modifier onlyManager {</span>
  99 |     | <span class='unexecuted'>        if (!whitelisted[msg.sender]) revert NotManager(msg.sender);</span>
 100 |     | <span class='unexecuted'>        _;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /* ---------------------------------- EXTERNAL FUNCTIONS ---------------------------------- */</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /// @notice Initialize the contract, callable only once</span>
 106 |     | <span class='neutral'>    /// @param _stakedToken BIFI token address</span>
 107 | *   | <span class='executed'>    function initialize(address _stakedToken, string calldata _name, string calldata _symbol) external initializer {</span>
 108 | *   | <span class='executed'>        __ERC20_init(_name, _symbol);</span>
 109 | *   | <span class='executed'>        __Ownable_init();</span>
 110 | *   | <span class='executed'>        stakedToken = IERC20Upgradeable(_stakedToken);</span>
 111 | *   | <span class='executed'>        rewardMax = 100;</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /// @notice Stake BIFI tokens</span>
 115 |     | <span class='neutral'>    /// @dev An equal number of receipt tokens will be minted to the caller</span>
 116 |     | <span class='neutral'>    /// @param _amount Amount of BIFI to stake</span>
 117 |     | <span class='unexecuted'>    function stake(uint256 _amount) external update(msg.sender) {</span>
 118 |     | <span class='unexecuted'>        _stake(msg.sender, _amount);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /// @notice Stake BIFI tokens with a permit</span>
 122 |     | <span class='neutral'>    /// @dev An equal number of receipt tokens will be minted to the caller</span>
 123 |     | <span class='neutral'>    /// @param _user User to stake for</span>
 124 |     | <span class='neutral'>    /// @param _amount Amount of BIFI to stake</span>
 125 |     | <span class='neutral'>    /// @param _deadline Timestamp of the deadline after which the permit is invalid</span>
 126 |     | <span class='neutral'>    /// @param _v Part of a signature</span>
 127 |     | <span class='neutral'>    /// @param _r Part of a signature</span>
 128 |     | <span class='neutral'>    /// @param _s Part of a signature</span>
 129 |     | <span class='unexecuted'>    function stakeWithPermit(</span>
 130 |     | <span class='neutral'>        address _user,</span>
 131 |     | <span class='neutral'>        uint256 _amount,</span>
 132 |     | <span class='neutral'>        uint256 _deadline,</span>
 133 |     | <span class='neutral'>        uint8 _v,</span>
 134 |     | <span class='neutral'>        bytes32 _r,</span>
 135 |     | <span class='neutral'>        bytes32 _s</span>
 136 |     | <span class='unexecuted'>    ) external update(_user) {</span>
 137 |     | <span class='unexecuted'>        IERC20PermitUpgradeable(address(stakedToken)).permit(</span>
 138 |     | <span class='unexecuted'>            _user, address(this), _amount, _deadline, _v, _r, _s</span>
 139 |     | <span class='neutral'>        );</span>
 140 |     | <span class='unexecuted'>        _stake(_user, _amount);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @notice Withdraw BIFI tokens</span>
 144 |     | <span class='neutral'>    /// @dev Burns an equal number of receipt tokens from the caller</span>
 145 |     | <span class='neutral'>    /// @param _amount Amount of BIFI to withdraw</span>
 146 | *   | <span class='executed'>    function withdraw(uint256 _amount) external update(msg.sender) {</span>
 147 | *   | <span class='executed'>        _withdraw(_amount);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /// @notice Withdraw all of the caller&#39;s BIFI tokens and claim rewards</span>
 151 |     | <span class='neutral'>    /// @dev Burns all receipt tokens owned by the caller</span>
 152 |     | <span class='unexecuted'>    function exit() external update(msg.sender) {</span>
 153 |     | <span class='unexecuted'>        _withdraw(balanceOf(msg.sender));</span>
 154 |     | <span class='neutral'>        _getReward();</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @notice Claim all the caller&#39;s earned rewards </span>
 158 |     | <span class='unexecuted'>    function getReward() external update(msg.sender) {</span>
 159 |     | <span class='unexecuted'>        _getReward();</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /// @notice View the amount of rewards earned by the user</span>
 163 |     | <span class='neutral'>    /// @param _user User to view the earned rewards for</span>
 164 |     | <span class='neutral'>    /// @return rewardTokens Address array of the rewards</span>
 165 |     | <span class='neutral'>    /// @return earnedAmounts Amounts of the user&#39;s earned rewards</span>
 166 |     | <span class='unexecuted'>    function earned(address _user) external view returns (</span>
 167 |     | <span class='unexecuted'>        address[] memory rewardTokens,</span>
 168 |     | <span class='neutral'>        uint256[] memory earnedAmounts</span>
 169 |     | <span class='unexecuted'>    ) {</span>
 170 |     | <span class='unexecuted'>        uint256 rewardLength = rewards.length;</span>
 171 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](rewardLength);</span>
 172 |     | <span class='unexecuted'>        for (uint i; i &lt; rewardLength;) {</span>
 173 |     | <span class='unexecuted'>            amounts[i] = _earned(_user, rewards[i]);</span>
 174 |     | <span class='unexecuted'>            unchecked { ++i; }</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='unexecuted'>        earnedAmounts = amounts;</span>
 177 |     | <span class='unexecuted'>        rewardTokens = rewards;</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /// @notice View the amount of a single reward earned by the user</span>
 181 |     | <span class='neutral'>    /// @param _user User to view the earned reward for</span>
 182 |     | <span class='neutral'>    /// @param _reward Reward to calculate the earned amount for</span>
 183 |     | <span class='neutral'>    /// @return earnedAmount Amount of the user&#39;s earned reward</span>
 184 |     | <span class='unexecuted'>    function earned(address _user, address _reward) external view returns (uint256 earnedAmount) {</span>
 185 |     | <span class='unexecuted'>        earnedAmount = _earned(_user, _reward);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /// @notice View the reward information</span>
 189 |     | <span class='neutral'>    /// @dev The active reward information is automatically selected from the id mapping</span>
 190 |     | <span class='neutral'>    /// @param _rewardId Index of the reward in the array to get the information for</span>
 191 |     | <span class='neutral'>    /// @return reward Address of the reward</span>
 192 |     | <span class='neutral'>    /// @return periodFinish End timestamp of reward distribution</span>
 193 |     | <span class='neutral'>    /// @return duration Distribution length of time in seconds</span>
 194 |     | <span class='neutral'>    /// @return lastUpdateTime Latest timestamp of an update</span>
 195 |     | <span class='neutral'>    /// @return rate Distribution speed in wei per second</span>
 196 |     | <span class='unexecuted'>    function rewardInfo(uint256 _rewardId) external view returns (</span>
 197 |     | <span class='unexecuted'>        address reward,</span>
 198 |     | <span class='unexecuted'>        uint256 periodFinish,</span>
 199 |     | <span class='unexecuted'>        uint256 duration,</span>
 200 |     | <span class='unexecuted'>        uint256 lastUpdateTime,</span>
 201 |     | <span class='unexecuted'>        uint256 rate</span>
 202 |     | <span class='neutral'>    ) {</span>
 203 |     | <span class='unexecuted'>        reward = rewards[_rewardId];</span>
 204 |     | <span class='unexecuted'>        RewardInfo storage info = _getRewardInfo(reward);</span>
 205 |     | <span class='neutral'>        (periodFinish, duration, lastUpdateTime, rate) =</span>
 206 |     | <span class='unexecuted'>            (info.periodFinish, info.duration, info.lastUpdateTime, info.rate);</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /* ------------------------------- ERC20 OVERRIDE FUNCTIONS ------------------------------- */</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /// @notice Update rewards for both source and recipient and then transfer receipt tokens to </span>
 212 |     | <span class='neutral'>    /// the recipient address</span>
 213 |     | <span class='neutral'>    /// @dev Overrides the ERC20 implementation to add the reward update</span>
 214 |     | <span class='neutral'>    /// @param _to Recipient address of the token transfer</span>
 215 |     | <span class='neutral'>    /// @param _value Amount to transfer</span>
 216 |     | <span class='neutral'>    /// @return success Transfer was successful or not</span>
 217 |     | <span class='unexecuted'>    function transfer(address _to, uint256 _value) public override returns (bool success) {</span>
 218 |     | <span class='unexecuted'>        _update(msg.sender);</span>
 219 |     | <span class='unexecuted'>        _update(_to);</span>
 220 |     | <span class='unexecuted'>        return super.transfer(_to, _value);</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /// @notice Update rewards for both source and recipient and then transfer receipt tokens from</span>
 224 |     | <span class='neutral'>    /// the source address to the recipient address</span>
 225 |     | <span class='neutral'>    /// @dev Overrides the ERC20 implementation to add the reward update</span>
 226 |     | <span class='neutral'>    /// @param _from Source address of the token transfer</span>
 227 |     | <span class='neutral'>    /// @param _to Recipient address of the token transfer</span>
 228 |     | <span class='neutral'>    /// @param _value Amount to transfer</span>
 229 |     | <span class='neutral'>    /// @return success Transfer was successful or not</span>
 230 |     | <span class='unexecuted'>    function transferFrom(</span>
 231 |     | <span class='neutral'>        address _from,</span>
 232 |     | <span class='neutral'>        address _to,</span>
 233 |     | <span class='neutral'>        uint256 _value</span>
 234 |     | <span class='unexecuted'>    ) public override returns (bool success) {</span>
 235 |     | <span class='unexecuted'>        _update(_from);</span>
 236 |     | <span class='unexecuted'>        _update(_to);</span>
 237 |     | <span class='unexecuted'>        return super.transferFrom(_from, _to, _value);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    /* ----------------------------------- OWNER FUNCTIONS ------------------------------------ */</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /// @notice Manager function to start a reward distribution</span>
 243 |     | <span class='neutral'>    /// @dev Must approve this contract to spend the reward amount before calling this function. </span>
 244 |     | <span class='neutral'>    /// New rewards will be assigned a id using their address and the block timestamp.</span>
 245 |     | <span class='neutral'>    /// @param _reward Address of the reward</span>
 246 |     | <span class='neutral'>    /// @param _amount Amount of reward</span>
 247 |     | <span class='neutral'>    /// @param _duration Duration of the reward distribution in seconds</span>
 248 |     | <span class='unexecuted'>    function notifyRewardAmount(</span>
 249 |     | <span class='neutral'>        address _reward,</span>
 250 |     | <span class='neutral'>        uint256 _amount,</span>
 251 |     | <span class='neutral'>        uint256 _duration</span>
 252 |     | <span class='unexecuted'>    ) external onlyManager update(address(0)) {</span>
 253 |     | <span class='unexecuted'>        if (_reward == address(stakedToken)) revert StakedTokenIsNotAReward();</span>
 254 |     | <span class='unexecuted'>        if (_duration &lt; 1 hours) revert ShortDuration(_duration);</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>        if (!_rewardExists(_reward)) {</span>
 257 |     | <span class='unexecuted'>            _id[_reward] = keccak256(abi.encodePacked(_reward, block.timestamp));</span>
 258 |     | <span class='unexecuted'>            uint256 rewardLength = rewards.length;</span>
 259 |     | <span class='unexecuted'>            if (rewards.length + 1 &gt; rewardMax) revert TooManyRewards();</span>
 260 |     | <span class='unexecuted'>            _index[_reward] = rewardLength;</span>
 261 |     | <span class='unexecuted'>            rewards.push(_reward);</span>
 262 |     | <span class='unexecuted'>            emit AddReward(_reward);</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>        IERC20Upgradeable(_reward).safeTransferFrom(msg.sender, address(this), _amount);</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>        RewardInfo storage rewardData = _getRewardInfo(_reward);</span>
 268 |     | <span class='unexecuted'>        uint256 leftover;</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        if (block.timestamp &lt; rewardData.periodFinish) {</span>
 271 |     | <span class='unexecuted'>            uint256 remaining = rewardData.periodFinish - block.timestamp;</span>
 272 |     | <span class='unexecuted'>            leftover = remaining * rewardData.rate;</span>
 273 |     | <span class='neutral'>        }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>        rewardData.rate = (_amount + leftover) / _duration;</span>
 276 |     | <span class='unexecuted'>        rewardData.lastUpdateTime = block.timestamp;</span>
 277 |     | <span class='unexecuted'>        rewardData.periodFinish = block.timestamp + _duration;</span>
 278 |     | <span class='unexecuted'>        rewardData.duration = _duration;</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>        emit NotifyReward(_reward, _amount, _duration);</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    /// @notice Owner function to remove a reward from this contract</span>
 284 |     | <span class='neutral'>    /// @dev All unclaimed earnings are ignored. Re-adding the reward will have a new set of</span>
 285 |     | <span class='neutral'>    /// reward information so any unclaimed earnings cannot be recovered</span>
 286 |     | <span class='neutral'>    /// @param _reward Address of the reward to be removed</span>
 287 |     | <span class='neutral'>    /// @param _recipient Address of the recipient that the removed reward was sent to</span>
 288 | *   | <span class='executed'>    function removeReward(address _reward, address _recipient) external onlyOwner {</span>
 289 |     | <span class='unexecuted'>        if (!_rewardExists(_reward)) revert RewardNotFound(_reward);</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='unexecuted'>        uint256 replacedIndex = _index[_reward];</span>
 292 |     | <span class='unexecuted'>        address endToken = rewards[rewards.length - 1];</span>
 293 |     | <span class='unexecuted'>        rewards[replacedIndex] = endToken;</span>
 294 |     | <span class='unexecuted'>        _index[endToken] = replacedIndex;</span>
 295 |     | <span class='unexecuted'>        rewards.pop();</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>        uint256 rewardBal = IERC20Upgradeable(_reward).balanceOf(address(this));</span>
 298 |     | <span class='unexecuted'>        IERC20Upgradeable(_reward).safeTransfer(_recipient, rewardBal);</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='unexecuted'>        emit RemoveReward(_reward, _recipient);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    /// @notice Owner function to remove unsupported tokens sent to this contract</span>
 304 |     | <span class='neutral'>    /// @param _token Address of the token to be removed</span>
 305 |     | <span class='neutral'>    /// @param _recipient Address of the recipient that the removed token was sent to</span>
 306 |     | <span class='unexecuted'>    function rescueTokens(address _token, address _recipient) external onlyOwner {</span>
 307 |     | <span class='unexecuted'>        if (_token == address(stakedToken)) revert WithdrawingStakedToken();</span>
 308 |     | <span class='unexecuted'>        if (_rewardExists(_token)) revert WithdrawingRewardToken(_token);</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='unexecuted'>        uint256 amount = IERC20Upgradeable(_token).balanceOf(address(this));</span>
 311 |     | <span class='unexecuted'>        IERC20Upgradeable(_token).safeTransfer(_recipient, amount);</span>
 312 |     | <span class='unexecuted'>        emit RescueTokens(_token, _recipient);</span>
 313 |     | <span class='neutral'>    }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>    /// @notice Owner function to add addresses to the whitelist</span>
 316 |     | <span class='neutral'>    /// @param _manager Address able to call manager functions</span>
 317 |     | <span class='neutral'>    /// @param _whitelisted Whether to add or remove from whitelist</span>
 318 |     | <span class='unexecuted'>    function setWhitelist(address _manager, bool _whitelisted) external onlyOwner {</span>
 319 |     | <span class='unexecuted'>        whitelisted[_manager] = _whitelisted;</span>
 320 |     | <span class='unexecuted'>        emit SetWhitelist(_manager, _whitelisted);</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>    /* ---------------------------------- INTERNAL FUNCTIONS ---------------------------------- */</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>    /// @dev Update the rewards and earnings for a user</span>
 326 |     | <span class='neutral'>    /// @param _user Address to update the earnings for</span>
 327 |     | <span class='unexecuted'>    function _update(address _user) private {</span>
 328 |     | <span class='unexecuted'>        uint256 rewardLength = rewards.length;</span>
 329 |     | <span class='unexecuted'>        for (uint i; i &lt; rewardLength;) {</span>
 330 |     | <span class='unexecuted'>            address reward = rewards[i];</span>
 331 |     | <span class='unexecuted'>            RewardInfo storage rewardData = _getRewardInfo(reward);</span>
 332 |     | <span class='unexecuted'>            rewardData.rewardPerTokenStored = _rewardPerToken(reward);</span>
 333 |     | <span class='unexecuted'>            rewardData.lastUpdateTime = _lastTimeRewardApplicable(rewardData.periodFinish);</span>
 334 |     | <span class='unexecuted'>            if (_user != address(0)) {</span>
 335 |     | <span class='unexecuted'>                rewardData.earned[_user] = _earned(_user, reward);</span>
 336 |     | <span class='unexecuted'>                rewardData.userRewardPerTokenPaid[_user] = rewardData.rewardPerTokenStored;</span>
 337 |     | <span class='neutral'>            }</span>
 338 |     | <span class='unexecuted'>            unchecked { ++i; } </span>
 339 |     | <span class='neutral'>        }</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>    /// @dev Stake BIFI tokens and mint the caller receipt tokens</span>
 343 |     | <span class='neutral'>    /// @param _user Address of the user to stake for</span>
 344 |     | <span class='neutral'>    /// @param _amount Amount of BIFI to stake</span>
 345 |     | <span class='unexecuted'>    function _stake(address _user, uint256 _amount) private {</span>
 346 |     | <span class='unexecuted'>        _mint(_user, _amount);</span>
 347 |     | <span class='unexecuted'>        stakedToken.safeTransferFrom(_user, address(this), _amount);</span>
 348 |     | <span class='unexecuted'>        emit Staked(msg.sender, _amount);</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>    /// @dev Withdraw BIFI tokens and burn an equal number of receipt tokens from the caller</span>
 352 |     | <span class='neutral'>    /// @param _amount Amount of BIFI to withdraw</span>
 353 |     | <span class='neutral'>    </span>
 354 |     | <span class='unexecuted'>    function _withdraw(uint256 _amount) private {</span>
 355 |     | <span class='unexecuted'>        _burn(msg.sender, _amount);</span>
 356 |     | <span class='unexecuted'>        stakedToken.safeTransfer(msg.sender, _amount);</span>
 357 |     | <span class='unexecuted'>        emit Withdrawn(msg.sender, _amount);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>    /// @dev Claim all the caller&#39;s earned rewards </span>
 361 |     | <span class='unexecuted'>    function _getReward() private {</span>
 362 |     | <span class='unexecuted'>        uint256 rewardLength = rewards.length;</span>
 363 |     | <span class='unexecuted'>        for (uint i; i &lt; rewardLength;) {</span>
 364 |     | <span class='unexecuted'>            address reward = rewards[i];</span>
 365 |     | <span class='unexecuted'>            uint256 rewardEarned = _earned(msg.sender, reward);</span>
 366 |     | <span class='unexecuted'>            if (rewardEarned &gt; 0) {</span>
 367 |     | <span class='unexecuted'>                _getRewardInfo(reward).earned[msg.sender] = 0;</span>
 368 |     | <span class='unexecuted'>                _rewardTransfer(reward, msg.sender, rewardEarned);</span>
 369 |     | <span class='unexecuted'>                emit RewardPaid(msg.sender, reward, rewardEarned);</span>
 370 |     | <span class='neutral'>            }</span>
 371 |     | <span class='unexecuted'>            unchecked { ++i; }</span>
 372 |     | <span class='neutral'>        }</span>
 373 |     | <span class='neutral'>    }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>    /// @dev Return either the period finish or the current timestamp, whichever is earliest</span>
 376 |     | <span class='neutral'>    /// @param _periodFinish End timestamp of the reward distribution</span>
 377 |     | <span class='neutral'>    /// @return timestamp Earliest timestamp out of the period finish or block timestamp </span>
 378 |     | <span class='unexecuted'>    function _lastTimeRewardApplicable(uint256 _periodFinish) private view returns (uint256 timestamp) {</span>
 379 |     | <span class='unexecuted'>        timestamp = block.timestamp &gt; _periodFinish ? _periodFinish : block.timestamp;</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>    /// @dev Calculate the reward amount per BIFI token</span>
 383 |     | <span class='neutral'>    /// @param _reward Address of the reward</span>
 384 |     | <span class='neutral'>    /// @return rewardPerToken Reward amount per BIFI token</span>
 385 | *   | <span class='executed'>    function _rewardPerToken(address _reward) private view returns (uint256 rewardPerToken) {</span>
 386 |     | <span class='unexecuted'>        RewardInfo storage rewardData = _getRewardInfo(_reward);</span>
 387 | *   | <span class='executed'>        if (totalSupply() == 0) {</span>
 388 |     | <span class='unexecuted'>            rewardPerToken = rewardData.rewardPerTokenStored;</span>
 389 |     | <span class='neutral'>        } else {</span>
 390 |     | <span class='unexecuted'>            rewardPerToken = rewardData.rewardPerTokenStored + (</span>
 391 |     | <span class='unexecuted'>                (_lastTimeRewardApplicable(rewardData.periodFinish) - rewardData.lastUpdateTime) </span>
 392 |     | <span class='unexecuted'>                * rewardData.rate</span>
 393 |     | <span class='unexecuted'>                * 1e18 </span>
 394 |     | <span class='neutral'>                / totalSupply()</span>
 395 |     | <span class='neutral'>            );</span>
 396 |     | <span class='neutral'>        }</span>
 397 |     | <span class='neutral'>    }</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>    /// @dev Calculate the reward amount earned by the user</span>
 400 |     | <span class='neutral'>    /// @param _user Address of the user</span>
 401 |     | <span class='neutral'>    /// @param _reward Address of the reward</span>
 402 |     | <span class='neutral'>    /// @return earnedAmount Amount of reward earned by the user</span>
 403 |     | <span class='unexecuted'>    function _earned(address _user, address _reward) private view returns (uint256 earnedAmount) {</span>
 404 |     | <span class='unexecuted'>        RewardInfo storage rewardData = _getRewardInfo(_reward);</span>
 405 |     | <span class='unexecuted'>        earnedAmount = rewardData.earned[_user] + (</span>
 406 |     | <span class='unexecuted'>            balanceOf(_user) * </span>
 407 |     | <span class='unexecuted'>            (_rewardPerToken(_reward) - rewardData.userRewardPerTokenPaid[_user]) </span>
 408 |     | <span class='unexecuted'>            / 1e18</span>
 409 |     | <span class='neutral'>        );</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>    /// @dev Return the most current reward information for a reward</span>
 413 |     | <span class='neutral'>    /// @param _reward Address of the reward</span>
 414 |     | <span class='neutral'>    /// @return info Reward information for the reward</span>
 415 |     | <span class='unexecuted'>    function _getRewardInfo(address _reward) private view returns(RewardInfo storage info) {</span>
 416 |     | <span class='unexecuted'>        info = _rewardInfo[_id[_reward]];</span>
 417 |     | <span class='neutral'>    }</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    /// @dev Check if a reward exists in the reward array already</span>
 420 |     | <span class='neutral'>    /// @param _reward Address of the reward</span>
 421 |     | <span class='neutral'>    /// @return exists Returns true if token is in the array</span>
 422 | *   | <span class='executed'>    function _rewardExists(address _reward) private view returns (bool exists) {</span>
 423 | *   | <span class='executed'>        if (rewards.length &gt; 0) exists = _reward == rewards[_index[_reward]];</span>
 424 |     | <span class='neutral'>    }</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>    /// @dev Transfer at most the balance of the reward on this contract to avoid errors</span>
 427 |     | <span class='neutral'>    /// @param _reward Address of the reward</span>
 428 |     | <span class='neutral'>    /// @param _recipient Address of the recipient of the reward</span>
 429 |     | <span class='neutral'>    /// @param _amount Amount of the reward to be sent to the recipient</span>
 430 |     | <span class='unexecuted'>    function _rewardTransfer(address _reward, address _recipient, uint256 _amount) private {</span>
 431 |     | <span class='unexecuted'>        uint256 rewardBal = IERC20Upgradeable(_reward).balanceOf(address(this));</span>
 432 |     | <span class='unexecuted'>        if (_amount &gt; rewardBal) _amount = rewardBal;</span>
 433 |     | <span class='unexecuted'>        if (_amount &gt; 0) IERC20Upgradeable(_reward).safeTransfer(_recipient, _amount);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/rewardpool/BeefyRewardPoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BeefyRewardPool} from &quot;./BeefyRewardPool.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ClonesUpgradeable} from &quot;@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// Beefy Reward Pool Proxy Factory</span>
  8 |     | <span class='neutral'>// Minimal proxy pattern for creating new Beefy concentrated liquidity reward pools</span>
  9 | *   | <span class='executed'>contract BeefyRewardPoolFactory {</span>
 10 |     | <span class='neutral'>  using ClonesUpgradeable for address;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  /// @notice Contract template for deploying proxied Beefy Reward Pools</span>
 13 | *   | <span class='executed'>  BeefyRewardPool public instance;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>  /// @notice Emitted when a new Beefy Reward Pool is created</span>
 16 |     | <span class='neutral'>  event ProxyCreated(address proxy);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>  /** </span>
 19 |     | <span class='neutral'>   * @notice Constructor initializes the Beefy Reward Pool template instance</span>
 20 |     | <span class='neutral'>   * @param _instance The address of the Beefy Reward Pool template instance</span>
 21 |     | <span class='neutral'>   */</span>
 22 |     | <span class='unexecuted'>  constructor(address _instance) {</span>
 23 |     | <span class='unexecuted'>    if (_instance == address(0)) {</span>
 24 |     | <span class='unexecuted'>      instance = new BeefyRewardPool();</span>
 25 |     | <span class='neutral'>    } else {</span>
 26 |     | <span class='unexecuted'>      instance = BeefyRewardPool(_instance);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>  }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>  /**</span>
 31 |     | <span class='neutral'>   * @notice Create a new Beefy Reward Pool as a proxy of the template instance</span>
 32 |     | <span class='neutral'>   * @return A reference to the new proxied Beefy Reward Pool</span>
 33 |     | <span class='neutral'>   */</span>
 34 | *   | <span class='executed'>  function cloneRewardPool(</span>
 35 | *   | <span class='executed'>  ) external returns (BeefyRewardPool) {</span>
 36 | *   | <span class='executed'>    BeefyRewardPool vault = BeefyRewardPool(_cloneContract(address(instance)));</span>
 37 |     | <span class='neutral'>    return vault;</span>
 38 |     | <span class='neutral'>  }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>  /**</span>
 41 |     | <span class='neutral'>   * Deploys and returns the address of a clone that mimics the behaviour of `implementation`</span>
 42 |     | <span class='neutral'>   * @param implementation The address of the contract to clone</span>
 43 |     | <span class='neutral'>   * @return The address of the newly created clone</span>
 44 |     | <span class='neutral'>  */</span>
 45 | *   | <span class='executed'>  function _cloneContract(address implementation) private returns (address) {</span>
 46 | *   | <span class='executed'>    address proxy = implementation.clone();</span>
 47 | *   | <span class='executed'>    emit ProxyCreated(proxy);</span>
 48 | *   | <span class='executed'>    return proxy;</span>
 49 |     | <span class='neutral'>  }</span>
 50 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/strategies/StratFeeManagerInitializable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.23;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {OwnableUpgradeable} from &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {PausableUpgradeable} from &quot;@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IFeeConfig} from &quot;../interfaces/beefy/IFeeConfig.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IStrategyFactory} from &quot;../interfaces/beefy/IStrategyFactory.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract StratFeeManagerInitializable is OwnableUpgradeable, PausableUpgradeable {</span>
  11 |     | <span class='neutral'>    struct CommonAddresses {</span>
  12 |     | <span class='neutral'>        address vault;</span>
  13 |     | <span class='neutral'>        address unirouter;</span>
  14 |     | <span class='neutral'>        address strategist;</span>
  15 |     | <span class='neutral'>        address factory;</span>
  16 |     | <span class='neutral'>    }</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /// @notice The native address of the chain</span>
  19 |     | <span class='unexecuted'>    address public native;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /// @notice The address of the vault</span>
  22 |     | <span class='unexecuted'>    address public vault;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /// @notice The address of the unirouter</span>
  25 |     | <span class='unexecuted'>    address public unirouter;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice The address of the strategist</span>
  28 |     | <span class='unexecuted'>    address public strategist;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /// @notice The address of the strategy factory</span>
  31 |     | <span class='unexecuted'>    IStrategyFactory public factory;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @notice The total amount of token0 locked in the vault</span>
  34 |     | <span class='unexecuted'>    uint256 public totalLocked0;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @notice The total amount of token1 locked in the vault</span>
  37 |     | <span class='unexecuted'>    uint256 public totalLocked1;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @notice The last time the strat harvested</span>
  40 |     | <span class='unexecuted'>    uint256 public lastHarvest;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice The duration of the locked rewards</span>
  43 |     | <span class='unexecuted'>    uint256 constant DURATION = 1 hours;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice The divisor used to calculate the fee</span>
  46 |     | <span class='unexecuted'>    uint256 constant DIVISOR = 1 ether;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    // Events</span>
  50 |     | <span class='neutral'>    event SetStratFeeId(uint256 feeId);</span>
  51 |     | <span class='neutral'>    event SetUnirouter(address unirouter);</span>
  52 |     | <span class='neutral'>    event SetStrategist(address strategist);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    // Errors</span>
  55 |     | <span class='neutral'>    error NotManager();</span>
  56 |     | <span class='neutral'>    error NotStrategist();</span>
  57 |     | <span class='neutral'>    error OverLimit();</span>
  58 |     | <span class='neutral'>    error StrategyPaused();</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @notice Initialize the Strategy Fee Manager inherited contract with the common addresses</span>
  62 |     | <span class='neutral'>     * @param _commonAddresses The common addresses of the vault, unirouter, keeper, strategist, beefyFeeRecipient and beefyFeeConfig</span>
  63 |     | <span class='neutral'>     */</span>
  64 | *   | <span class='executed'>    function __StratFeeManager_init(CommonAddresses calldata _commonAddresses) internal onlyInitializing {</span>
  65 | *   | <span class='executed'>        __Ownable_init();</span>
  66 | *   | <span class='executed'>        __Pausable_init();</span>
  67 | *   | <span class='executed'>        vault = _commonAddresses.vault;</span>
  68 | *   | <span class='executed'>        unirouter = _commonAddresses.unirouter;</span>
  69 | *   | <span class='executed'>        strategist = _commonAddresses.strategist;</span>
  70 | *   | <span class='executed'>        factory = IStrategyFactory(_commonAddresses.factory);</span>
  71 | *   | <span class='executed'>        native = factory.native();</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @notice function that throws if the strategy is paused</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='unexecuted'>    function _whenStrategyNotPaused() internal view {</span>
  78 |     | <span class='unexecuted'>        if (paused() || factory.globalPause()) revert StrategyPaused();</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @notice function that returns true if the strategy is paused</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function _isPaused() internal view returns (bool) {</span>
  86 |     | <span class='unexecuted'>        return paused() || factory.globalPause();</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /** </span>
  90 |     | <span class='neutral'>     * @notice Modifier that throws if called by any account other than the manager or the owner</span>
  91 |     | <span class='neutral'>    */</span>
  92 |     | <span class='neutral'>    //audit Can the keeper be changed ?  @mody: only through the setkeeper in the factory. protected with onlyowner modifier</span>
  93 |     | <span class='neutral'>    modifier onlyManager() {</span>
  94 |     | <span class='unexecuted'>        if (msg.sender != owner() &amp;&amp; msg.sender != keeper()) revert NotManager();</span>
  95 |     | <span class='neutral'>        _;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice The address of the keeper, set on the factory. </span>
  99 |     | <span class='unexecuted'>    function keeper() public view returns (address) {</span>
 100 |     | <span class='unexecuted'>        return factory.keeper();</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice The address of the beefy fee recipient, set on the factory.</span>
 104 |     | <span class='unexecuted'>    function beefyFeeRecipient() public view returns (address) {</span>
 105 |     | <span class='unexecuted'>        return factory.beefyFeeRecipient();</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice The address of the beefy fee config, set on the factory.</span>
 109 |     | <span class='unexecuted'>    function beefyFeeConfig() public view returns (IFeeConfig) {</span>
 110 |     | <span class='unexecuted'>        return IFeeConfig(factory.beefyFeeConfig());</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /**</span>
 114 |     | <span class='neutral'>     * @notice get the fees breakdown from the fee config for this contract</span>
 115 |     | <span class='neutral'>     * @return IFeeConfig.FeeCategory The fees breakdown</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    //audit-info What is IFeeConfig(factory.beefyFeeConfig).getFees(this);</span>
 119 |     | <span class='unexecuted'>    function getFees() internal view returns (IFeeConfig.FeeCategory memory) {</span>
 120 |     | <span class='unexecuted'>        return beefyFeeConfig().getFees(address(this));</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @notice get all the fees from the fee config for this contract</span>
 125 |     | <span class='neutral'>     * @return IFeeConfig.AllFees The fees</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='neutral'>     //audit depositFee(), withdrawFee() set to 0.</span>
 128 |     | <span class='unexecuted'>    function getAllFees() external view returns (IFeeConfig.AllFees memory) {</span>
 129 |     | <span class='unexecuted'>        return IFeeConfig.AllFees(getFees(), depositFee(), withdrawFee());</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /**</span>
 133 |     | <span class='neutral'>     * @notice get the strat fee id from the fee config</span>
 134 |     | <span class='neutral'>     * @return uint256 The strat fee id</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='unexecuted'>    function getStratFeeId() external view returns (uint256) {</span>
 137 |     | <span class='unexecuted'>        return beefyFeeConfig().stratFeeId(address(this));</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @notice set the strat fee id in the fee config</span>
 142 |     | <span class='neutral'>     * @param _feeId The new strat fee id</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='unexecuted'>    function setStratFeeId(uint256 _feeId) external onlyManager {</span>
 145 |     | <span class='unexecuted'>        beefyFeeConfig().setStratFeeId(_feeId);</span>
 146 |     | <span class='unexecuted'>        emit SetStratFeeId(_feeId);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @notice set the unirouter address</span>
 151 |     | <span class='neutral'>     * @param _unirouter The new unirouter address</span>
 152 |     | <span class='neutral'>     */</span>
 153 |     | <span class='unexecuted'>    function setUnirouter(address _unirouter) external virtual onlyOwner {</span>
 154 |     | <span class='unexecuted'>        unirouter = _unirouter;</span>
 155 |     | <span class='unexecuted'>        emit SetUnirouter(_unirouter);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /**</span>
 159 |     | <span class='neutral'>     * @notice set the strategist address</span>
 160 |     | <span class='neutral'>     * @param _strategist The new strategist address</span>
 161 |     | <span class='neutral'>     */</span>
 162 |     | <span class='unexecuted'>    function setStrategist(address _strategist) external {</span>
 163 |     | <span class='unexecuted'>        if (msg.sender != strategist) revert NotStrategist();</span>
 164 |     | <span class='unexecuted'>        strategist = _strategist;</span>
 165 |     | <span class='unexecuted'>        emit SetStrategist(_strategist);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /**</span>
 169 |     | <span class='neutral'>     * @notice The deposit fee variable will alwasy be 0. This is used by the UI. </span>
 170 |     | <span class='neutral'>     * @return uint256 The deposit fee</span>
 171 |     | <span class='neutral'>     */</span>
 172 |     | <span class='unexecuted'>    function depositFee() public virtual view returns (uint256) {</span>
 173 |     | <span class='neutral'>        return 0;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /**</span>
 177 |     | <span class='neutral'>     * @notice The withdraw fee variable will alwasy be 0. This is used by the UI. </span>
 178 |     | <span class='neutral'>     * @return uint256 The withdraw fee</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function withdrawFee() public virtual view returns (uint256) {</span>
 181 |     | <span class='neutral'>        return 0;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    /**</span>
 185 |     | <span class='neutral'>     * @notice The locked profit is the amount of token0 and token1 that is locked in the vault, this can be overriden by the strategy contract.</span>
 186 |     | <span class='neutral'>     * @return locked0 The amount of token0 locked</span>
 187 |     | <span class='neutral'>     * @return locked1 The amount of token1 locked</span>
 188 |     | <span class='neutral'>     */</span>
 189 |     | <span class='neutral'>     //audit-info Looks weird</span>
 190 |     | <span class='unexecuted'>    function lockedProfit() public virtual view returns (uint256 locked0, uint256 locked1) {</span>
 191 |     | <span class='unexecuted'>        uint256 elapsed = block.timestamp - lastHarvest;</span>
 192 |     | <span class='unexecuted'>        uint256 remaining = elapsed &lt; DURATION ? DURATION - elapsed : 0;</span>
 193 |     | <span class='unexecuted'>        return (totalLocked0 * remaining / DURATION, totalLocked1 * remaining / DURATION);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    /**</span>
 197 |     | <span class='neutral'>     * @dev This empty reserved space is put in place to allow future versions to add new</span>
 198 |     | <span class='neutral'>     * variables without shifting down storage in the inheritance chain.</span>
 199 |     | <span class='neutral'>     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='neutral'>    uint256[49] private __gap;</span>
 202 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/strategies/StrategyFactory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {BeaconProxy} from &quot;@openzeppelin-4/contracts/proxy/beacon/BeaconProxy.sol&quot;;</span>
   5 |     | <span class='neutral'>import {UpgradeableBeacon} from &quot;@openzeppelin-4/contracts/proxy/beacon/UpgradeableBeacon.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Ownable} from &quot;@openzeppelin-4/contracts/access/Ownable.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Beefy Strategy ConcLiq Proxy Factory</span>
   9 |     | <span class='neutral'>// Minimal proxy pattern for creating new Beefy concentrated liquidity vaults</span>
  10 | *   | <span class='executed'>contract StrategyFactory is Ownable {</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>  /// @notice instance mapping to strategy name with version. </span>
  13 | *   | <span class='executed'>  mapping (string =&gt; UpgradeableBeacon) public instances;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>  /// @notice approved rebalancer mapping </span>
  16 |     | <span class='unexecuted'>  mapping (address =&gt; bool) public rebalancers;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>  /// @notice deployed strategy types</span>
  19 |     | <span class='unexecuted'>  string[] public strategyTypes;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>  /// @notice The address of the native token</span>
  22 | *   | <span class='executed'>  address public native;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>  /// @notice The address of the keeper</span>
  25 |     | <span class='unexecuted'>  address public keeper;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>  /// @notice The beefy fee recipient</span>
  28 |     | <span class='unexecuted'>  address public beefyFeeRecipient;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>  /// @notice The beefy fee config</span>
  31 |     | <span class='unexecuted'>  address public beefyFeeConfig;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>  /// @notice Global pause state for all strategies that use this</span>
  34 |     | <span class='unexecuted'>  bool public globalPause;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>  /// @notice Emitted when a new Beefy Strategy is created</span>
  37 |     | <span class='neutral'>  event ProxyCreated(string strategyName, address proxy);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>  /// @notice Emitted when a Beefy Strategy is upgraded</span>
  40 |     | <span class='neutral'>  event InstanceUpgraded(string strategyName, address newImplementation);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>  /// @notice Emitted when a new Beefy Strategy is added</span>
  43 |     | <span class='neutral'>  event NewStrategyAdded(string strategyName, address implementation);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>  /// @notice Emitted when the beefy fee recipient address is changed</span>
  46 |     | <span class='neutral'>  event SetBeefyFeeRecipient(address beefyFeeRecipient);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>  /// @notice Emitted when the beefy fee config address is changed</span>
  49 |     | <span class='neutral'>  event SetBeefyFeeConfig(address beefyFeeConfig);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>  /// @notice Emitted when the keeper address is changed</span>
  52 |     | <span class='neutral'>  event SetKeeper(address keeper);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>  /// @notice Emitted when the global pause state is changed</span>
  55 |     | <span class='neutral'>  event GlobalPause(bool paused);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>  /// @notice Emitted when a rebalancer is added or removed</span>
  58 |     | <span class='neutral'>  event RebalancerChanged(address rebalancer, bool isRebalancer);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>  // Errors</span>
  61 |     | <span class='neutral'>  error NotManager();</span>
  62 |     | <span class='neutral'>  error StratVersionExists();</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>  /// @notice Throws if called by any account other than the owner or the keeper/</span>
  65 |     | <span class='neutral'>  modifier onlyManager() {</span>
  66 | *   | <span class='executed'>    if (msg.sender != owner() &amp;&amp; msg.sender != address(keeper)) revert NotManager();</span>
  67 |     | <span class='neutral'>    _;</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>  /// @notice Constructor initializes the keeper address</span>
  71 |     | <span class='unexecuted'>  constructor(</span>
  72 |     | <span class='neutral'>    address _native,</span>
  73 |     | <span class='neutral'>    address _keeper,</span>
  74 |     | <span class='neutral'>    address _beefyFeeRecipient,</span>
  75 |     | <span class='neutral'>    address _beefyFeeConfig</span>
  76 |     | <span class='unexecuted'>  ) Ownable(msg.sender) {</span>
  77 |     | <span class='unexecuted'>    native = _native;</span>
  78 |     | <span class='unexecuted'>    keeper = _keeper;</span>
  79 |     | <span class='unexecuted'>    beefyFeeRecipient = _beefyFeeRecipient;</span>
  80 |     | <span class='unexecuted'>    beefyFeeConfig = _beefyFeeConfig;</span>
  81 |     | <span class='neutral'>  }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>  /** @notice Creates a new Beefy Strategy as a proxy of the template instance</span>
  84 |     | <span class='neutral'>    * @param _strategyName The name of the strategy</span>
  85 |     | <span class='neutral'>    * @return A reference to the new proxied Beefy Strategy</span>
  86 |     | <span class='neutral'>   */</span>
  87 | *   | <span class='executed'>  function createStrategy(string calldata _strategyName) external returns (address) {</span>
  88 |     | <span class='neutral'>    </span>
  89 |     | <span class='neutral'>    // Create a new Beefy Strategy as a proxy of the template instance</span>
  90 | *   | <span class='executed'>    UpgradeableBeacon instance = instances[_strategyName];</span>
  91 | *   | <span class='executed'>    BeaconProxy proxy = new BeaconProxy(address(instance), &quot;&quot;);</span>
  92 |     | <span class='neutral'></span>
  93 | *   | <span class='executed'>    emit ProxyCreated(_strategyName, address(proxy));</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    return address(proxy);</span>
  96 |     | <span class='neutral'>  }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>  /**</span>
  99 |     | <span class='neutral'>   * @notice Upgrades the implementation of a strategy</span>
 100 |     | <span class='neutral'>   * @param _strategyName The name of the strategy</span>
 101 |     | <span class='neutral'>   * @param _newImplementation The new implementation address</span>
 102 |     | <span class='neutral'>   */</span>
 103 |     | <span class='unexecuted'>  function upgradeTo(string calldata _strategyName, address _newImplementation) external onlyOwner {</span>
 104 |     | <span class='unexecuted'>    UpgradeableBeacon instance = instances[_strategyName];</span>
 105 |     | <span class='unexecuted'>    instance.upgradeTo(_newImplementation);</span>
 106 |     | <span class='unexecuted'>    emit InstanceUpgraded(_strategyName, _newImplementation);</span>
 107 |     | <span class='neutral'>  }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>  /**</span>
 110 |     | <span class='neutral'>   * @notice Adds a new strategy to the factory</span>
 111 |     | <span class='neutral'>   * @param _strategyName The name of the strategy</span>
 112 |     | <span class='neutral'>   * @param _implementation The implementation address</span>
 113 |     | <span class='neutral'>   */</span>
 114 | *   | <span class='executed'>  function addStrategy(string calldata _strategyName, address _implementation) external onlyManager {</span>
 115 | *   | <span class='executed'>    if (address(instances[_strategyName]) != address(0)) revert StratVersionExists();</span>
 116 | *   | <span class='executed'>    instances[_strategyName] = new UpgradeableBeacon(_implementation, address(this));</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    // Store in our deployed strategy type array</span>
 119 | *   | <span class='executed'>    strategyTypes.push(_strategyName);</span>
 120 | *   | <span class='executed'>    emit NewStrategyAdded(_strategyName, _implementation);</span>
 121 |     | <span class='neutral'>  }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>  /**</span>
 124 |     | <span class='neutral'>   * @notice Pauses all strategies</span>
 125 |     | <span class='neutral'>   */</span>
 126 |     | <span class='unexecuted'>  function pauseAllStrats() external onlyManager {</span>
 127 |     | <span class='unexecuted'>    globalPause = true;</span>
 128 |     | <span class='unexecuted'>    emit GlobalPause(true);</span>
 129 |     | <span class='neutral'>  }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>  /**</span>
 132 |     | <span class='neutral'>   * @notice Unpauses all strategies</span>
 133 |     | <span class='neutral'>   */</span>
 134 |     | <span class='unexecuted'>  function unpauseAllStrats() external onlyOwner {</span>
 135 |     | <span class='unexecuted'>    globalPause = false;</span>
 136 |     | <span class='unexecuted'>    emit GlobalPause(false);</span>
 137 |     | <span class='neutral'>  }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>  /**</span>
 140 |     | <span class='neutral'>   * @notice Adds a rebalancer callable by the owner</span>
 141 |     | <span class='neutral'>   * @param _rebalancer The rebalancer address</span>
 142 |     | <span class='neutral'>   */</span>
 143 | *   | <span class='executed'>  function addRebalancer(address _rebalancer) external onlyOwner {</span>
 144 |     | <span class='unexecuted'>    rebalancers[_rebalancer] = true;</span>
 145 |     | <span class='unexecuted'>    emit RebalancerChanged(_rebalancer, true);</span>
 146 |     | <span class='neutral'>  }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>  /**</span>
 149 |     | <span class='neutral'>   * @notice Removes a rebalancer callable by a manager</span>
 150 |     | <span class='neutral'>   * @param _rebalancer The rebalancer address</span>
 151 |     | <span class='neutral'>   */</span>
 152 |     | <span class='unexecuted'>  function removeRebalancer(address _rebalancer) external onlyManager {</span>
 153 |     | <span class='unexecuted'>    rebalancers[_rebalancer] = false;</span>
 154 |     | <span class='unexecuted'>    emit RebalancerChanged(_rebalancer, false);</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>  /**</span>
 158 |     | <span class='neutral'>   * @notice set the beefy fee recipient address</span>
 159 |     | <span class='neutral'>   * @param _beefyFeeRecipient The new beefy fee recipient address</span>
 160 |     | <span class='neutral'>   */</span>
 161 |     | <span class='unexecuted'>  function setBeefyFeeRecipient(address _beefyFeeRecipient) external onlyOwner {</span>
 162 |     | <span class='unexecuted'>      beefyFeeRecipient = _beefyFeeRecipient;</span>
 163 |     | <span class='unexecuted'>      emit SetBeefyFeeRecipient(_beefyFeeRecipient);</span>
 164 |     | <span class='neutral'>  }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>  /**</span>
 167 |     | <span class='neutral'>   * @notice set the beefy fee config address</span>
 168 |     | <span class='neutral'>   * @param _beefyFeeConfig The new beefy fee config address</span>
 169 |     | <span class='neutral'>   */</span>
 170 | *   | <span class='executed'>  function setBeefyFeeConfig(address _beefyFeeConfig) external onlyOwner {</span>
 171 |     | <span class='unexecuted'>      beefyFeeConfig = _beefyFeeConfig;</span>
 172 |     | <span class='unexecuted'>      emit SetBeefyFeeConfig(_beefyFeeConfig);</span>
 173 |     | <span class='neutral'>  }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>  /**</span>
 176 |     | <span class='neutral'>   * @notice set the keeper address</span>
 177 |     | <span class='neutral'>   * @param _keeper The new keeper address</span>
 178 |     | <span class='neutral'>   */</span>
 179 |     | <span class='unexecuted'>  function setKeeper(address _keeper) external onlyOwner {</span>
 180 |     | <span class='unexecuted'>      keeper = _keeper;</span>
 181 |     | <span class='unexecuted'>      emit SetKeeper(_keeper);</span>
 182 |     | <span class='neutral'>  }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>  /**</span>
 185 |     | <span class='neutral'>   * @notice Gets the implementation of a strategy</span>
 186 |     | <span class='neutral'>   * @param _strategyName The name of the strategy</span>
 187 |     | <span class='neutral'>   * @return The implementation address</span>
 188 |     | <span class='neutral'>   */</span>
 189 |     | <span class='unexecuted'>  function getImplementation(string calldata _strategyName) external view returns (address) {</span>
 190 |     | <span class='unexecuted'>    return instances[_strategyName].implementation();</span>
 191 |     | <span class='neutral'>  }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>  /**</span>
 194 |     | <span class='neutral'>   * @notice Gets the array of deployed strategies</span>
 195 |     | <span class='neutral'>   * @return The array of deployed strategies</span>
 196 |     | <span class='neutral'>   */</span>
 197 |     | <span class='unexecuted'>  function getStrategyTypes() external view returns (string[] memory) {</span>
 198 |     | <span class='unexecuted'>    return strategyTypes;</span>
 199 |     | <span class='neutral'>  }</span>
 200 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/strategies/velodrome/StrategyPassiveManagerVelodrome.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import {Test, console} from &quot;forge-std/Test.sol&quot;;</span>
    5 |     | <span class='neutral'></span>
    6 |     | <span class='neutral'>import {IERC20Metadata} from &quot;@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
    7 |     | <span class='neutral'>import {IERC721} from &quot;@openzeppelin-4/contracts/token/ERC721/IERC721.sol&quot;;</span>
    8 |     | <span class='neutral'>import {SafeERC20} from &quot;@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
    9 |     | <span class='neutral'>import {SignedMath} from &quot;@openzeppelin-4/contracts/utils/math/SignedMath.sol&quot;;</span>
   10 |     | <span class='neutral'>import {StratFeeManagerInitializable, IFeeConfig} from &quot;../StratFeeManagerInitializable.sol&quot;;</span>
   11 |     | <span class='neutral'>import {IVeloPool} from &quot;../../interfaces/velodrome/IVeloPool.sol&quot;;</span>
   12 |     | <span class='neutral'>import {IVeloRouter} from &quot;../../interfaces/velodrome/IVeloRouter.sol&quot;;</span>
   13 |     | <span class='neutral'>import {LiquidityAmounts} from &quot;../../utils/LiquidityAmounts.sol&quot;;</span>
   14 |     | <span class='neutral'>import {TickMath} from &quot;../../utils/TickMath.sol&quot;;</span>
   15 |     | <span class='neutral'>import {TickUtils, FullMath} from &quot;../../utils/TickUtils.sol&quot;;</span>
   16 |     | <span class='neutral'>import {VeloSwapUtils} from &quot;../../utils/VeloSwapUtils.sol&quot;;</span>
   17 |     | <span class='neutral'>import {IBeefyVaultConcLiq} from &quot;../../interfaces/beefy/IBeefyVaultConcLiq.sol&quot;;</span>
   18 |     | <span class='neutral'>import {IStrategyConcLiq} from &quot;../../interfaces/beefy/IStrategyConcLiq.sol&quot;;</span>
   19 |     | <span class='neutral'>import {IStrategyVelodrome} from &quot;../../interfaces/beefy/IStrategyVelodrome.sol&quot;;</span>
   20 |     | <span class='neutral'>import {IStrategyFactory} from &quot;../../interfaces/beefy/IStrategyFactory.sol&quot;;</span>
   21 |     | <span class='neutral'>import {INftPositionManager} from &quot;../../interfaces/velodrome/INftPositionManager.sol&quot;;</span>
   22 |     | <span class='neutral'>import {ICLGauge} from &quot;../../interfaces/velodrome/ICLGauge.sol&quot;;</span>
   23 |     | <span class='neutral'>import {IRewardPool} from &quot;../../interfaces/beefy/IRewardPool.sol&quot;;</span>
   24 |     | <span class='neutral'>import {IQuoter} from &quot;../../interfaces/uniswap/IQuoter.sol&quot;;</span>
   25 |     | <span class='neutral'>import {UniV3Utils} from &quot;../../utils/UniV3Utils.sol&quot;;</span>
   26 |     | <span class='neutral'></span>
   27 |     | <span class='neutral'>/// @title Beefy Passive Position Manager. Version: Velodrome</span>
   28 |     | <span class='neutral'>/// @author weso, Beefy</span>
   29 |     | <span class='neutral'>/// @notice This is a contract for managing a passive concentrated liquidity position on Velodrome.</span>
   30 | *   | <span class='executed'>contract StrategyPassiveManagerVelodrome is</span>
   31 |     | <span class='neutral'>    StratFeeManagerInitializable,</span>
   32 |     | <span class='neutral'>    IStrategyConcLiq,</span>
   33 |     | <span class='neutral'>    IStrategyVelodrome</span>
   34 |     | <span class='neutral'>{</span>
   35 |     | <span class='neutral'>    using SafeERC20 for IERC20Metadata;</span>
   36 |     | <span class='neutral'>    using TickMath for int24;</span>
   37 |     | <span class='neutral'></span>
   38 |     | <span class='neutral'>    /// @notice The precision for pricing.</span>
   39 |     | <span class='unexecuted'>    uint256 private constant PRECISION = 1e36;</span>
   40 |     | <span class='unexecuted'>    uint256 private constant SQRT_PRECISION = 1e18;</span>
   41 |     | <span class='neutral'></span>
   42 |     | <span class='neutral'>    /// @notice The max and min ticks univ3 allows.</span>
   43 |     | <span class='neutral'>    int56 private constant MIN_TICK = -887272;</span>
   44 |     | <span class='unexecuted'>    int56 private constant MAX_TICK = 887272;</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    /// @notice The address of the Velodrome pool.</span>
   47 |     | <span class='unexecuted'>    address public pool;</span>
   48 |     | <span class='neutral'>    /// @notice The address of the quoter.</span>
   49 |     | <span class='neutral'>    //audit-info What&#39;s the quoter ?</span>
   50 |     | <span class='unexecuted'>    address public quoter;</span>
   51 |     | <span class='neutral'>    /// @notice The address of the NFT position manager.</span>
   52 |     | <span class='unexecuted'>    address public nftManager;</span>
   53 |     | <span class='neutral'>    /// @notice The address of the gauge.</span>
   54 |     | <span class='neutral'>    //audit-info What&#39;s the gauge ?</span>
   55 |     | <span class='unexecuted'>    address public gauge;</span>
   56 |     | <span class='neutral'>    /// @notice The address of the output.</span>
   57 |     | <span class='unexecuted'>    address public output;</span>
   58 |     | <span class='neutral'>    /// @notice The address of the first token in the liquidity pool.</span>
   59 |     | <span class='unexecuted'>    address public lpToken0;</span>
   60 |     | <span class='neutral'>    /// @notice The address of the second token in the liquidity pool.</span>
   61 |     | <span class='unexecuted'>    address public lpToken1;</span>
   62 |     | <span class='neutral'>    /// @notice The address of the rewardPool.</span>
   63 |     | <span class='neutral'>    //audit-info What&#39;s the reward pool ? @mody: on beefy, you can stake your reipt beef tokens and get rewards on them with another native token</span>
   64 |     | <span class='unexecuted'>    address public rewardPool;</span>
   65 |     | <span class='neutral'></span>
   66 |     | <span class='neutral'>    /// @notice The amount of unharvested output in the strategy.</span>
   67 |     | <span class='unexecuted'>    uint256 public fees;</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    /// @notice The path to swap the output to the native token for fee harvesting.</span>
   70 |     | <span class='unexecuted'>    bytes public outputToNativePath;</span>
   71 |     | <span class='neutral'>    /// @notice The path to swap the first token to the native token for data pricing.</span>
   72 |     | <span class='unexecuted'>    bytes public lpToken0ToNativePath;</span>
   73 |     | <span class='neutral'>    /// @notice The path to swap the second token to the native token for data pricing.</span>
   74 |     | <span class='unexecuted'>    bytes public lpToken1ToNativePath;</span>
   75 |     | <span class='neutral'></span>
   76 |     | <span class='neutral'>    /// @notice The struct to store our tick positioning.</span>
   77 |     | <span class='neutral'>    struct Position {</span>
   78 |     | <span class='neutral'>        uint256 nftId;</span>
   79 |     | <span class='neutral'>        int24 tickLower;</span>
   80 |     | <span class='neutral'>        int24 tickUpper;</span>
   81 |     | <span class='neutral'>    }</span>
   82 |     | <span class='neutral'></span>
   83 |     | <span class='neutral'>    /// @notice The main position of the strategy.</span>
   84 |     | <span class='neutral'>    /// @dev this will always be a 50/50 position that will be equal to position width * tickSpacing on each side.</span>
   85 |     | <span class='unexecuted'>    Position public positionMain;</span>
   86 |     | <span class='neutral'></span>
   87 |     | <span class='neutral'>    /// @notice The alternative position of the strategy.</span>
   88 |     | <span class='neutral'>    /// @dev this will always be a single sided (limit order) position that will start closest to current tick and continue to width * tickSpacing.</span>
   89 |     | <span class='neutral'>    /// This will always be in the token that has the most value after we fill our main position.</span>
   90 |     | <span class='neutral'>    //audit Invariant: Alternative Position SHOULD always be in the token that has the most value</span>
   91 |     | <span class='unexecuted'>    Position public positionAlt;</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    /// @notice The width of the position, thats a multiplier for tick spacing to find our range.</span>
   94 |     | <span class='neutral'>    //audit-info Who set&#39;s that and can it be modify ? In what term ?</span>
   95 |     | <span class='unexecuted'>    int24 public positionWidth;</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    /// @notice the max tick deviations we will allow for deposits/setTick.</span>
   98 |     | <span class='neutral'>    //audit-info Who set&#39;s that and can it be modify ? In what term ?</span>
   99 |     | <span class='unexecuted'>    int56 public maxTickDeviation;</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    /// @notice The twap interval seconds we use for the twap check.</span>
  102 |     | <span class='unexecuted'>    uint32 public twapInterval;</span>
  103 |     | <span class='neutral'></span>
  104 |     | <span class='neutral'>    /// @notice Initializes the ticks on first deposit.</span>
  105 |     | <span class='neutral'>    bool private initTicks;</span>
  106 |     | <span class='neutral'></span>
  107 |     | <span class='neutral'>    // Errors</span>
  108 |     | <span class='neutral'>    error NotAuthorized();</span>
  109 |     | <span class='neutral'>    error NotPool();</span>
  110 |     | <span class='neutral'>    error InvalidEntry();</span>
  111 |     | <span class='neutral'>    error NotVault();</span>
  112 |     | <span class='neutral'>    error InvalidInput();</span>
  113 |     | <span class='neutral'>    error InvalidOutput();</span>
  114 |     | <span class='neutral'>    error NotCalm();</span>
  115 |     | <span class='neutral'>    error TooMuchSlippage();</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    // Events</span>
  118 |     | <span class='neutral'>    event TVL(uint256 bal0, uint256 bal1);</span>
  119 |     | <span class='neutral'>    event Harvest(uint256 fees);</span>
  120 |     | <span class='neutral'>    event SetPositionWidth(int24 oldWidth, int24 width);</span>
  121 |     | <span class='neutral'>    event SetDeviation(int56 maxTickDeviation);</span>
  122 |     | <span class='neutral'>    event SetTwapInterval(uint32 oldInterval, uint32 interval);</span>
  123 |     | <span class='neutral'>    event SetOutputToNativePath(bytes path);</span>
  124 |     | <span class='neutral'>    event SetRewardPool(address rewardPool);</span>
  125 |     | <span class='neutral'>    event ChargedFees(</span>
  126 |     | <span class='neutral'>        uint256 callFeeAmount,</span>
  127 |     | <span class='neutral'>        uint256 beefyFeeAmount,</span>
  128 |     | <span class='neutral'>        uint256 strategistFeeAmount</span>
  129 |     | <span class='neutral'>    );</span>
  130 |     | <span class='neutral'>    event ClaimedFees(uint256 fees);</span>
  131 |     | <span class='neutral'></span>
  132 |     | <span class='neutral'>    /// @notice Modifier to only allow deposit/setTick actions when current price is within a certain deviation of twap.</span>
  133 |     | <span class='neutral'>    modifier onlyCalmPeriods() {</span>
  134 |     | <span class='unexecuted'>        _onlyCalmPeriods();</span>
  135 |     | <span class='neutral'>        _;</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    /// @notice function to only allow deposit/setTick actions when current price is within a certain deviation of twap.</span>
  139 |     | <span class='unexecuted'>    function _onlyCalmPeriods() private view {</span>
  140 |     | <span class='unexecuted'>        if (!isCalm()) revert NotCalm();</span>
  141 |     | <span class='neutral'>    }</span>
  142 |     | <span class='neutral'></span>
  143 |     | <span class='neutral'>    //audit-info Assuming the rebalancer is the Gelato bot</span>
  144 |     | <span class='neutral'>    modifier onlyRebalancers() {</span>
  145 |     | <span class='unexecuted'>        if (!IStrategyFactory(factory).rebalancers(msg.sender))</span>
  146 |     | <span class='unexecuted'>            revert NotAuthorized();</span>
  147 |     | <span class='neutral'>        _;</span>
  148 |     | <span class='neutral'>    }</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>    /// @notice function to only allow deposit/setTick actions when current price is within a certain deviation of twap.</span>
  151 |     | <span class='neutral'>    //audit Crutial function imo</span>
  152 |     | <span class='unexecuted'>    function isCalm() public view returns (bool) {</span>
  153 |     | <span class='unexecuted'>        int24 tick = currentTick();</span>
  154 |     | <span class='unexecuted'>        int56 twapTick = twap();</span>
  155 |     | <span class='neutral'></span>
  156 |     | <span class='unexecuted'>        int56 minCalmTick = int56(</span>
  157 |     | <span class='unexecuted'>            SignedMath.max(twapTick - maxTickDeviation, MIN_TICK)</span>
  158 |     | <span class='neutral'>        );</span>
  159 |     | <span class='unexecuted'>        int56 maxCalmTick = int56(</span>
  160 |     | <span class='unexecuted'>            SignedMath.min(twapTick + maxTickDeviation, MAX_TICK)</span>
  161 |     | <span class='neutral'>        );</span>
  162 |     | <span class='neutral'></span>
  163 |     | <span class='neutral'>        // Calculate if tick move more than allowed from twap and revert if it did.</span>
  164 |     | <span class='unexecuted'>        if (minCalmTick &gt; tick || maxCalmTick &lt; tick) return false;</span>
  165 |     | <span class='unexecuted'>        else return true;</span>
  166 |     | <span class='neutral'>    }</span>
  167 |     | <span class='neutral'></span>
  168 |     | <span class='neutral'>    /**</span>
  169 |     | <span class='neutral'>     * @notice Initializes the strategy and the inherited strat fee manager.</span>
  170 |     | <span class='neutral'>     * @dev Make sure cardinality is set appropriately for the twap.</span>
  171 |     | <span class='neutral'>     * @param _pool The underlying Velodrome pool.</span>
  172 |     | <span class='neutral'>     * @param _nftManager The NFT position manager.</span>
  173 |     | <span class='neutral'>     * @param _output The output token for the strategy.</span>
  174 |     | <span class='neutral'>     * @param _positionWidth The multiplier for tick spacing to find our range.</span>
  175 |     | <span class='neutral'>     * @param _paths The bytes paths for swapping (Output To Native, Token0 to Native, Token1 to Native).</span>
  176 |     | <span class='neutral'>     * @param _commonAddresses The common addresses needed for the strat fee manager.</span>
  177 |     | <span class='neutral'>     */</span>
  178 | *   | <span class='executed'>    function initialize(</span>
  179 |     | <span class='neutral'>        address _pool,</span>
  180 |     | <span class='neutral'>        address _quoter,</span>
  181 |     | <span class='neutral'>        address _nftManager,</span>
  182 |     | <span class='neutral'>        address _gauge,</span>
  183 |     | <span class='neutral'>        address _rewardPool,</span>
  184 |     | <span class='neutral'>        address _output,</span>
  185 |     | <span class='neutral'>        int24 _positionWidth,</span>
  186 |     | <span class='neutral'>        bytes[] calldata _paths,</span>
  187 |     | <span class='neutral'>        CommonAddresses calldata _commonAddresses</span>
  188 |     | <span class='neutral'>    ) external initializer {</span>
  189 | *   | <span class='executed'>        __StratFeeManager_init(_commonAddresses);</span>
  190 |     | <span class='neutral'></span>
  191 | *   | <span class='executed'>        pool = _pool;</span>
  192 | *   | <span class='executed'>        quoter = _quoter;</span>
  193 | *   | <span class='executed'>        output = _output;</span>
  194 | *   | <span class='executed'>        nftManager = _nftManager;</span>
  195 | *   | <span class='executed'>        gauge = _gauge;</span>
  196 | *   | <span class='executed'>        rewardPool = _rewardPool;</span>
  197 |     | <span class='neutral'></span>
  198 | *   | <span class='executed'>        lpToken0 = IVeloPool(_pool).token0();</span>
  199 |     | <span class='unexecuted'>        lpToken1 = IVeloPool(_pool).token1();</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>        // Our width multiplier. The tick distance of each side will be width * tickSpacing.</span>
  202 |     | <span class='unexecuted'>        positionWidth = _positionWidth;</span>
  203 |     | <span class='neutral'></span>
  204 |     | <span class='unexecuted'>        outputToNativePath = _paths[0];</span>
  205 |     | <span class='unexecuted'>        lpToken0ToNativePath = _paths[1];</span>
  206 |     | <span class='unexecuted'>        lpToken1ToNativePath = _paths[2];</span>
  207 |     | <span class='neutral'></span>
  208 |     | <span class='neutral'>        // Set the twap interval to 120 seconds.</span>
  209 |     | <span class='unexecuted'>        twapInterval = 120;</span>
  210 |     | <span class='neutral'></span>
  211 |     | <span class='unexecuted'>        _giveAllowances();</span>
  212 |     | <span class='neutral'>    }</span>
  213 |     | <span class='neutral'></span>
  214 |     | <span class='neutral'>    /// @notice Only allows the vault to call a function.</span>
  215 |     | <span class='neutral'>    //audit Can the vault address be changed ?</span>
  216 |     | <span class='unexecuted'>    function _onlyVault() private view {</span>
  217 |     | <span class='unexecuted'>        if (msg.sender != vault) revert NotVault();</span>
  218 |     | <span class='neutral'>    }</span>
  219 |     | <span class='neutral'></span>
  220 |     | <span class='neutral'>    /// @notice Called during deposit and withdraw to remove liquidity and harvest fees for accounting purposes.</span>
  221 | *   | <span class='executed'>    function beforeAction() external {</span>
  222 |     | <span class='unexecuted'>        _onlyVault();</span>
  223 |     | <span class='unexecuted'>        _claimEarnings();</span>
  224 | *   | <span class='executed'>        _removeLiquidity();</span>
  225 |     | <span class='neutral'>    }</span>
  226 |     | <span class='neutral'></span>
  227 |     | <span class='neutral'>    /// @notice Called during deposit to add all liquidity back to their positions.</span>
  228 |     | <span class='unexecuted'>    function deposit() external onlyCalmPeriods {</span>
  229 |     | <span class='unexecuted'>        _onlyVault();</span>
  230 |     | <span class='neutral'></span>
  231 |     | <span class='unexecuted'>        if (!initTicks) {</span>
  232 |     | <span class='unexecuted'>            _setTicks();</span>
  233 |     | <span class='unexecuted'>            initTicks = true;</span>
  234 |     | <span class='neutral'>        }</span>
  235 |     | <span class='neutral'></span>
  236 |     | <span class='neutral'>        // Add all liquidity</span>
  237 |     | <span class='unexecuted'>        _addLiquidity();</span>
  238 |     | <span class='neutral'></span>
  239 |     | <span class='neutral'>        (uint256 bal0, uint256 bal1) = balances();</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>        // TVL Balances after deposit</span>
  242 |     | <span class='neutral'>        emit TVL(bal0, bal1);</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    /**</span>
  246 |     | <span class='neutral'>     * @notice Withdraws the specified amount of tokens from the strategy as calculated by the vault.</span>
  247 |     | <span class='neutral'>     * @param _amount0 The amount of token0 to withdraw.</span>
  248 |     | <span class='neutral'>     * @param _amount1 The amount of token1 to withdraw.</span>
  249 |     | <span class='neutral'>     */</span>
  250 |     | <span class='unexecuted'>    function withdraw(uint256 _amount0, uint256 _amount1) external {</span>
  251 |     | <span class='unexecuted'>        _onlyVault();</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>        // Liquidity has already been removed in beforeAction() so this is just a simple withdraw.</span>
  254 |     | <span class='unexecuted'>        if (_amount0 &gt; 0)</span>
  255 |     | <span class='unexecuted'>            IERC20Metadata(lpToken0).safeTransfer(vault, _amount0);</span>
  256 |     | <span class='unexecuted'>        if (_amount1 &gt; 0)</span>
  257 |     | <span class='unexecuted'>            IERC20Metadata(lpToken1).safeTransfer(vault, _amount1);</span>
  258 |     | <span class='neutral'></span>
  259 |     | <span class='neutral'>        // After we take what is needed we add it all back to our positions.</span>
  260 |     | <span class='unexecuted'>        if (!_isPaused()) _addLiquidity();</span>
  261 |     | <span class='neutral'></span>
  262 |     | <span class='unexecuted'>        (uint256 bal0, uint256 bal1) = balances();</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>        // TVL Balances after withdraw</span>
  265 |     | <span class='unexecuted'>        emit TVL(bal0, bal1);</span>
  266 |     | <span class='neutral'>    }</span>
  267 |     | <span class='neutral'></span>
  268 |     | <span class='neutral'>    /// @notice Adds liquidity to the main and alternative positions called on deposit, harvest and withdraw.</span>
  269 |     | <span class='unexecuted'>    function _addLiquidity() private {</span>
  270 |     | <span class='unexecuted'>        _whenStrategyNotPaused(); //revert if the Stategy is Paused</span>
  271 |     | <span class='neutral'></span>
  272 |     | <span class='unexecuted'>        (uint256 bal0, uint256 bal1) = balancesOfThis();</span>
  273 |     | <span class='neutral'></span>
  274 |     | <span class='unexecuted'>        int24 mainLower = positionMain.tickLower; //get the tick Lower of Main position</span>
  275 |     | <span class='unexecuted'>        int24 mainUpper = positionMain.tickUpper; //get the tick Upper of Main position</span>
  276 |     | <span class='unexecuted'>        int24 altLower = positionAlt.tickLower; //get the tick Lower of Alt position</span>
  277 |     | <span class='unexecuted'>        int24 altUpper = positionAlt.tickUpper; //get the tick Upper of Alt position</span>
  278 |     | <span class='neutral'></span>
  279 |     | <span class='neutral'>        // Then we fetch how much liquidity we get for adding at the main position ticks with our token balances.</span>
  280 |     | <span class='unexecuted'>        uint160 sqrtprice = sqrtPrice();</span>
  281 |     | <span class='unexecuted'>        uint128 liquidity = LiquidityAmounts.getLiquidityForAmounts(</span>
  282 |     | <span class='unexecuted'>            sqrtprice,</span>
  283 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(mainLower),</span>
  284 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(mainUpper),</span>
  285 |     | <span class='unexecuted'>            bal0,</span>
  286 |     | <span class='unexecuted'>            bal1</span>
  287 |     | <span class='neutral'>        );</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='unexecuted'>        (uint256 amount0, uint256 amount1) = LiquidityAmounts</span>
  290 |     | <span class='neutral'>            .getAmountsForLiquidity(</span>
  291 |     | <span class='unexecuted'>                sqrtprice,</span>
  292 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(mainLower),</span>
  293 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(mainUpper),</span>
  294 |     | <span class='unexecuted'>                liquidity</span>
  295 |     | <span class='neutral'>            );</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='unexecuted'>        bool amountsOk = _checkAmounts(liquidity, mainLower, mainUpper);</span>
  298 |     | <span class='neutral'></span>
  299 |     | <span class='neutral'>        // Mint or add liquidity to the position.</span>
  300 |     | <span class='unexecuted'>        if (liquidity &gt; 0 &amp;&amp; amountsOk) {</span>
  301 |     | <span class='neutral'>            //audit-info Mint position if the user has some liquidity in main</span>
  302 |     | <span class='unexecuted'>            _mintPosition(mainLower, mainUpper, amount0, amount1, true);</span>
  303 |     | <span class='neutral'>        }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='unexecuted'>        (bal0, bal1) = balancesOfThis();</span>
  306 |     | <span class='neutral'></span>
  307 |     | <span class='neutral'>        // Fetch how much liquidity we get for adding at the alternative position ticks with our token balances.</span>
  308 |     | <span class='unexecuted'>        liquidity = LiquidityAmounts.getLiquidityForAmounts(</span>
  309 |     | <span class='unexecuted'>            sqrtprice,</span>
  310 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(altLower),</span>
  311 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(altUpper),</span>
  312 |     | <span class='unexecuted'>            bal0,</span>
  313 |     | <span class='unexecuted'>            bal1</span>
  314 |     | <span class='neutral'>        );</span>
  315 |     | <span class='neutral'></span>
  316 |     | <span class='unexecuted'>        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(</span>
  317 |     | <span class='unexecuted'>            sqrtprice,</span>
  318 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(altLower),</span>
  319 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(altUpper),</span>
  320 |     | <span class='unexecuted'>            liquidity</span>
  321 |     | <span class='neutral'>        );</span>
  322 |     | <span class='neutral'></span>
  323 |     | <span class='neutral'>        // Mint or add liquidity to the position.</span>
  324 |     | <span class='unexecuted'>        if (liquidity &gt; 0 &amp;&amp; (amount0 &gt; 0 || amount1 &gt; 0)) {</span>
  325 |     | <span class='neutral'>            //audit-info Mint position if the user has some liquidity in alt</span>
  326 |     | <span class='unexecuted'>            _mintPosition(altLower, altUpper, amount0, amount1, false);</span>
  327 |     | <span class='neutral'>        }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='unexecuted'>        if (positionMain.nftId != 0)</span>
  330 |     | <span class='unexecuted'>            ICLGauge(gauge).deposit(positionMain.nftId);</span>
  331 |     | <span class='unexecuted'>        if (positionAlt.nftId != 0) ICLGauge(gauge).deposit(positionAlt.nftId);</span>
  332 |     | <span class='neutral'>    }</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>    /// @notice Mints a new position for the main or alternative position.</span>
  335 |     | <span class='unexecuted'>    function _mintPosition(</span>
  336 |     | <span class='neutral'>        int24 _tickLower,</span>
  337 |     | <span class='neutral'>        int24 _tickUpper,</span>
  338 |     | <span class='neutral'>        uint256 _amount0,</span>
  339 |     | <span class='neutral'>        uint256 _amount1,</span>
  340 |     | <span class='neutral'>        bool _mainPosition</span>
  341 |     | <span class='neutral'>    ) private {</span>
  342 |     | <span class='unexecuted'>        INftPositionManager.MintParams memory mintParams = INftPositionManager</span>
  343 |     | <span class='neutral'>            .MintParams({</span>
  344 |     | <span class='unexecuted'>                token0: lpToken0,</span>
  345 |     | <span class='unexecuted'>                token1: lpToken1,</span>
  346 |     | <span class='unexecuted'>                tickSpacing: _tickDistance(),</span>
  347 |     | <span class='unexecuted'>                tickLower: _tickLower,</span>
  348 |     | <span class='unexecuted'>                tickUpper: _tickUpper,</span>
  349 |     | <span class='unexecuted'>                amount0Desired: _amount0,</span>
  350 |     | <span class='unexecuted'>                amount1Desired: _amount1,</span>
  351 |     | <span class='unexecuted'>                amount0Min: 0,</span>
  352 |     | <span class='unexecuted'>                amount1Min: 0,</span>
  353 |     | <span class='unexecuted'>                recipient: address(this),</span>
  354 |     | <span class='unexecuted'>                deadline: block.timestamp,</span>
  355 |     | <span class='unexecuted'>                sqrtPriceX96: 0</span>
  356 |     | <span class='neutral'>            });</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='unexecuted'>        (uint256 nftId, , , ) = INftPositionManager(nftManager).mint(</span>
  359 |     | <span class='unexecuted'>            mintParams</span>
  360 |     | <span class='neutral'>        );</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='unexecuted'>        if (_mainPosition) positionMain.nftId = nftId;</span>
  363 |     | <span class='unexecuted'>        else positionAlt.nftId = nftId;</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='unexecuted'>        IERC721(nftManager).approve(gauge, nftId);</span>
  366 |     | <span class='neutral'>    }</span>
  367 |     | <span class='neutral'></span>
  368 |     | <span class='neutral'>    /// @notice Removes liquidity from the main and alternative positions, called on deposit, withdraw and harvest.</span>
  369 |     | <span class='unexecuted'>    function _removeLiquidity() private {</span>
  370 |     | <span class='unexecuted'>        uint128 liquidity;</span>
  371 |     | <span class='neutral'>        uint128 liquidityAlt;</span>
  372 |     | <span class='unexecuted'>        if (positionMain.nftId != 0) {</span>
  373 |     | <span class='unexecuted'>            (, , , , , , , liquidity, , , , ) = INftPositionManager(nftManager)</span>
  374 |     | <span class='unexecuted'>                .positions(positionMain.nftId);</span>
  375 |     | <span class='unexecuted'>            ICLGauge(gauge).withdraw(positionMain.nftId);</span>
  376 |     | <span class='neutral'>        }</span>
  377 |     | <span class='neutral'></span>
  378 |     | <span class='unexecuted'>        if (positionAlt.nftId != 0) {</span>
  379 |     | <span class='unexecuted'>            (, , , , , , , liquidityAlt, , , , ) = INftPositionManager(</span>
  380 |     | <span class='unexecuted'>                nftManager</span>
  381 |     | <span class='unexecuted'>            ).positions(positionAlt.nftId);</span>
  382 |     | <span class='unexecuted'>            ICLGauge(gauge).withdraw(positionAlt.nftId);</span>
  383 |     | <span class='neutral'>        }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>        // init our params</span>
  386 |     | <span class='unexecuted'>        INftPositionManager.DecreaseLiquidityParams</span>
  387 |     | <span class='neutral'>            memory decreaseLiquidityParams;</span>
  388 |     | <span class='neutral'>        INftPositionManager.CollectParams memory collectParams;</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>        // If we have liquidity in the positions we remove it and collect our tokens.</span>
  391 |     | <span class='unexecuted'>        if (liquidity &gt; 0) {</span>
  392 |     | <span class='unexecuted'>            decreaseLiquidityParams = INftPositionManager</span>
  393 |     | <span class='neutral'>                .DecreaseLiquidityParams({</span>
  394 |     | <span class='unexecuted'>                    tokenId: positionMain.nftId,</span>
  395 |     | <span class='neutral'>                    liquidity: liquidity,</span>
  396 |     | <span class='neutral'>                    amount0Min: 0,</span>
  397 |     | <span class='neutral'>                    amount1Min: 0,</span>
  398 |     | <span class='unexecuted'>                    deadline: block.timestamp</span>
  399 |     | <span class='neutral'>                });</span>
  400 |     | <span class='neutral'>            //audit Is it possible to have 0 liquidity and still have some fees left to collect ?</span>
  401 |     | <span class='neutral'>            //audit If that&#39;s the case, the fees aren&#39;t collected, and the positions isn&#39;t burn.</span>
  402 |     | <span class='unexecuted'>            collectParams = INftPositionManager.CollectParams({</span>
  403 |     | <span class='neutral'>                tokenId: positionMain.nftId,</span>
  404 |     | <span class='unexecuted'>                recipient: address(this),</span>
  405 |     | <span class='neutral'>                amount0Max: type(uint128).max,</span>
  406 |     | <span class='neutral'>                amount1Max: type(uint128).max</span>
  407 |     | <span class='neutral'>            });</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='unexecuted'>            INftPositionManager(nftManager).decreaseLiquidity(</span>
  410 |     | <span class='neutral'>                decreaseLiquidityParams</span>
  411 |     | <span class='neutral'>            );</span>
  412 |     | <span class='unexecuted'>            INftPositionManager(nftManager).collect(collectParams);</span>
  413 |     | <span class='unexecuted'>            INftPositionManager(nftManager).burn(positionMain.nftId);</span>
  414 |     | <span class='unexecuted'>            positionMain.nftId = 0;</span>
  415 |     | <span class='neutral'>        }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='unexecuted'>        if (liquidityAlt &gt; 0) {</span>
  418 |     | <span class='unexecuted'>            decreaseLiquidityParams = INftPositionManager</span>
  419 |     | <span class='neutral'>                .DecreaseLiquidityParams({</span>
  420 |     | <span class='unexecuted'>                    tokenId: positionAlt.nftId,</span>
  421 |     | <span class='neutral'>                    liquidity: liquidityAlt,</span>
  422 |     | <span class='neutral'>                    amount0Min: 0,</span>
  423 |     | <span class='neutral'>                    amount1Min: 0,</span>
  424 |     | <span class='unexecuted'>                    deadline: block.timestamp</span>
  425 |     | <span class='neutral'>                });</span>
  426 |     | <span class='neutral'></span>
  427 |     | <span class='unexecuted'>            collectParams = INftPositionManager.CollectParams({</span>
  428 |     | <span class='neutral'>                tokenId: positionAlt.nftId,</span>
  429 |     | <span class='unexecuted'>                recipient: address(this),</span>
  430 |     | <span class='neutral'>                amount0Max: type(uint128).max,</span>
  431 |     | <span class='neutral'>                amount1Max: type(uint128).max</span>
  432 |     | <span class='neutral'>            });</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='unexecuted'>            INftPositionManager(nftManager).decreaseLiquidity(</span>
  435 |     | <span class='neutral'>                decreaseLiquidityParams</span>
  436 |     | <span class='neutral'>            );</span>
  437 |     | <span class='unexecuted'>            INftPositionManager(nftManager).collect(collectParams);</span>
  438 |     | <span class='unexecuted'>            INftPositionManager(nftManager).burn(positionAlt.nftId);</span>
  439 |     | <span class='unexecuted'>            positionAlt.nftId = 0;</span>
  440 |     | <span class='neutral'>        }</span>
  441 |     | <span class='neutral'>    }</span>
  442 |     | <span class='neutral'></span>
  443 |     | <span class='neutral'>    /**</span>
  444 |     | <span class='neutral'>     *  @notice Checks if the amounts are ok to add liquidity.</span>
  445 |     | <span class='neutral'>     * @param _liquidity The liquidity to add.</span>
  446 |     | <span class='neutral'>     * @param _tickLower The lower tick of the position.</span>
  447 |     | <span class='neutral'>     * @param _tickUpper The upper tick of the position.</span>
  448 |     | <span class='neutral'>     * @return bool True if the amounts are ok, false if not.</span>
  449 |     | <span class='neutral'>     */</span>
  450 |     | <span class='unexecuted'>    function _checkAmounts(</span>
  451 |     | <span class='neutral'>        uint128 _liquidity,</span>
  452 |     | <span class='neutral'>        int24 _tickLower,</span>
  453 |     | <span class='neutral'>        int24 _tickUpper</span>
  454 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
  455 |     | <span class='unexecuted'>        (uint256 amount0, uint256 amount1) = LiquidityAmounts</span>
  456 |     | <span class='neutral'>            .getAmountsForLiquidity(</span>
  457 |     | <span class='unexecuted'>                sqrtPrice(),</span>
  458 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(_tickLower),</span>
  459 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(_tickUpper),</span>
  460 |     | <span class='neutral'>                _liquidity</span>
  461 |     | <span class='neutral'>            );</span>
  462 |     | <span class='neutral'></span>
  463 |     | <span class='unexecuted'>        if (amount0 == 0 || amount1 == 0) return false;</span>
  464 |     | <span class='unexecuted'>        else return true;</span>
  465 |     | <span class='neutral'>    }</span>
  466 |     | <span class='neutral'></span>
  467 |     | <span class='neutral'>    /// @notice Function called to rebalance the position</span>
  468 |     | <span class='unexecuted'>    function moveTicks() external onlyCalmPeriods onlyRebalancers {</span>
  469 |     | <span class='unexecuted'>        _claimEarnings();</span>
  470 |     | <span class='unexecuted'>        _removeLiquidity();</span>
  471 |     | <span class='unexecuted'>        _setTicks();</span>
  472 |     | <span class='unexecuted'>        _addLiquidity();</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='unexecuted'>        (uint256 bal0, uint256 bal1) = balances();</span>
  475 |     | <span class='unexecuted'>        emit TVL(bal0, bal1);</span>
  476 |     | <span class='neutral'>    }</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>    /// @notice Harvest call to claim rewards from gauge then charge fees for Beefy and notify rewards.</span>
  479 |     | <span class='neutral'>    /// @param _callFeeRecipient The address to send the call fee to.</span>
  480 | *   | <span class='executed'>    function harvest(address _callFeeRecipient) external {</span>
  481 | *   | <span class='executed'>        _harvest(_callFeeRecipient);</span>
  482 |     | <span class='neutral'>    }</span>
  483 |     | <span class='neutral'></span>
  484 |     | <span class='neutral'>    /// @notice Harvest call to claim rewards from gauge then charge fees for Beefy and notify rewards.</span>
  485 |     | <span class='neutral'>    /// @dev Call fee goes to the tx.origin.</span>
  486 |     | <span class='unexecuted'>    function harvest() external {</span>
  487 |     | <span class='neutral'>        //audit-info Why not use msg.sender ? Account Abstraction EIP4337 is not compatible</span>
  488 |     | <span class='unexecuted'>        _harvest(tx.origin);</span>
  489 |     | <span class='neutral'>    }</span>
  490 |     | <span class='neutral'></span>
  491 |     | <span class='neutral'>    /// @notice Internal function to claim rewards from gauge then charge fees for Beefy and notify rewards</span>
  492 |     | <span class='unexecuted'>    function _harvest(address _callFeeRecipient) private {</span>
  493 |     | <span class='neutral'>        // Claim rewards from gauge</span>
  494 |     | <span class='unexecuted'>        _claimEarnings();</span>
  495 |     | <span class='neutral'></span>
  496 |     | <span class='neutral'>        // Charge fees for Beefy and send them to the appropriate addresses, charge fees to accrued state fee amounts.</span>
  497 |     | <span class='unexecuted'>        uint256 feeLeft = _chargeFees(_callFeeRecipient, fees);</span>
  498 |     | <span class='neutral'></span>
  499 |     | <span class='neutral'>        // Reset state fees to 0.</span>
  500 |     | <span class='unexecuted'>        fees = 0;</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='neutral'>        // Notify rewards with our velo.</span>
  503 |     | <span class='unexecuted'>        IRewardPool(rewardPool).notifyRewardAmount(output, feeLeft, 1 days);</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>        // Log the last time we claimed fees.</span>
  506 |     | <span class='unexecuted'>        lastHarvest = block.timestamp;</span>
  507 |     | <span class='neutral'></span>
  508 |     | <span class='neutral'>        // Log the fees post Beefy fees.</span>
  509 |     | <span class='unexecuted'>        emit Harvest(feeLeft);</span>
  510 |     | <span class='neutral'>    }</span>
  511 |     | <span class='neutral'></span>
  512 |     | <span class='neutral'>    /// @notice Internal function to claim rewards from the gauge and collect them.</span>
  513 |     | <span class='unexecuted'>    function _claimEarnings() private {</span>
  514 |     | <span class='neutral'>        // Claim rewards</span>
  515 |     | <span class='unexecuted'>        uint256 feeBefore = IERC20Metadata(output).balanceOf(address(this));</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>        //audit-info How this is working ? Is this contract suppose to receive some tokens ?</span>
  518 |     | <span class='unexecuted'>        if (positionMain.nftId != 0)</span>
  519 |     | <span class='unexecuted'>            ICLGauge(gauge).getReward(positionMain.nftId);</span>
  520 |     | <span class='unexecuted'>        if (positionAlt.nftId != 0)</span>
  521 |     | <span class='unexecuted'>            ICLGauge(gauge).getReward(positionAlt.nftId);</span>
  522 |     | <span class='neutral'></span>
  523 |     | <span class='unexecuted'>        uint256 claimed = IERC20Metadata(output).balanceOf(address(this)) -</span>
  524 |     | <span class='unexecuted'>            feeBefore;</span>
  525 |     | <span class='unexecuted'>        fees = fees + claimed;</span>
  526 |     | <span class='neutral'></span>
  527 |     | <span class='unexecuted'>        emit ClaimedFees(claimed);</span>
  528 |     | <span class='neutral'>    }</span>
  529 |     | <span class='neutral'></span>
  530 |     | <span class='neutral'>    /**</span>
  531 |     | <span class='neutral'>     * @notice Internal function to charge fees for Beefy and send them to the appropriate addresses.</span>
  532 |     | <span class='neutral'>     * @param _callFeeRecipient The address to send the call fee to.</span>
  533 |     | <span class='neutral'>     * @param _amount The amount of output to charge fees on.</span>
  534 |     | <span class='neutral'>     * @return _amountLeft The amount of token0 left after fees.</span>
  535 |     | <span class='neutral'>     */</span>
  536 |     | <span class='unexecuted'>    function _chargeFees(</span>
  537 |     | <span class='neutral'>        address _callFeeRecipient,</span>
  538 |     | <span class='neutral'>        uint256 _amount</span>
  539 |     | <span class='unexecuted'>    ) private returns (uint256 _amountLeft) {</span>
  540 |     | <span class='neutral'>        /// Fetch our fee percentage amounts from the fee config.</span>
  541 |     | <span class='unexecuted'>        IFeeConfig.FeeCategory memory fee = getFees();</span>
  542 |     | <span class='neutral'></span>
  543 |     | <span class='neutral'>        /// We calculate how much to swap and then swap both tokens to native and charge fees.</span>
  544 |     | <span class='unexecuted'>        uint256 nativeEarned;</span>
  545 |     | <span class='unexecuted'>        if (_amount &gt; 0) {</span>
  546 |     | <span class='neutral'>            // Calculate amount of token 0 to swap for fees.</span>
  547 |     | <span class='unexecuted'>            uint256 amountToSwap = (_amount * fee.total) / DIVISOR;</span>
  548 |     | <span class='unexecuted'>            _amountLeft = _amount - amountToSwap;</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>            // If token0 is not native, swap to native the fee amount.</span>
  551 |     | <span class='unexecuted'>            uint256 out;</span>
  552 |     | <span class='unexecuted'>            uint256 nativeBefore = IERC20Metadata(native).balanceOf(</span>
  553 |     | <span class='unexecuted'>                address(this)</span>
  554 |     | <span class='neutral'>            );</span>
  555 |     | <span class='unexecuted'>            if (output != native) {</span>
  556 |     | <span class='unexecuted'>                VeloSwapUtils.swap(</span>
  557 |     | <span class='unexecuted'>                    unirouter,</span>
  558 |     | <span class='unexecuted'>                    outputToNativePath,</span>
  559 |     | <span class='unexecuted'>                    amountToSwap,</span>
  560 |     | <span class='unexecuted'>                    true</span>
  561 |     | <span class='neutral'>                );</span>
  562 |     | <span class='unexecuted'>                out =</span>
  563 |     | <span class='unexecuted'>                    IERC20Metadata(native).balanceOf(address(this)) -</span>
  564 |     | <span class='unexecuted'>                    nativeBefore;</span>
  565 |     | <span class='neutral'>            }</span>
  566 |     | <span class='neutral'></span>
  567 |     | <span class='neutral'>            // Add the native earned to the total of native we earned for beefy fees, handle if token0 is native.</span>
  568 |     | <span class='unexecuted'>            if (output == native) nativeEarned += amountToSwap;</span>
  569 |     | <span class='unexecuted'>            else nativeEarned += out;</span>
  570 |     | <span class='neutral'>        }</span>
  571 |     | <span class='neutral'></span>
  572 |     | <span class='neutral'>        // Distribute the native earned to the appropriate addresses.</span>
  573 |     | <span class='unexecuted'>        uint256 callFeeAmount = (nativeEarned * fee.call) / DIVISOR;</span>
  574 |     | <span class='unexecuted'>        IERC20Metadata(native).safeTransfer(_callFeeRecipient, callFeeAmount);</span>
  575 |     | <span class='neutral'></span>
  576 |     | <span class='unexecuted'>        uint256 strategistFeeAmount = (nativeEarned * fee.strategist) / DIVISOR;</span>
  577 |     | <span class='unexecuted'>        IERC20Metadata(native).safeTransfer(strategist, strategistFeeAmount);</span>
  578 |     | <span class='neutral'></span>
  579 |     | <span class='unexecuted'>        uint256 beefyFeeAmount = nativeEarned -</span>
  580 |     | <span class='unexecuted'>            callFeeAmount -</span>
  581 |     | <span class='unexecuted'>            strategistFeeAmount;</span>
  582 |     | <span class='unexecuted'>        IERC20Metadata(native).safeTransfer(</span>
  583 |     | <span class='unexecuted'>            beefyFeeRecipient(),</span>
  584 |     | <span class='unexecuted'>            beefyFeeAmount</span>
  585 |     | <span class='neutral'>        );</span>
  586 |     | <span class='neutral'></span>
  587 |     | <span class='unexecuted'>        emit ChargedFees(callFeeAmount, beefyFeeAmount, strategistFeeAmount);</span>
  588 |     | <span class='neutral'>    }</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>    /**</span>
  591 |     | <span class='neutral'>     * @notice Returns total token balances in the strategy.</span>
  592 |     | <span class='neutral'>     * @return token0Bal The amount of token0 in the strategy.</span>
  593 |     | <span class='neutral'>     * @return token1Bal The amount of token1 in the strategy.</span>
  594 |     | <span class='neutral'>     */</span>
  595 |     | <span class='unexecuted'>    function balances()</span>
  596 |     | <span class='neutral'>        public</span>
  597 |     | <span class='neutral'>        view</span>
  598 |     | <span class='unexecuted'>        returns (uint256 token0Bal, uint256 token1Bal)</span>
  599 |     | <span class='neutral'>    {</span>
  600 |     | <span class='unexecuted'>        (uint256 thisBal0, uint256 thisBal1) = balancesOfThis();</span>
  601 |     | <span class='unexecuted'>        (uint256 poolBal0, uint256 poolBal1, , , , ) = balancesOfPool();</span>
  602 |     | <span class='neutral'></span>
  603 |     | <span class='unexecuted'>        uint256 total0 = thisBal0 + poolBal0;</span>
  604 |     | <span class='unexecuted'>        uint256 total1 = thisBal1 + poolBal1;</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>        // For token0 and token1 we return balance of this contract + balance of positions - feesUnharvested.</span>
  607 |     | <span class='unexecuted'>        return (total0, total1);</span>
  608 |     | <span class='neutral'>    }</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    /**</span>
  611 |     | <span class='neutral'>     * @notice Returns total tokens sitting in the strategy.</span>
  612 |     | <span class='neutral'>     * @return token0Bal The amount of token0 in the strategy.</span>
  613 |     | <span class='neutral'>     * @return token1Bal The amount of token1 in the strategy.</span>
  614 |     | <span class='neutral'>     */</span>
  615 |     | <span class='unexecuted'>    function balancesOfThis()</span>
  616 |     | <span class='neutral'>        public</span>
  617 |     | <span class='neutral'>        view</span>
  618 |     | <span class='unexecuted'>        returns (uint256 token0Bal, uint256 token1Bal)</span>
  619 |     | <span class='neutral'>    {</span>
  620 |     | <span class='unexecuted'>        return (</span>
  621 |     | <span class='unexecuted'>            IERC20Metadata(lpToken0).balanceOf(address(this)),</span>
  622 |     | <span class='unexecuted'>            IERC20Metadata(lpToken1).balanceOf(address(this))</span>
  623 |     | <span class='neutral'>        );</span>
  624 |     | <span class='neutral'>    }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>    /**</span>
  627 |     | <span class='neutral'>     * @notice Returns total tokens in pool positions (is a calculation which means it could be a little off by a few wei).</span>
  628 |     | <span class='neutral'>     * @return token0Bal The amount of token0 in the pool.</span>
  629 |     | <span class='neutral'>     * @return token1Bal The amount of token1 in the pool.</span>
  630 |     | <span class='neutral'>     * @return mainAmount0 The amount of token0 in the main position.</span>
  631 |     | <span class='neutral'>     * @return mainAmount1 The amount of token1 in the main position.</span>
  632 |     | <span class='neutral'>     * @return altAmount0 The amount of token0 in the alt position.</span>
  633 |     | <span class='neutral'>     * @return altAmount1 The amount of token1 in the alt position.</span>
  634 |     | <span class='neutral'>     */</span>
  635 |     | <span class='unexecuted'>    function balancesOfPool()</span>
  636 |     | <span class='neutral'>        public</span>
  637 |     | <span class='neutral'>        view</span>
  638 |     | <span class='neutral'>        returns (</span>
  639 |     | <span class='unexecuted'>            uint256 token0Bal,</span>
  640 |     | <span class='unexecuted'>            uint256 token1Bal,</span>
  641 |     | <span class='unexecuted'>            uint256 mainAmount0,</span>
  642 |     | <span class='unexecuted'>            uint256 mainAmount1,</span>
  643 |     | <span class='unexecuted'>            uint256 altAmount0,</span>
  644 |     | <span class='unexecuted'>            uint256 altAmount1</span>
  645 |     | <span class='neutral'>        )</span>
  646 |     | <span class='unexecuted'>    {</span>
  647 |     | <span class='unexecuted'>        uint160 sqrtPriceX96 = sqrtPrice();</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='unexecuted'>        uint128 liquidity;</span>
  650 |     | <span class='unexecuted'>        uint128 altLiquidity;</span>
  651 |     | <span class='unexecuted'>        uint256 owed0;</span>
  652 |     | <span class='unexecuted'>        uint256 owed1;</span>
  653 |     | <span class='unexecuted'>        uint256 altOwed0;</span>
  654 |     | <span class='unexecuted'>        uint256 altOwed1;</span>
  655 |     | <span class='unexecuted'>        if (positionMain.nftId != 0)</span>
  656 |     | <span class='unexecuted'>            (, , , , , , , liquidity, , , owed0, owed1) = INftPositionManager(</span>
  657 |     | <span class='unexecuted'>                nftManager</span>
  658 |     | <span class='unexecuted'>            ).positions(positionMain.nftId);</span>
  659 |     | <span class='unexecuted'>        if (positionAlt.nftId != 0)</span>
  660 |     | <span class='unexecuted'>            (</span>
  661 |     | <span class='neutral'>                ,</span>
  662 |     | <span class='neutral'>                ,</span>
  663 |     | <span class='neutral'>                ,</span>
  664 |     | <span class='neutral'>                ,</span>
  665 |     | <span class='neutral'>                ,</span>
  666 |     | <span class='neutral'>                ,</span>
  667 |     | <span class='neutral'>                ,</span>
  668 |     | <span class='neutral'>                altLiquidity,</span>
  669 |     | <span class='neutral'>                ,</span>
  670 |     | <span class='neutral'>                ,</span>
  671 |     | <span class='neutral'>                altOwed0,</span>
  672 |     | <span class='neutral'>                altOwed1</span>
  673 |     | <span class='unexecuted'>            ) = INftPositionManager(nftManager).positions(positionAlt.nftId);</span>
  674 |     | <span class='neutral'></span>
  675 |     | <span class='unexecuted'>        (mainAmount0, mainAmount1) = LiquidityAmounts.getAmountsForLiquidity(</span>
  676 |     | <span class='unexecuted'>            sqrtPriceX96,</span>
  677 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(positionMain.tickLower),</span>
  678 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(positionMain.tickUpper),</span>
  679 |     | <span class='unexecuted'>            liquidity</span>
  680 |     | <span class='neutral'>        );</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='unexecuted'>        (altAmount0, altAmount1) = LiquidityAmounts.getAmountsForLiquidity(</span>
  683 |     | <span class='unexecuted'>            sqrtPriceX96,</span>
  684 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(positionAlt.tickLower),</span>
  685 |     | <span class='unexecuted'>            TickMath.getSqrtRatioAtTick(positionAlt.tickUpper),</span>
  686 |     | <span class='unexecuted'>            altLiquidity</span>
  687 |     | <span class='neutral'>        );</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='unexecuted'>        mainAmount0 += owed0;</span>
  690 |     | <span class='unexecuted'>        mainAmount1 += owed1;</span>
  691 |     | <span class='neutral'></span>
  692 |     | <span class='unexecuted'>        altAmount0 += altOwed0;</span>
  693 |     | <span class='unexecuted'>        altAmount1 += altOwed1;</span>
  694 |     | <span class='neutral'></span>
  695 |     | <span class='unexecuted'>        token0Bal = mainAmount0 + altAmount0;</span>
  696 |     | <span class='unexecuted'>        token1Bal = mainAmount1 + altAmount1;</span>
  697 |     | <span class='neutral'>    }</span>
  698 |     | <span class='neutral'></span>
  699 |     | <span class='neutral'>    /**</span>
  700 |     | <span class='neutral'>     * @notice Returns the range of the pool, will always be the main position.</span>
  701 |     | <span class='neutral'>     * @return lowerPrice The lower price of the position.</span>
  702 |     | <span class='neutral'>     * @return upperPrice The upper price of the position.</span>
  703 |     | <span class='neutral'>     */</span>
  704 |     | <span class='unexecuted'>    function range()</span>
  705 |     | <span class='neutral'>        external</span>
  706 |     | <span class='neutral'>        view</span>
  707 |     | <span class='unexecuted'>        returns (uint256 lowerPrice, uint256 upperPrice)</span>
  708 |     | <span class='neutral'>    {</span>
  709 |     | <span class='neutral'>        // the main position is always covering the alt range</span>
  710 |     | <span class='unexecuted'>        lowerPrice =</span>
  711 |     | <span class='unexecuted'>            FullMath.mulDiv(</span>
  712 |     | <span class='unexecuted'>                uint256(TickMath.getSqrtRatioAtTick(positionMain.tickLower)),</span>
  713 |     | <span class='neutral'>                SQRT_PRECISION,</span>
  714 |     | <span class='neutral'>                (2 ** 96)</span>
  715 |     | <span class='neutral'>            ) **</span>
  716 |     | <span class='unexecuted'>                2;</span>
  717 |     | <span class='unexecuted'>        upperPrice =</span>
  718 |     | <span class='unexecuted'>            FullMath.mulDiv(</span>
  719 |     | <span class='unexecuted'>                uint256(TickMath.getSqrtRatioAtTick(positionMain.tickUpper)),</span>
  720 |     | <span class='neutral'>                SQRT_PRECISION,</span>
  721 |     | <span class='neutral'>                (2 ** 96)</span>
  722 |     | <span class='neutral'>            ) **</span>
  723 |     | <span class='unexecuted'>                2;</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>    /**</span>
  727 |     | <span class='neutral'>     * @notice The current tick of the pool.</span>
  728 |     | <span class='neutral'>     * @return tick The current tick of the pool.</span>
  729 |     | <span class='neutral'>     */</span>
  730 |     | <span class='unexecuted'>    function currentTick() public view returns (int24 tick) {</span>
  731 |     | <span class='neutral'>        //audit Is the current tick can be manipulable like the spot price ?</span>
  732 |     | <span class='unexecuted'>        (, tick, , , , ) = IVeloPool(pool).slot0();</span>
  733 |     | <span class='neutral'>    }</span>
  734 |     | <span class='neutral'></span>
  735 |     | <span class='neutral'>    /**</span>
  736 |     | <span class='neutral'>     * @notice The current price of the pool.</span>
  737 |     | <span class='neutral'>     * @return _price The current price of the pool.</span>
  738 |     | <span class='neutral'>     */</span>
  739 |     | <span class='unexecuted'>    function price() public view returns (uint256 _price) {</span>
  740 |     | <span class='unexecuted'>        uint160 sqrtPriceX96 = sqrtPrice();</span>
  741 |     | <span class='neutral'>        _price =</span>
  742 |     | <span class='unexecuted'>            FullMath.mulDiv(uint256(sqrtPriceX96), SQRT_PRECISION, (2 ** 96)) **</span>
  743 |     | <span class='unexecuted'>                2;</span>
  744 |     | <span class='neutral'>    }</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    /**</span>
  747 |     | <span class='neutral'>     * @notice The sqrt price of the pool.</span>
  748 |     | <span class='neutral'>     * @return sqrtPriceX96 The sqrt price of the pool.</span>
  749 |     | <span class='neutral'>     */</span>
  750 |     | <span class='neutral'></span>
  751 |     | <span class='neutral'>    //audit Watchout, Can be easily manipulated</span>
  752 |     | <span class='unexecuted'>    function sqrtPrice() public view returns (uint160 sqrtPriceX96) {</span>
  753 |     | <span class='unexecuted'>        (sqrtPriceX96, , , , , ) = IVeloPool(pool).slot0();</span>
  754 |     | <span class='neutral'>    }</span>
  755 |     | <span class='neutral'></span>
  756 |     | <span class='neutral'>    /**</span>
  757 |     | <span class='neutral'>     * @notice The tick distance of the pool.</span>
  758 |     | <span class='neutral'>     * @return int24 The tick distance/spacing of the pool.</span>
  759 |     | <span class='neutral'>     */</span>
  760 |     | <span class='unexecuted'>    function _tickDistance() private view returns (int24) {</span>
  761 |     | <span class='unexecuted'>        return IVeloPool(pool).tickSpacing();</span>
  762 |     | <span class='neutral'>    }</span>
  763 |     | <span class='neutral'></span>
  764 |     | <span class='neutral'>    /// @notice Sets the tick positions for the main and alternative positions.</span>
  765 |     | <span class='unexecuted'>    function _setTicks() private onlyCalmPeriods {</span>
  766 |     | <span class='unexecuted'>        int24 tick = currentTick();</span>
  767 |     | <span class='unexecuted'>        int24 distance = _tickDistance();</span>
  768 |     | <span class='unexecuted'>        int24 width = positionWidth * distance;</span>
  769 |     | <span class='neutral'></span>
  770 |     | <span class='unexecuted'>        _setMainTick(tick, distance, width);</span>
  771 |     | <span class='unexecuted'>        _setAltTick(tick, distance, width);</span>
  772 |     | <span class='neutral'>    }</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    /// @notice Sets the main tick position.</span>
  775 |     | <span class='unexecuted'>    function _setMainTick(int24 tick, int24 distance, int24 width) private {</span>
  776 |     | <span class='unexecuted'>        (positionMain.tickLower, positionMain.tickUpper) = TickUtils.baseTicks(</span>
  777 |     | <span class='unexecuted'>            tick,</span>
  778 |     | <span class='unexecuted'>            width,</span>
  779 |     | <span class='unexecuted'>            distance</span>
  780 |     | <span class='neutral'>        );</span>
  781 |     | <span class='neutral'>    }</span>
  782 |     | <span class='neutral'></span>
  783 |     | <span class='neutral'>    /// @notice Sets the alternative tick position.</span>
  784 |     | <span class='unexecuted'>    function _setAltTick(int24 tick, int24 distance, int24 width) private {</span>
  785 |     | <span class='unexecuted'>        (uint256 bal0, uint256 bal1) = balancesOfThis();</span>
  786 |     | <span class='neutral'></span>
  787 |     | <span class='neutral'>        // We calculate how much token0 we have in the price of token1.</span>
  788 |     | <span class='unexecuted'>        uint256 amount0;</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='unexecuted'>        if (bal0 &gt; 0) {</span>
  791 |     | <span class='neutral'>            //audit price() is spot price and it&#39;s manipulable</span>
  792 |     | <span class='unexecuted'>            amount0 = (bal0 * price()) / PRECISION;</span>
  793 |     | <span class='neutral'>        }</span>
  794 |     | <span class='neutral'></span>
  795 |     | <span class='neutral'>        // We set the alternative position based on the token that has the most value available.</span>
  796 |     | <span class='unexecuted'>        if (amount0 &lt; bal1) {</span>
  797 |     | <span class='unexecuted'>            (positionAlt.tickLower, ) = TickUtils.baseTicks(</span>
  798 |     | <span class='unexecuted'>                tick,</span>
  799 |     | <span class='unexecuted'>                width,</span>
  800 |     | <span class='unexecuted'>                distance</span>
  801 |     | <span class='neutral'>            );</span>
  802 |     | <span class='neutral'></span>
  803 |     | <span class='unexecuted'>            (positionAlt.tickUpper, ) = TickUtils.baseTicks(</span>
  804 |     | <span class='unexecuted'>                tick,</span>
  805 |     | <span class='unexecuted'>                distance,</span>
  806 |     | <span class='neutral'>                distance</span>
  807 |     | <span class='neutral'>            );</span>
  808 |     | <span class='unexecuted'>        } else if (bal1 &lt; amount0) {</span>
  809 |     | <span class='unexecuted'>            (, positionAlt.tickLower) = TickUtils.baseTicks(</span>
  810 |     | <span class='unexecuted'>                tick,</span>
  811 |     | <span class='unexecuted'>                distance,</span>
  812 |     | <span class='unexecuted'>                distance</span>
  813 |     | <span class='neutral'>            );</span>
  814 |     | <span class='neutral'></span>
  815 |     | <span class='unexecuted'>            (, positionAlt.tickUpper) = TickUtils.baseTicks(</span>
  816 |     | <span class='unexecuted'>                tick,</span>
  817 |     | <span class='unexecuted'>                width,</span>
  818 |     | <span class='unexecuted'>                distance</span>
  819 |     | <span class='neutral'>            );</span>
  820 |     | <span class='neutral'>        }</span>
  821 |     | <span class='neutral'>    }</span>
  822 |     | <span class='neutral'></span>
  823 |     | <span class='neutral'>    /**</span>
  824 |     | <span class='neutral'>     * @notice Sets the path to swap the output token to the native token for fee harvesting.</span>
  825 |     | <span class='neutral'>     * @param _path The path to swap the output token to the native token.</span>
  826 |     | <span class='neutral'>     */</span>
  827 |     | <span class='unexecuted'>    function setOutputToNativePath(bytes calldata _path) public onlyOwner {</span>
  828 |     | <span class='unexecuted'>        if (_path.length &gt; 0) {</span>
  829 |     | <span class='unexecuted'>            address[] memory _route = VeloSwapUtils.pathToRoute(_path);</span>
  830 |     | <span class='unexecuted'>            if (_route[0] != output) revert InvalidInput();</span>
  831 |     | <span class='unexecuted'>            if (_route[_route.length - 1] != native) revert InvalidOutput();</span>
  832 |     | <span class='unexecuted'>            outputToNativePath = _path;</span>
  833 |     | <span class='unexecuted'>            emit SetOutputToNativePath(_path);</span>
  834 |     | <span class='neutral'>        }</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    /**</span>
  838 |     | <span class='neutral'>     * @notice Sets the deviation from the twap we will allow on adding liquidity.</span>
  839 |     | <span class='neutral'>     * @param _maxDeviation The max deviation from twap we will allow.</span>
  840 |     | <span class='neutral'>     */</span>
  841 |     | <span class='unexecuted'>    function setDeviation(int56 _maxDeviation) external onlyOwner {</span>
  842 |     | <span class='unexecuted'>        emit SetDeviation(_maxDeviation);</span>
  843 |     | <span class='neutral'></span>
  844 |     | <span class='neutral'>        // Require the deviation to be less than or equal to 4 times the tick spacing.</span>
  845 |     | <span class='unexecuted'>        if (_maxDeviation &gt;= _tickDistance() * 4) revert InvalidInput();</span>
  846 |     | <span class='neutral'></span>
  847 |     | <span class='unexecuted'>        maxTickDeviation = _maxDeviation;</span>
  848 |     | <span class='neutral'>    }</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    /**</span>
  851 |     | <span class='neutral'>     * @notice Returns the route to swap the output token to the native token for fee harvesting.</span>
  852 |     | <span class='neutral'>     * @return address[] The route to swap the output to the native token.</span>
  853 |     | <span class='neutral'>     */</span>
  854 |     | <span class='unexecuted'>    function outputToNative() public view returns (address[] memory) {</span>
  855 |     | <span class='unexecuted'>        if (outputToNativePath.length == 0) return new address[](0);</span>
  856 |     | <span class='unexecuted'>        return VeloSwapUtils.pathToRoute(outputToNativePath);</span>
  857 |     | <span class='neutral'>    }</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='neutral'>    /// @notice Returns the price of the first token in native token.</span>
  860 |     | <span class='unexecuted'>    function lpToken0ToNativePrice() public returns (uint256) {</span>
  861 |     | <span class='unexecuted'>        uint amount = 10 ** IERC20Metadata(lpToken0).decimals() / 10;</span>
  862 |     | <span class='unexecuted'>        if (lpToken0 == native) return amount;</span>
  863 |     | <span class='unexecuted'>        return IQuoter(quoter).quoteExactInput(lpToken0ToNativePath, amount);</span>
  864 |     | <span class='neutral'>    }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>    /// @notice Returns the price of the second token in native token.</span>
  867 |     | <span class='unexecuted'>    function lpToken1ToNativePrice() public returns (uint256) {</span>
  868 |     | <span class='unexecuted'>        uint amount = 10 ** IERC20Metadata(lpToken1).decimals() / 10;</span>
  869 |     | <span class='unexecuted'>        if (lpToken1 == native) return amount;</span>
  870 |     | <span class='unexecuted'>        return IQuoter(quoter).quoteExactInput(lpToken1ToNativePath, amount);</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    /**</span>
  874 |     | <span class='neutral'>     * @notice The twap of the last minute from the pool.</span>
  875 |     | <span class='neutral'>     * @return twapTick The twap of the last minute from the pool.</span>
  876 |     | <span class='neutral'>     */</span>
  877 |     | <span class='unexecuted'>    function twap() public view returns (int56 twapTick) {</span>
  878 |     | <span class='unexecuted'>        uint32[] memory secondsAgo = new uint32[](2);</span>
  879 |     | <span class='unexecuted'>        secondsAgo[0] = uint32(twapInterval); //audit-info Why cast it to uint32 when it&#39;s already the default type?</span>
  880 |     | <span class='unexecuted'>        secondsAgo[1] = 0;</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='unexecuted'>        (int56[] memory tickCuml, ) = IVeloPool(pool).observe(secondsAgo); //audit-info check on what observe() is doing</span>
  883 |     | <span class='unexecuted'>        twapTick = (tickCuml[1] - tickCuml[0]) / int32(twapInterval); //audit-ok Pretty safe to downcast to int32 as the max value is 2B.</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='unexecuted'>    function setTwapInterval(uint32 _interval) external onlyOwner {</span>
  887 |     | <span class='unexecuted'>        emit SetTwapInterval(twapInterval, _interval);</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>        // Require the interval to be greater than 60 seconds.</span>
  890 |     | <span class='unexecuted'>        if (_interval &lt; 60) revert InvalidInput();</span>
  891 |     | <span class='neutral'></span>
  892 |     | <span class='unexecuted'>        twapInterval = _interval;</span>
  893 |     | <span class='neutral'>    }</span>
  894 |     | <span class='neutral'></span>
  895 |     | <span class='neutral'>    /**</span>
  896 |     | <span class='neutral'>     * @notice Sets our position width and readjusts our positions.</span>
  897 |     | <span class='neutral'>     * @param _width The new width multiplier of the position.</span>
  898 |     | <span class='neutral'>     */</span>
  899 |     | <span class='unexecuted'>    function setPositionWidth(int24 _width) external onlyOwner {</span>
  900 |     | <span class='unexecuted'>        emit SetPositionWidth(positionWidth, _width);</span>
  901 |     | <span class='unexecuted'>        _claimEarnings();</span>
  902 |     | <span class='unexecuted'>        _removeLiquidity();</span>
  903 |     | <span class='unexecuted'>        positionWidth = _width;</span>
  904 |     | <span class='unexecuted'>        _setTicks();</span>
  905 |     | <span class='unexecuted'>        _addLiquidity();</span>
  906 |     | <span class='neutral'>    }</span>
  907 |     | <span class='neutral'></span>
  908 |     | <span class='neutral'>    /**</span>
  909 |     | <span class='neutral'>     * @notice Sets the reward pool address.</span>
  910 |     | <span class='neutral'>     * @param _rewardPool The new reward pool address.</span>
  911 |     | <span class='neutral'>     */</span>
  912 |     | <span class='unexecuted'>    function setRewardPool(address _rewardPool) external onlyOwner {</span>
  913 |     | <span class='unexecuted'>        rewardPool = _rewardPool;</span>
  914 |     | <span class='unexecuted'>        emit SetRewardPool(_rewardPool);</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    /**</span>
  918 |     | <span class='neutral'>     * @notice set the unirouter address</span>
  919 |     | <span class='neutral'>     * @param _unirouter The new unirouter address</span>
  920 |     | <span class='neutral'>     */</span>
  921 |     | <span class='unexecuted'>    function setUnirouter(address _unirouter) external override onlyOwner {</span>
  922 |     | <span class='unexecuted'>        _removeAllowances();</span>
  923 |     | <span class='unexecuted'>        unirouter = _unirouter;</span>
  924 |     | <span class='unexecuted'>        _giveAllowances();</span>
  925 |     | <span class='unexecuted'>        emit SetUnirouter(_unirouter);</span>
  926 |     | <span class='neutral'>    }</span>
  927 |     | <span class='neutral'></span>
  928 |     | <span class='neutral'>    /// @notice Retire the strategy and return all the dust to the fee recipient.</span>
  929 |     | <span class='unexecuted'>    function retireVault() external onlyOwner {</span>
  930 |     | <span class='unexecuted'>        if (IBeefyVaultConcLiq(vault).totalSupply() != 10 ** 3)</span>
  931 |     | <span class='unexecuted'>            revert NotAuthorized();</span>
  932 |     | <span class='unexecuted'>        panic(0, 0);</span>
  933 |     | <span class='unexecuted'>        address feeRecipient = beefyFeeRecipient();</span>
  934 |     | <span class='unexecuted'>        IERC20Metadata(lpToken0).safeTransfer(</span>
  935 |     | <span class='neutral'>            feeRecipient,</span>
  936 |     | <span class='unexecuted'>            IERC20Metadata(lpToken0).balanceOf(address(this))</span>
  937 |     | <span class='neutral'>        );</span>
  938 |     | <span class='unexecuted'>        IERC20Metadata(lpToken1).safeTransfer(</span>
  939 |     | <span class='unexecuted'>            feeRecipient,</span>
  940 |     | <span class='unexecuted'>            IERC20Metadata(lpToken1).balanceOf(address(this))</span>
  941 |     | <span class='neutral'>        );</span>
  942 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    /**</span>
  946 |     | <span class='neutral'>     * @notice Remove Liquidity and Allowances, then pause deposits.</span>
  947 |     | <span class='neutral'>     * @param _minAmount0 The minimum amount of token0 in the strategy after panic.</span>
  948 |     | <span class='neutral'>     * @param _minAmount1 The minimum amount of token1 in the strategy after panic.</span>
  949 |     | <span class='neutral'>     */</span>
  950 |     | <span class='unexecuted'>    function panic(</span>
  951 |     | <span class='neutral'>        uint256 _minAmount0,</span>
  952 |     | <span class='neutral'>        uint256 _minAmount1</span>
  953 |     | <span class='unexecuted'>    ) public onlyManager {</span>
  954 |     | <span class='unexecuted'>        _claimEarnings();</span>
  955 |     | <span class='unexecuted'>        _removeLiquidity();</span>
  956 |     | <span class='unexecuted'>        _removeAllowances();</span>
  957 |     | <span class='unexecuted'>        _pause();</span>
  958 |     | <span class='neutral'></span>
  959 |     | <span class='unexecuted'>        (uint256 bal0, uint256 bal1) = balances();</span>
  960 |     | <span class='unexecuted'>        if (bal0 &lt; _minAmount0 || bal1 &lt; _minAmount1) revert TooMuchSlippage();</span>
  961 |     | <span class='neutral'>    }</span>
  962 |     | <span class='neutral'></span>
  963 |     | <span class='neutral'>    /// @notice Unpause deposits, give allowances and add liquidity.</span>
  964 |     | <span class='neutral'>    //audit What&#39;s the matter of Pause/Unpaused when there are no function using the whenNotPaused() modifier ?</span>
  965 |     | <span class='unexecuted'>    function unpause() external onlyManager {</span>
  966 |     | <span class='neutral'>        //audit-info how can the owner be the 0 address ?</span>
  967 |     | <span class='unexecuted'>        if (owner() == address(0)) revert NotAuthorized();</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>        //audit-info Why so many actions only on unpaused ?</span>
  970 |     | <span class='unexecuted'>        _giveAllowances();</span>
  971 |     | <span class='unexecuted'>        _unpause();</span>
  972 |     | <span class='unexecuted'>        _setTicks();</span>
  973 |     | <span class='unexecuted'>        _addLiquidity();</span>
  974 |     | <span class='neutral'>    }</span>
  975 |     | <span class='neutral'></span>
  976 |     | <span class='neutral'>    /// @notice gives swap permisions for the tokens to the unirouter.</span>
  977 |     | <span class='unexecuted'>    function _giveAllowances() private {</span>
  978 |     | <span class='unexecuted'>        IERC20Metadata(output).forceApprove(unirouter, type(uint256).max);</span>
  979 |     | <span class='unexecuted'>        IERC20Metadata(output).forceApprove(rewardPool, type(uint256).max);</span>
  980 |     | <span class='unexecuted'>        IERC20Metadata(lpToken0).forceApprove(nftManager, type(uint256).max);</span>
  981 |     | <span class='unexecuted'>        IERC20Metadata(lpToken1).forceApprove(nftManager, type(uint256).max);</span>
  982 |     | <span class='neutral'>    }</span>
  983 |     | <span class='neutral'></span>
  984 |     | <span class='neutral'>    /// @notice removes swap permisions for the tokens from the unirouter.</span>
  985 |     | <span class='unexecuted'>    function _removeAllowances() private {</span>
  986 |     | <span class='unexecuted'>        IERC20Metadata(output).forceApprove(unirouter, 0);</span>
  987 |     | <span class='unexecuted'>        IERC20Metadata(output).forceApprove(rewardPool, 0);</span>
  988 |     | <span class='unexecuted'>        IERC20Metadata(lpToken0).forceApprove(nftManager, 0);</span>
  989 |     | <span class='unexecuted'>        IERC20Metadata(lpToken1).forceApprove(nftManager, 0);</span>
  990 |     | <span class='neutral'>    }</span>
  991 |     | <span class='neutral'></span>
  992 |     | <span class='unexecuted'>    function onERC721Received(</span>
  993 |     | <span class='neutral'>        address,</span>
  994 |     | <span class='neutral'>        address,</span>
  995 |     | <span class='neutral'>        uint256,</span>
  996 |     | <span class='neutral'>        bytes calldata</span>
  997 |     | <span class='neutral'>    ) external pure returns (bytes4) {</span>
  998 |     | <span class='neutral'>        return this.onERC721Received.selector;</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'>}</span>
 1001 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/BytesLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>/*</span>
   3 |     | <span class='neutral'> * @title Solidity Bytes Arrays Utils</span>
   4 |     | <span class='neutral'> * @author Gonalo S &lt;goncalo.sa@consensys.net&gt;</span>
   5 |     | <span class='neutral'> *</span>
   6 |     | <span class='neutral'> * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.</span>
   7 |     | <span class='neutral'> *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>pragma solidity &gt;=0.8.0 &lt;0.9.0;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>library BytesLib {</span>
  13 |     | <span class='neutral'>    function concat(</span>
  14 |     | <span class='neutral'>        bytes memory _preBytes,</span>
  15 |     | <span class='neutral'>        bytes memory _postBytes</span>
  16 |     | <span class='neutral'>    )</span>
  17 |     | <span class='neutral'>    internal</span>
  18 |     | <span class='neutral'>    pure</span>
  19 |     | <span class='neutral'>    returns (bytes memory)</span>
  20 |     | <span class='neutral'>    {</span>
  21 |     | <span class='neutral'>        bytes memory tempBytes;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>        assembly {</span>
  24 |     | <span class='neutral'>        // Get a location of some free memory and store it in tempBytes as</span>
  25 |     | <span class='neutral'>        // Solidity does for memory variables.</span>
  26 |     | <span class='neutral'>            tempBytes := mload(0x40)</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        // Store the length of the first bytes array at the beginning of</span>
  29 |     | <span class='neutral'>        // the memory for tempBytes.</span>
  30 |     | <span class='neutral'>            let length := mload(_preBytes)</span>
  31 |     | <span class='neutral'>            mstore(tempBytes, length)</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>        // Maintain a memory counter for the current write location in the</span>
  34 |     | <span class='neutral'>        // temp bytes array by adding the 32 bytes for the array length to</span>
  35 |     | <span class='neutral'>        // the starting location.</span>
  36 |     | <span class='neutral'>            let mc := add(tempBytes, 0x20)</span>
  37 |     | <span class='neutral'>        // Stop copying when the memory counter reaches the length of the</span>
  38 |     | <span class='neutral'>        // first bytes array.</span>
  39 |     | <span class='neutral'>            let end := add(mc, length)</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>            for {</span>
  42 |     | <span class='neutral'>            // Initialize a copy counter to the start of the _preBytes data,</span>
  43 |     | <span class='neutral'>            // 32 bytes into its memory.</span>
  44 |     | <span class='neutral'>                let cc := add(_preBytes, 0x20)</span>
  45 |     | <span class='neutral'>            } lt(mc, end) {</span>
  46 |     | <span class='neutral'>            // Increase both counters by 32 bytes each iteration.</span>
  47 |     | <span class='neutral'>                mc := add(mc, 0x20)</span>
  48 |     | <span class='neutral'>                cc := add(cc, 0x20)</span>
  49 |     | <span class='neutral'>            } {</span>
  50 |     | <span class='neutral'>            // Write the _preBytes data into the tempBytes memory 32 bytes</span>
  51 |     | <span class='neutral'>            // at a time.</span>
  52 |     | <span class='neutral'>                mstore(mc, mload(cc))</span>
  53 |     | <span class='neutral'>            }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // Add the length of _postBytes to the current length of tempBytes</span>
  56 |     | <span class='neutral'>        // and store it as the new length in the first 32 bytes of the</span>
  57 |     | <span class='neutral'>        // tempBytes memory.</span>
  58 |     | <span class='neutral'>            length := mload(_postBytes)</span>
  59 |     | <span class='neutral'>            mstore(tempBytes, add(length, mload(tempBytes)))</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // Move the memory counter back from a multiple of 0x20 to the</span>
  62 |     | <span class='neutral'>        // actual end of the _preBytes data.</span>
  63 |     | <span class='neutral'>            mc := end</span>
  64 |     | <span class='neutral'>        // Stop copying when the memory counter reaches the new combined</span>
  65 |     | <span class='neutral'>        // length of the arrays.</span>
  66 |     | <span class='neutral'>            end := add(mc, length)</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>            for {</span>
  69 |     | <span class='neutral'>                let cc := add(_postBytes, 0x20)</span>
  70 |     | <span class='neutral'>            } lt(mc, end) {</span>
  71 |     | <span class='neutral'>                mc := add(mc, 0x20)</span>
  72 |     | <span class='neutral'>                cc := add(cc, 0x20)</span>
  73 |     | <span class='neutral'>            } {</span>
  74 |     | <span class='neutral'>                mstore(mc, mload(cc))</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // Update the free-memory pointer by padding our last write location</span>
  78 |     | <span class='neutral'>        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the</span>
  79 |     | <span class='neutral'>        // next 32 byte block, then round down to the nearest multiple of</span>
  80 |     | <span class='neutral'>        // 32. If the sum of the length of the two arrays is zero then add</span>
  81 |     | <span class='neutral'>        // one before rounding down to leave a blank 32 bytes (the length block with 0).</span>
  82 |     | <span class='neutral'>            mstore(0x40, and(</span>
  83 |     | <span class='neutral'>            add(add(end, iszero(add(length, mload(_preBytes)))), 31),</span>
  84 |     | <span class='neutral'>            not(31) // Round down to the nearest 32 bytes.</span>
  85 |     | <span class='neutral'>            ))</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        return tempBytes;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {</span>
  92 |     | <span class='neutral'>        assembly {</span>
  93 |     | <span class='neutral'>        // Read the first 32 bytes of _preBytes storage, which is the length</span>
  94 |     | <span class='neutral'>        // of the array. (We don&#39;t need to use the offset into the slot</span>
  95 |     | <span class='neutral'>        // because arrays use the entire slot.)</span>
  96 |     | <span class='neutral'>            let fslot := sload(_preBytes.slot)</span>
  97 |     | <span class='neutral'>        // Arrays of 31 bytes or less have an even value in their slot,</span>
  98 |     | <span class='neutral'>        // while longer arrays have an odd value. The actual length is</span>
  99 |     | <span class='neutral'>        // the slot divided by two for odd values, and the lowest order</span>
 100 |     | <span class='neutral'>        // byte divided by two for even values.</span>
 101 |     | <span class='neutral'>        // If the slot is even, bitwise and the slot with 255 and divide by</span>
 102 |     | <span class='neutral'>        // two to get the length. If the slot is odd, bitwise and the slot</span>
 103 |     | <span class='neutral'>        // with -1 and divide by two.</span>
 104 |     | <span class='neutral'>            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)</span>
 105 |     | <span class='neutral'>            let mlength := mload(_postBytes)</span>
 106 |     | <span class='neutral'>            let newlength := add(slength, mlength)</span>
 107 |     | <span class='neutral'>        // slength can contain both the length and contents of the array</span>
 108 |     | <span class='neutral'>        // if length &lt; 32 bytes so let&#39;s prepare for that</span>
 109 |     | <span class='neutral'>        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</span>
 110 |     | <span class='neutral'>            switch add(lt(slength, 32), lt(newlength, 32))</span>
 111 |     | <span class='neutral'>            case 2 {</span>
 112 |     | <span class='neutral'>            // Since the new array still fits in the slot, we just need to</span>
 113 |     | <span class='neutral'>            // update the contents of the slot.</span>
 114 |     | <span class='neutral'>            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length</span>
 115 |     | <span class='neutral'>                sstore(</span>
 116 |     | <span class='neutral'>                _preBytes.slot,</span>
 117 |     | <span class='neutral'>                // all the modifications to the slot are inside this</span>
 118 |     | <span class='neutral'>                // next block</span>
 119 |     | <span class='neutral'>                add(</span>
 120 |     | <span class='neutral'>                // we can just add to the slot contents because the</span>
 121 |     | <span class='neutral'>                // bytes we want to change are the LSBs</span>
 122 |     | <span class='neutral'>                fslot,</span>
 123 |     | <span class='neutral'>                add(</span>
 124 |     | <span class='neutral'>                mul(</span>
 125 |     | <span class='neutral'>                div(</span>
 126 |     | <span class='neutral'>                // load the bytes from memory</span>
 127 |     | <span class='neutral'>                mload(add(_postBytes, 0x20)),</span>
 128 |     | <span class='neutral'>                // zero all bytes to the right</span>
 129 |     | <span class='neutral'>                exp(0x100, sub(32, mlength))</span>
 130 |     | <span class='neutral'>                ),</span>
 131 |     | <span class='neutral'>                // and now shift left the number of bytes to</span>
 132 |     | <span class='neutral'>                // leave space for the length in the slot</span>
 133 |     | <span class='neutral'>                exp(0x100, sub(32, newlength))</span>
 134 |     | <span class='neutral'>                ),</span>
 135 |     | <span class='neutral'>                // increase length by the double of the memory</span>
 136 |     | <span class='neutral'>                // bytes length</span>
 137 |     | <span class='neutral'>                mul(mlength, 2)</span>
 138 |     | <span class='neutral'>                )</span>
 139 |     | <span class='neutral'>                )</span>
 140 |     | <span class='neutral'>                )</span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='neutral'>            case 1 {</span>
 143 |     | <span class='neutral'>            // The stored value fits in the slot, but the combined value</span>
 144 |     | <span class='neutral'>            // will exceed it.</span>
 145 |     | <span class='neutral'>            // get the keccak hash to get the contents of the array</span>
 146 |     | <span class='neutral'>                mstore(0x0, _preBytes.slot)</span>
 147 |     | <span class='neutral'>                let sc := add(keccak256(0x0, 0x20), div(slength, 32))</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>            // save new length</span>
 150 |     | <span class='neutral'>                sstore(_preBytes.slot, add(mul(newlength, 2), 1))</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>            // The contents of the _postBytes array start 32 bytes into</span>
 153 |     | <span class='neutral'>            // the structure. Our first read should obtain the `submod`</span>
 154 |     | <span class='neutral'>            // bytes that can fit into the unused space in the last word</span>
 155 |     | <span class='neutral'>            // of the stored array. To get this, we read 32 bytes starting</span>
 156 |     | <span class='neutral'>            // from `submod`, so the data we read overlaps with the array</span>
 157 |     | <span class='neutral'>            // contents by `submod` bytes. Masking the lowest-order</span>
 158 |     | <span class='neutral'>            // `submod` bytes allows us to add that value directly to the</span>
 159 |     | <span class='neutral'>            // stored value.</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>                let submod := sub(32, slength)</span>
 162 |     | <span class='neutral'>                let mc := add(_postBytes, submod)</span>
 163 |     | <span class='neutral'>                let end := add(_postBytes, mlength)</span>
 164 |     | <span class='neutral'>                let mask := sub(exp(0x100, submod), 1)</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>                sstore(</span>
 167 |     | <span class='neutral'>                sc,</span>
 168 |     | <span class='neutral'>                add(</span>
 169 |     | <span class='neutral'>                and(</span>
 170 |     | <span class='neutral'>                fslot,</span>
 171 |     | <span class='neutral'>                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00</span>
 172 |     | <span class='neutral'>                ),</span>
 173 |     | <span class='neutral'>                and(mload(mc), mask)</span>
 174 |     | <span class='neutral'>                )</span>
 175 |     | <span class='neutral'>                )</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>                for {</span>
 178 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 179 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 180 |     | <span class='neutral'>                } lt(mc, end) {</span>
 181 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 182 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 183 |     | <span class='neutral'>                } {</span>
 184 |     | <span class='neutral'>                    sstore(sc, mload(mc))</span>
 185 |     | <span class='neutral'>                }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>                mask := exp(0x100, sub(mc, end))</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>                sstore(sc, mul(div(mload(mc), mask), mask))</span>
 190 |     | <span class='neutral'>            }</span>
 191 |     | <span class='neutral'>            default {</span>
 192 |     | <span class='neutral'>            // get the keccak hash to get the contents of the array</span>
 193 |     | <span class='neutral'>                mstore(0x0, _preBytes.slot)</span>
 194 |     | <span class='neutral'>            // Start copying to the last used word of the stored array.</span>
 195 |     | <span class='neutral'>                let sc := add(keccak256(0x0, 0x20), div(slength, 32))</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>            // save new length</span>
 198 |     | <span class='neutral'>                sstore(_preBytes.slot, add(mul(newlength, 2), 1))</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>            // Copy over the first `submod` bytes of the new data as in</span>
 201 |     | <span class='neutral'>            // case 1 above.</span>
 202 |     | <span class='neutral'>                let slengthmod := mod(slength, 32)</span>
 203 |     | <span class='neutral'>                let mlengthmod := mod(mlength, 32)</span>
 204 |     | <span class='neutral'>                let submod := sub(32, slengthmod)</span>
 205 |     | <span class='neutral'>                let mc := add(_postBytes, submod)</span>
 206 |     | <span class='neutral'>                let end := add(_postBytes, mlength)</span>
 207 |     | <span class='neutral'>                let mask := sub(exp(0x100, submod), 1)</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>                sstore(sc, add(sload(sc), and(mload(mc), mask)))</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>                for {</span>
 212 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 213 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 214 |     | <span class='neutral'>                } lt(mc, end) {</span>
 215 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 216 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 217 |     | <span class='neutral'>                } {</span>
 218 |     | <span class='neutral'>                    sstore(sc, mload(mc))</span>
 219 |     | <span class='neutral'>                }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>                mask := exp(0x100, sub(mc, end))</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>                sstore(sc, mul(div(mload(mc), mask), mask))</span>
 224 |     | <span class='neutral'>            }</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>    function slice(</span>
 229 |     | <span class='neutral'>        bytes memory _bytes,</span>
 230 |     | <span class='neutral'>        uint256 _start,</span>
 231 |     | <span class='neutral'>        uint256 _length</span>
 232 |     | <span class='neutral'>    )</span>
 233 |     | <span class='neutral'>    internal</span>
 234 |     | <span class='neutral'>    pure</span>
 235 |     | <span class='unexecuted'>    returns (bytes memory)</span>
 236 |     | <span class='neutral'>    {</span>
 237 |     | <span class='unexecuted'>        require(_length + 31 &gt;= _length, &quot;slice_overflow&quot;);</span>
 238 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + _length, &quot;slice_outOfBounds&quot;);</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>        bytes memory tempBytes;</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>        assembly {</span>
 243 |     | <span class='unexecuted'>            switch iszero(_length)</span>
 244 |     | <span class='unexecuted'>            case 0 {</span>
 245 |     | <span class='neutral'>            // Get a location of some free memory and store it in tempBytes as</span>
 246 |     | <span class='neutral'>            // Solidity does for memory variables.</span>
 247 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>            // The first word of the slice result is potentially a partial</span>
 250 |     | <span class='neutral'>            // word read from the original array. To read it, we calculate</span>
 251 |     | <span class='neutral'>            // the length of that partial word and start copying that many</span>
 252 |     | <span class='neutral'>            // bytes into the array. The first word we copy will start with</span>
 253 |     | <span class='neutral'>            // data we don&#39;t care about, but the last `lengthmod` bytes will</span>
 254 |     | <span class='neutral'>            // land at the beginning of the contents of the new array. When</span>
 255 |     | <span class='neutral'>            // we&#39;re done copying, we overwrite the full first word with</span>
 256 |     | <span class='neutral'>            // the actual length of the slice.</span>
 257 |     | <span class='unexecuted'>                let lengthmod := and(_length, 31)</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>            // The multiplication in the next line is necessary</span>
 260 |     | <span class='neutral'>            // because when slicing multiples of 32 bytes (lengthmod == 0)</span>
 261 |     | <span class='neutral'>            // the following copy loop was copying the origin&#39;s length</span>
 262 |     | <span class='neutral'>            // and then ending prematurely not copying everything it should.</span>
 263 |     | <span class='unexecuted'>                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))</span>
 264 |     | <span class='unexecuted'>                let end := add(mc, _length)</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>                for {</span>
 267 |     | <span class='neutral'>                // The multiplication in the next line has the same exact purpose</span>
 268 |     | <span class='neutral'>                // as the one above.</span>
 269 |     | <span class='unexecuted'>                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)</span>
 270 |     | <span class='unexecuted'>                } lt(mc, end) {</span>
 271 |     | <span class='unexecuted'>                    mc := add(mc, 0x20)</span>
 272 |     | <span class='unexecuted'>                    cc := add(cc, 0x20)</span>
 273 |     | <span class='neutral'>                } {</span>
 274 |     | <span class='unexecuted'>                    mstore(mc, mload(cc))</span>
 275 |     | <span class='neutral'>                }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>                mstore(tempBytes, _length)</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>            //update free-memory pointer</span>
 280 |     | <span class='neutral'>            //allocating the array padded to 32 bytes like the compiler does now</span>
 281 |     | <span class='unexecuted'>                mstore(0x40, and(add(mc, 31), not(31)))</span>
 282 |     | <span class='neutral'>            }</span>
 283 |     | <span class='neutral'>            //if we want a zero-length slice let&#39;s just return a zero-length array</span>
 284 |     | <span class='neutral'>            default {</span>
 285 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
 286 |     | <span class='neutral'>            //zero out the 32 bytes slice we are about to return</span>
 287 |     | <span class='neutral'>            //we need to do it because Solidity does not garbage collect</span>
 288 |     | <span class='unexecuted'>                mstore(tempBytes, 0)</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>                mstore(0x40, add(tempBytes, 0x20))</span>
 291 |     | <span class='neutral'>            }</span>
 292 |     | <span class='neutral'>        }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        return tempBytes;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {</span>
 298 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 20, &quot;toAddress_outOfBounds&quot;);</span>
 299 |     | <span class='neutral'>        address tempAddress;</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>        assembly {</span>
 302 |     | <span class='unexecuted'>            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)</span>
 303 |     | <span class='neutral'>        }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        return tempAddress;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {</span>
 309 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 1 , &quot;toUint8_outOfBounds&quot;);</span>
 310 |     | <span class='neutral'>        uint8 tempUint;</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>        assembly {</span>
 313 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x1), _start))</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>        return tempUint;</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {</span>
 320 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 2, &quot;toUint16_outOfBounds&quot;);</span>
 321 |     | <span class='neutral'>        uint16 tempUint;</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>        assembly {</span>
 324 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x2), _start))</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>        return tempUint;</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='unexecuted'>    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {</span>
 331 |     | <span class='unexecuted'>        require(_start + 3 &gt;= _start, &#39;toUint24_overflow&#39;);</span>
 332 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 3, &#39;toUint24_outOfBounds&#39;);</span>
 333 |     | <span class='neutral'>        uint24 tempUint;</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>        assembly {</span>
 336 |     | <span class='unexecuted'>            tempUint := mload(add(add(_bytes, 0x3), _start))</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>        return tempUint;</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {</span>
 343 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 4, &quot;toUint32_outOfBounds&quot;);</span>
 344 |     | <span class='neutral'>        uint32 tempUint;</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>        assembly {</span>
 347 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x4), _start))</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>        return tempUint;</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {</span>
 354 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 8, &quot;toUint64_outOfBounds&quot;);</span>
 355 |     | <span class='neutral'>        uint64 tempUint;</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>        assembly {</span>
 358 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x8), _start))</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>        return tempUint;</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {</span>
 365 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 12, &quot;toUint96_outOfBounds&quot;);</span>
 366 |     | <span class='neutral'>        uint96 tempUint;</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        assembly {</span>
 369 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0xc), _start))</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>        return tempUint;</span>
 373 |     | <span class='neutral'>    }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {</span>
 376 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 16, &quot;toUint128_outOfBounds&quot;);</span>
 377 |     | <span class='neutral'>        uint128 tempUint;</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='neutral'>        assembly {</span>
 380 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x10), _start))</span>
 381 |     | <span class='neutral'>        }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>        return tempUint;</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='neutral'>    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {</span>
 387 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 32, &quot;toUint256_outOfBounds&quot;);</span>
 388 |     | <span class='neutral'>        uint256 tempUint;</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>        assembly {</span>
 391 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x20), _start))</span>
 392 |     | <span class='neutral'>        }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='neutral'>        return tempUint;</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {</span>
 398 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 32, &quot;toBytes32_outOfBounds&quot;);</span>
 399 |     | <span class='neutral'>        bytes32 tempBytes32;</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>        assembly {</span>
 402 |     | <span class='neutral'>            tempBytes32 := mload(add(add(_bytes, 0x20), _start))</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='neutral'>        return tempBytes32;</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {</span>
 409 |     | <span class='neutral'>        bool success = true;</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='neutral'>        assembly {</span>
 412 |     | <span class='neutral'>            let length := mload(_preBytes)</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>        // if lengths don&#39;t match the arrays are not equal</span>
 415 |     | <span class='neutral'>            switch eq(length, mload(_postBytes))</span>
 416 |     | <span class='neutral'>            case 1 {</span>
 417 |     | <span class='neutral'>            // cb is a circuit breaker in the for loop since there&#39;s</span>
 418 |     | <span class='neutral'>            //  no said feature for inline assembly loops</span>
 419 |     | <span class='neutral'>            // cb = 1 - don&#39;t breaker</span>
 420 |     | <span class='neutral'>            // cb = 0 - break</span>
 421 |     | <span class='neutral'>                let cb := 1</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>                let mc := add(_preBytes, 0x20)</span>
 424 |     | <span class='neutral'>                let end := add(mc, length)</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>                for {</span>
 427 |     | <span class='neutral'>                    let cc := add(_postBytes, 0x20)</span>
 428 |     | <span class='neutral'>                // the next line is the loop condition:</span>
 429 |     | <span class='neutral'>                // while(uint256(mc &lt; end) + cb == 2)</span>
 430 |     | <span class='neutral'>                } eq(add(lt(mc, end), cb), 2) {</span>
 431 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 432 |     | <span class='neutral'>                    cc := add(cc, 0x20)</span>
 433 |     | <span class='neutral'>                } {</span>
 434 |     | <span class='neutral'>                // if any of these checks fails then arrays are not equal</span>
 435 |     | <span class='neutral'>                    if iszero(eq(mload(mc), mload(cc))) {</span>
 436 |     | <span class='neutral'>                    // unsuccess:</span>
 437 |     | <span class='neutral'>                        success := 0</span>
 438 |     | <span class='neutral'>                        cb := 0</span>
 439 |     | <span class='neutral'>                    }</span>
 440 |     | <span class='neutral'>                }</span>
 441 |     | <span class='neutral'>            }</span>
 442 |     | <span class='neutral'>            default {</span>
 443 |     | <span class='neutral'>            // unsuccess:</span>
 444 |     | <span class='neutral'>                success := 0</span>
 445 |     | <span class='neutral'>            }</span>
 446 |     | <span class='neutral'>        }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>        return success;</span>
 449 |     | <span class='neutral'>    }</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='neutral'>    function equalStorage(</span>
 452 |     | <span class='neutral'>        bytes storage _preBytes,</span>
 453 |     | <span class='neutral'>        bytes memory _postBytes</span>
 454 |     | <span class='neutral'>    )</span>
 455 |     | <span class='neutral'>    internal</span>
 456 |     | <span class='neutral'>    view</span>
 457 |     | <span class='neutral'>    returns (bool)</span>
 458 |     | <span class='neutral'>    {</span>
 459 |     | <span class='neutral'>        bool success = true;</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='neutral'>        assembly {</span>
 462 |     | <span class='neutral'>        // we know _preBytes_offset is 0</span>
 463 |     | <span class='neutral'>            let fslot := sload(_preBytes.slot)</span>
 464 |     | <span class='neutral'>        // Decode the length of the stored array like in concatStorage().</span>
 465 |     | <span class='neutral'>            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)</span>
 466 |     | <span class='neutral'>            let mlength := mload(_postBytes)</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>        // if lengths don&#39;t match the arrays are not equal</span>
 469 |     | <span class='neutral'>            switch eq(slength, mlength)</span>
 470 |     | <span class='neutral'>            case 1 {</span>
 471 |     | <span class='neutral'>            // slength can contain both the length and contents of the array</span>
 472 |     | <span class='neutral'>            // if length &lt; 32 bytes so let&#39;s prepare for that</span>
 473 |     | <span class='neutral'>            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</span>
 474 |     | <span class='neutral'>                if iszero(iszero(slength)) {</span>
 475 |     | <span class='neutral'>                    switch lt(slength, 32)</span>
 476 |     | <span class='neutral'>                    case 1 {</span>
 477 |     | <span class='neutral'>                    // blank the last byte which is the length</span>
 478 |     | <span class='neutral'>                        fslot := mul(div(fslot, 0x100), 0x100)</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {</span>
 481 |     | <span class='neutral'>                        // unsuccess:</span>
 482 |     | <span class='neutral'>                            success := 0</span>
 483 |     | <span class='neutral'>                        }</span>
 484 |     | <span class='neutral'>                    }</span>
 485 |     | <span class='neutral'>                    default {</span>
 486 |     | <span class='neutral'>                    // cb is a circuit breaker in the for loop since there&#39;s</span>
 487 |     | <span class='neutral'>                    //  no said feature for inline assembly loops</span>
 488 |     | <span class='neutral'>                    // cb = 1 - don&#39;t breaker</span>
 489 |     | <span class='neutral'>                    // cb = 0 - break</span>
 490 |     | <span class='neutral'>                        let cb := 1</span>
 491 |     | <span class='neutral'></span>
 492 |     | <span class='neutral'>                    // get the keccak hash to get the contents of the array</span>
 493 |     | <span class='neutral'>                        mstore(0x0, _preBytes.slot)</span>
 494 |     | <span class='neutral'>                        let sc := keccak256(0x0, 0x20)</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>                        let mc := add(_postBytes, 0x20)</span>
 497 |     | <span class='neutral'>                        let end := add(mc, mlength)</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>                    // the next line is the loop condition:</span>
 500 |     | <span class='neutral'>                    // while(uint256(mc &lt; end) + cb == 2)</span>
 501 |     | <span class='neutral'>                        for {} eq(add(lt(mc, end), cb), 2) {</span>
 502 |     | <span class='neutral'>                            sc := add(sc, 1)</span>
 503 |     | <span class='neutral'>                            mc := add(mc, 0x20)</span>
 504 |     | <span class='neutral'>                        } {</span>
 505 |     | <span class='neutral'>                            if iszero(eq(sload(sc), mload(mc))) {</span>
 506 |     | <span class='neutral'>                            // unsuccess:</span>
 507 |     | <span class='neutral'>                                success := 0</span>
 508 |     | <span class='neutral'>                                cb := 0</span>
 509 |     | <span class='neutral'>                            }</span>
 510 |     | <span class='neutral'>                        }</span>
 511 |     | <span class='neutral'>                    }</span>
 512 |     | <span class='neutral'>                }</span>
 513 |     | <span class='neutral'>            }</span>
 514 |     | <span class='neutral'>            default {</span>
 515 |     | <span class='neutral'>            // unsuccess:</span>
 516 |     | <span class='neutral'>                success := 0</span>
 517 |     | <span class='neutral'>            }</span>
 518 |     | <span class='neutral'>        }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>        return success;</span>
 521 |     | <span class='neutral'>    }</span>
 522 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Contains 512-bit math functions</span>
   5 |     | <span class='neutral'>/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision</span>
   6 |     | <span class='neutral'>/// @dev Handles &quot;phantom overflow&quot; i.e., allows multiplication and division where an intermediate value overflows 256 bits</span>
   7 |     | <span class='unexecuted'>library FullMath {</span>
   8 |     | <span class='neutral'>    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
   9 |     | <span class='neutral'>    /// @param a The multiplicand</span>
  10 |     | <span class='neutral'>    /// @param b The multiplier</span>
  11 |     | <span class='neutral'>    /// @param denominator The divisor</span>
  12 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
  13 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
  14 | *   | <span class='executed'>    function mulDiv(</span>
  15 |     | <span class='neutral'>        uint256 a,</span>
  16 |     | <span class='neutral'>        uint256 b,</span>
  17 |     | <span class='neutral'>        uint256 denominator</span>
  18 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
  19 |     | <span class='neutral'>        unchecked {</span>
  20 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = a * b</span>
  21 |     | <span class='neutral'>            // Compute the product mod 2**256 and mod 2**256 - 1</span>
  22 |     | <span class='neutral'>            // then use the Chinese Remainder Theorem to reconstruct</span>
  23 |     | <span class='neutral'>            // the 512 bit result. The result is stored in two 256</span>
  24 |     | <span class='neutral'>            // variables such that product = prod1 * 2**256 + prod0</span>
  25 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product</span>
  26 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
  27 |     | <span class='neutral'>            assembly {</span>
  28 |     | <span class='unexecuted'>                let mm := mulmod(a, b, not(0))</span>
  29 |     | <span class='unexecuted'>                prod0 := mul(a, b)</span>
  30 |     | <span class='unexecuted'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  31 |     | <span class='neutral'>            }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division</span>
  34 |     | <span class='unexecuted'>            if (prod1 == 0) {</span>
  35 |     | <span class='unexecuted'>                require(denominator &gt; 0);</span>
  36 |     | <span class='neutral'>                assembly {</span>
  37 |     | <span class='unexecuted'>                    result := div(prod0, denominator)</span>
  38 |     | <span class='neutral'>                }</span>
  39 |     | <span class='unexecuted'>                return result;</span>
  40 |     | <span class='neutral'>            }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>            // Make sure the result is less than 2**256.</span>
  43 |     | <span class='neutral'>            // Also prevents denominator == 0</span>
  44 |     | <span class='unexecuted'>            require(denominator &gt; prod1);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  47 |     | <span class='neutral'>            // 512 by 256 division.</span>
  48 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0]</span>
  51 |     | <span class='neutral'>            // Compute remainder using mulmod</span>
  52 |     | <span class='unexecuted'>            uint256 remainder;</span>
  53 |     | <span class='neutral'>            assembly {</span>
  54 |     | <span class='unexecuted'>                remainder := mulmod(a, b, denominator)</span>
  55 |     | <span class='neutral'>            }</span>
  56 |     | <span class='neutral'>            // Subtract 256 bit number from 512 bit number</span>
  57 |     | <span class='neutral'>            assembly {</span>
  58 |     | <span class='unexecuted'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  59 |     | <span class='unexecuted'>                prod0 := sub(prod0, remainder)</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>            // Factor powers of two out of denominator</span>
  63 |     | <span class='neutral'>            // Compute largest power of two divisor of denominator.</span>
  64 |     | <span class='neutral'>            // Always &gt;= 1.</span>
  65 |     | <span class='neutral'>            // EDIT for 0.8 compatibility:</span>
  66 |     | <span class='neutral'>            // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256</span>
  67 |     | <span class='unexecuted'>            uint256 twos = denominator &amp; (~denominator + 1);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>            // Divide denominator by power of two</span>
  70 |     | <span class='neutral'>            assembly {</span>
  71 |     | <span class='unexecuted'>                denominator := div(denominator, twos)</span>
  72 |     | <span class='neutral'>            }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>            // Divide [prod1 prod0] by the factors of two</span>
  75 |     | <span class='neutral'>            assembly {</span>
  76 |     | <span class='unexecuted'>                prod0 := div(prod0, twos)</span>
  77 |     | <span class='neutral'>            }</span>
  78 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0. For this we need</span>
  79 |     | <span class='neutral'>            // to flip `twos` such that it is 2**256 / twos.</span>
  80 |     | <span class='neutral'>            // If twos is zero, then it becomes one</span>
  81 |     | <span class='neutral'>            assembly {</span>
  82 |     | <span class='unexecuted'>                twos := add(div(sub(0, twos), twos), 1)</span>
  83 |     | <span class='neutral'>            }</span>
  84 |     | <span class='unexecuted'>            prod0 |= prod1 * twos;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>            // Invert denominator mod 2**256</span>
  87 |     | <span class='neutral'>            // Now that denominator is an odd number, it has an inverse</span>
  88 |     | <span class='neutral'>            // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  89 |     | <span class='neutral'>            // Compute the inverse by starting with a seed that is correct</span>
  90 |     | <span class='neutral'>            // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
  91 |     | <span class='unexecuted'>            uint256 inv = (3 * denominator) ^ 2;</span>
  92 |     | <span class='neutral'>            // Now use Newton-Raphson iteration to improve the precision.</span>
  93 |     | <span class='neutral'>            // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  94 |     | <span class='neutral'>            // arithmetic, doubling the correct bits in each step.</span>
  95 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // inverse mod 2**8</span>
  96 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // inverse mod 2**16</span>
  97 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // inverse mod 2**32</span>
  98 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // inverse mod 2**64</span>
  99 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // inverse mod 2**128</span>
 100 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // inverse mod 2**256</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying</span>
 103 |     | <span class='neutral'>            // with the modular inverse of denominator. This will give us the</span>
 104 |     | <span class='neutral'>            // correct result modulo 2**256. Since the precoditions guarantee</span>
 105 |     | <span class='neutral'>            // that the outcome is less than 2**256, this is the final result.</span>
 106 |     | <span class='neutral'>            // We don&#39;t need to compute the high bits of the result and prod1</span>
 107 |     | <span class='neutral'>            // is no longer required.</span>
 108 |     | <span class='unexecuted'>            result = prod0 * inv;</span>
 109 |     | <span class='neutral'>            return result;</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
 114 |     | <span class='neutral'>    /// @param a The multiplicand</span>
 115 |     | <span class='neutral'>    /// @param b The multiplier</span>
 116 |     | <span class='neutral'>    /// @param denominator The divisor</span>
 117 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
 118 |     | <span class='neutral'>    function mulDivRoundingUp(</span>
 119 |     | <span class='neutral'>        uint256 a,</span>
 120 |     | <span class='neutral'>        uint256 b,</span>
 121 |     | <span class='neutral'>        uint256 denominator</span>
 122 |     | <span class='neutral'>    ) internal pure returns (uint256 result) {</span>
 123 |     | <span class='neutral'>        result = mulDiv(a, b, denominator);</span>
 124 |     | <span class='neutral'>        if (mulmod(a, b, denominator) &gt; 0) {</span>
 125 |     | <span class='neutral'>            require(result &lt; type(uint256).max);</span>
 126 |     | <span class='neutral'>            result++;</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/LiquidityAmounts.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>import &quot;./FullMath.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>/// @title FixedPoint96</span>
   6 |     | <span class='neutral'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
   7 |     | <span class='neutral'>/// @dev Used in SqrtPriceMath.sol</span>
   8 |     | <span class='neutral'>//audit-info This library defines constants for handling binary fixed point numbers with a resolution of 96 bits.</span>
   9 |     | <span class='unexecuted'>library FixedPoint96 {</span>
  10 |     | <span class='unexecuted'>    uint8 internal constant RESOLUTION = 96;</span>
  11 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  12 |     | <span class='neutral'>}</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @title Liquidity amount functions</span>
  15 |     | <span class='neutral'>/// @notice Provides functions for computing liquidity amounts from token amounts and prices</span>
  16 |     | <span class='neutral'>//audit-info This library provides functions to compute liquidity amounts from token amounts and prices, and vice versa.</span>
  17 |     | <span class='unexecuted'>library LiquidityAmounts {</span>
  18 |     | <span class='unexecuted'>    function toUint128(uint256 x) private pure returns (uint128 y) {</span>
  19 |     | <span class='unexecuted'>        require((y = uint128(x)) == x);</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range</span>
  23 |     | <span class='neutral'>    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).</span>
  24 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
  25 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
  26 |     | <span class='neutral'>    /// @param amount0 The amount0 being sent in</span>
  27 |     | <span class='neutral'>    /// @return liquidity The amount of returned liquidity</span>
  28 |     | <span class='unexecuted'>    function getLiquidityForAmount0(</span>
  29 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  30 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  31 |     | <span class='neutral'>        uint256 amount0</span>
  32 |     | <span class='unexecuted'>    ) internal pure returns (uint128 liquidity) {</span>
  33 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96)</span>
  34 |     | <span class='unexecuted'>            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  35 |     | <span class='unexecuted'>        uint256 intermediate =</span>
  36 |     | <span class='unexecuted'>            FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96); //audit Can&#39;t oveflow revert ? </span>
  37 |     | <span class='neutral'>        return</span>
  38 |     | <span class='unexecuted'>            toUint128(</span>
  39 |     | <span class='unexecuted'>                FullMath.mulDiv(</span>
  40 |     | <span class='unexecuted'>                    amount0,</span>
  41 |     | <span class='neutral'>                    intermediate,</span>
  42 |     | <span class='unexecuted'>                    sqrtRatioBX96 - sqrtRatioAX96</span>
  43 |     | <span class='neutral'>                )</span>
  44 |     | <span class='neutral'>            );</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range</span>
  48 |     | <span class='neutral'>    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).</span>
  49 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
  50 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
  51 |     | <span class='neutral'>    /// @param amount1 The amount1 being sent in</span>
  52 |     | <span class='neutral'>    /// @return liquidity The amount of returned liquidity</span>
  53 |     | <span class='unexecuted'>    function getLiquidityForAmount1(</span>
  54 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  55 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  56 |     | <span class='neutral'>        uint256 amount1</span>
  57 |     | <span class='unexecuted'>    ) internal pure returns (uint128 liquidity) {</span>
  58 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96)</span>
  59 |     | <span class='unexecuted'>            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  60 |     | <span class='neutral'>        return</span>
  61 |     | <span class='unexecuted'>            toUint128(</span>
  62 |     | <span class='unexecuted'>                FullMath.mulDiv(</span>
  63 |     | <span class='unexecuted'>                    amount1,</span>
  64 |     | <span class='neutral'>                    FixedPoint96.Q96,</span>
  65 |     | <span class='unexecuted'>                    sqrtRatioBX96 - sqrtRatioAX96</span>
  66 |     | <span class='neutral'>                )</span>
  67 |     | <span class='neutral'>            );</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current</span>
  71 |     | <span class='neutral'>    /// pool prices and the prices at the tick boundaries</span>
  72 |     | <span class='unexecuted'>    function getLiquidityForAmounts(</span>
  73 |     | <span class='neutral'>        uint160 sqrtRatioX96,</span>
  74 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  75 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  76 |     | <span class='neutral'>        uint256 amount0,</span>
  77 |     | <span class='neutral'>        uint256 amount1</span>
  78 |     | <span class='unexecuted'>    ) internal pure returns (uint128 liquidity) {</span>
  79 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96)</span>
  80 |     | <span class='unexecuted'>            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        if (sqrtRatioX96 &lt;= sqrtRatioAX96) {</span>
  83 |     | <span class='unexecuted'>            liquidity = getLiquidityForAmount0(</span>
  84 |     | <span class='unexecuted'>                sqrtRatioAX96,</span>
  85 |     | <span class='unexecuted'>                sqrtRatioBX96,</span>
  86 |     | <span class='unexecuted'>                amount0</span>
  87 |     | <span class='neutral'>            );</span>
  88 |     | <span class='unexecuted'>        } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {</span>
  89 |     | <span class='unexecuted'>            uint128 liquidity0 =</span>
  90 |     | <span class='unexecuted'>                getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);</span>
  91 |     | <span class='unexecuted'>            uint128 liquidity1 =</span>
  92 |     | <span class='unexecuted'>                getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>            liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;</span>
  95 |     | <span class='neutral'>        } else {</span>
  96 |     | <span class='unexecuted'>            liquidity = getLiquidityForAmount1(</span>
  97 |     | <span class='unexecuted'>                sqrtRatioAX96,</span>
  98 |     | <span class='unexecuted'>                sqrtRatioBX96,</span>
  99 |     | <span class='unexecuted'>                amount1</span>
 100 |     | <span class='neutral'>            );</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range</span>
 105 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 106 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 107 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
 108 |     | <span class='neutral'>    /// @return amount0 The amount0</span>
 109 |     | <span class='unexecuted'>    function getAmount0ForLiquidity(</span>
 110 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 111 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 112 |     | <span class='neutral'>        uint128 liquidity</span>
 113 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount0) {</span>
 114 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96)</span>
 115 |     | <span class='unexecuted'>            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        return</span>
 118 |     | <span class='unexecuted'>            FullMath.mulDiv(</span>
 119 |     | <span class='unexecuted'>                uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION,</span>
 120 |     | <span class='unexecuted'>                sqrtRatioBX96 - sqrtRatioAX96,</span>
 121 |     | <span class='unexecuted'>                sqrtRatioBX96</span>
 122 |     | <span class='unexecuted'>            ) / sqrtRatioAX96;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range</span>
 126 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 127 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 128 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
 129 |     | <span class='neutral'>    /// @return amount1 The amount1</span>
 130 |     | <span class='unexecuted'>    function getAmount1ForLiquidity(</span>
 131 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 132 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 133 |     | <span class='neutral'>        uint128 liquidity</span>
 134 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount1) {</span>
 135 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96)</span>
 136 |     | <span class='unexecuted'>            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        return</span>
 139 |     | <span class='unexecuted'>            FullMath.mulDiv(</span>
 140 |     | <span class='neutral'>                liquidity,</span>
 141 |     | <span class='unexecuted'>                sqrtRatioBX96 - sqrtRatioAX96,</span>
 142 |     | <span class='neutral'>                FixedPoint96.Q96</span>
 143 |     | <span class='neutral'>            );</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current</span>
 147 |     | <span class='neutral'>    /// pool prices and the prices at the tick boundaries</span>
 148 |     | <span class='unexecuted'>    function getAmountsForLiquidity(</span>
 149 |     | <span class='neutral'>        uint160 sqrtRatioX96,</span>
 150 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 151 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 152 |     | <span class='neutral'>        uint128 liquidity</span>
 153 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount0, uint256 amount1) {</span>
 154 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96)</span>
 155 |     | <span class='unexecuted'>            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        if (sqrtRatioX96 &lt;= sqrtRatioAX96) {</span>
 158 |     | <span class='unexecuted'>            amount0 = getAmount0ForLiquidity(</span>
 159 |     | <span class='unexecuted'>                sqrtRatioAX96,</span>
 160 |     | <span class='unexecuted'>                sqrtRatioBX96,</span>
 161 |     | <span class='unexecuted'>                liquidity</span>
 162 |     | <span class='neutral'>            );</span>
 163 |     | <span class='unexecuted'>        } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {</span>
 164 |     | <span class='unexecuted'>            amount0 = getAmount0ForLiquidity(</span>
 165 |     | <span class='unexecuted'>                sqrtRatioX96,</span>
 166 |     | <span class='unexecuted'>                sqrtRatioBX96,</span>
 167 |     | <span class='unexecuted'>                liquidity</span>
 168 |     | <span class='neutral'>            );</span>
 169 |     | <span class='unexecuted'>            amount1 = getAmount1ForLiquidity(</span>
 170 |     | <span class='unexecuted'>                sqrtRatioAX96,</span>
 171 |     | <span class='unexecuted'>                sqrtRatioX96,</span>
 172 |     | <span class='unexecuted'>                liquidity</span>
 173 |     | <span class='neutral'>            );</span>
 174 |     | <span class='neutral'>        } else {</span>
 175 |     | <span class='unexecuted'>            amount1 = getAmount1ForLiquidity(</span>
 176 |     | <span class='unexecuted'>                sqrtRatioAX96,</span>
 177 |     | <span class='unexecuted'>                sqrtRatioBX96,</span>
 178 |     | <span class='unexecuted'>                liquidity</span>
 179 |     | <span class='neutral'>            );</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/Path.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>//audit-info What is that Library? </span>
  5 |     | <span class='neutral'>import &#39;./BytesLib.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title Functions for manipulating path data for multihop swaps</span>
  8 |     | <span class='unexecuted'>library Path {</span>
  9 |     | <span class='neutral'>    using BytesLib for bytes;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @dev The length of the bytes encoded address</span>
 12 |     | <span class='unexecuted'>    uint256 private constant ADDR_SIZE = 20;</span>
 13 |     | <span class='neutral'>    /// @dev The length of the bytes encoded fee</span>
 14 |     | <span class='unexecuted'>    uint256 private constant FEE_SIZE = 3;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @dev The offset of a single token address and pool fee</span>
 17 |     | <span class='unexecuted'>    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE; //== 23</span>
 18 |     | <span class='neutral'>    /// @dev The offset of an encoded pool key</span>
 19 |     | <span class='neutral'>    //audit-info Why do they again add the address&#39;s size </span>
 20 |     | <span class='neutral'>    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE; //== 43</span>
 21 |     | <span class='neutral'>    /// @dev The minimum length of an encoding that contains 2 or more pools</span>
 22 |     | <span class='neutral'>    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET; //== 66</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Returns true iff the path contains two or more pools</span>
 25 |     | <span class='neutral'>    /// @param path The encoded swap path</span>
 26 |     | <span class='neutral'>    /// @return True if path contains two or more pools, otherwise false</span>
 27 |     | <span class='neutral'>    function hasMultiplePools(bytes memory path) internal pure returns (bool) {</span>
 28 |     | <span class='neutral'>        return path.length &gt;= MULTIPLE_POOLS_MIN_LENGTH;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns the number of pools in the path</span>
 32 |     | <span class='neutral'>    /// @param path The encoded swap path</span>
 33 |     | <span class='neutral'>    /// @return The number of pools in the path</span>
 34 |     | <span class='unexecuted'>    function numPools(bytes memory path) internal pure returns (uint256) {</span>
 35 |     | <span class='neutral'>        // Ignore the first token address. From then on every fee and token offset indicates a pool.</span>
 36 |     | <span class='unexecuted'>        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Decodes the first pool in path</span>
 40 |     | <span class='neutral'>    /// @param path The bytes encoded swap path</span>
 41 |     | <span class='neutral'>    /// @return tokenA The first token of the given pool</span>
 42 |     | <span class='neutral'>    /// @return tokenB The second token of the given pool</span>
 43 |     | <span class='neutral'>    /// @return fee The fee level of the pool</span>
 44 |     | <span class='unexecuted'>    function decodeFirstPool(bytes memory path)</span>
 45 |     | <span class='neutral'>    internal</span>
 46 |     | <span class='neutral'>    pure</span>
 47 |     | <span class='neutral'>    returns (</span>
 48 |     | <span class='unexecuted'>        address tokenA,</span>
 49 |     | <span class='neutral'>        address tokenB,</span>
 50 |     | <span class='neutral'>        uint24 fee</span>
 51 |     | <span class='neutral'>    )</span>
 52 |     | <span class='neutral'>    {</span>
 53 |     | <span class='unexecuted'>        tokenA = path.toAddress(0);</span>
 54 |     | <span class='unexecuted'>        fee = path.toUint24(ADDR_SIZE);</span>
 55 |     | <span class='unexecuted'>        tokenB = path.toAddress(NEXT_OFFSET);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    /// @notice Gets the segment corresponding to the first pool in the path</span>
 59 |     | <span class='neutral'>    /// @param path The bytes encoded swap path</span>
 60 |     | <span class='neutral'>    /// @return The segment containing all data necessary to target the first pool in the path</span>
 61 |     | <span class='neutral'>    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {</span>
 62 |     | <span class='neutral'>        return path.slice(0, POP_OFFSET);</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /// @notice Skips a token + fee element from the buffer and returns the remainder</span>
 66 |     | <span class='neutral'>    /// @param path The swap path</span>
 67 |     | <span class='neutral'>    /// @return The remaining token + fee elements in the path</span>
 68 |     | <span class='unexecuted'>    function skipToken(bytes memory path) internal pure returns (bytes memory) {</span>
 69 |     | <span class='unexecuted'>        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/TickMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// @title Math library for computing sqrt prices from ticks and vice versa</span>
  5 |     | <span class='neutral'>// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports</span>
  6 |     | <span class='neutral'>// prices between 2**-128 and 2**128</span>
  7 |     | <span class='unexecuted'>library TickMath {</span>
  8 |     | <span class='neutral'>  // @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128</span>
  9 |     | <span class='neutral'>  int24 internal constant MIN_TICK = -887272;</span>
 10 |     | <span class='neutral'>  // @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128</span>
 11 |     | <span class='unexecuted'>  int24 internal constant MAX_TICK = -MIN_TICK;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  // @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)</span>
 14 |     | <span class='neutral'>  uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
 15 |     | <span class='neutral'>  // @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)</span>
 16 |     | <span class='neutral'>  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>  // @notice Calculates sqrt(1.0001^tick) * 2^96</span>
 19 |     | <span class='neutral'>  // @dev Throws if |tick| &gt; max tick</span>
 20 |     | <span class='neutral'>  // @param tick The input tick for the above formula</span>
 21 |     | <span class='neutral'>  // @return sqrtP A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
 22 |     | <span class='neutral'>  // at the given tick</span>
 23 |     | <span class='unexecuted'>  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtP) {</span>
 24 |     | <span class='unexecuted'>    unchecked {</span>
 25 |     | <span class='unexecuted'>      uint256 absTick = uint256(tick &lt; 0 ? -int256(tick) : int256(tick));</span>
 26 |     | <span class='unexecuted'>      require(absTick &lt;= uint256(int256(MAX_TICK)), &#39;T&#39;);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>      // do bitwise comparison, if i-th bit is turned on,</span>
 29 |     | <span class='neutral'>      // multiply ratio by hardcoded values of sqrt(1.0001^-(2^i)) * 2^128</span>
 30 |     | <span class='neutral'>      // where 0 &lt;= i &lt;= 19</span>
 31 |     | <span class='unexecuted'>      uint256 ratio = (absTick &amp; 0x1 != 0)</span>
 32 |     | <span class='unexecuted'>        ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
 33 |     | <span class='neutral'>        : 0x100000000000000000000000000000000;</span>
 34 |     | <span class='unexecuted'>      if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
 35 |     | <span class='unexecuted'>      if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
 36 |     | <span class='unexecuted'>      if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
 37 |     | <span class='unexecuted'>      if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
 38 |     | <span class='unexecuted'>      if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
 39 |     | <span class='unexecuted'>      if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
 40 |     | <span class='unexecuted'>      if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
 41 |     | <span class='unexecuted'>      if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
 42 |     | <span class='unexecuted'>      if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
 43 |     | <span class='unexecuted'>      if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
 44 |     | <span class='unexecuted'>      if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
 45 |     | <span class='unexecuted'>      if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
 46 |     | <span class='unexecuted'>      if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
 47 |     | <span class='unexecuted'>      if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
 48 |     | <span class='unexecuted'>      if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
 49 |     | <span class='unexecuted'>      if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
 50 |     | <span class='unexecuted'>      if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
 51 |     | <span class='unexecuted'>      if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
 52 |     | <span class='unexecuted'>      if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>      // take reciprocal for positive tick values</span>
 55 |     | <span class='unexecuted'>      if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>      // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
 58 |     | <span class='neutral'>      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span>
 59 |     | <span class='neutral'>      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span>
 60 |     | <span class='unexecuted'>      sqrtP = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'>  }</span>
 63 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/TickUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./Path.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./TickMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./LiquidityAmounts.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library TickUtils {</span>
   9 |     | <span class='neutral'>    using Path for bytes;</span>
  10 |     | <span class='neutral'>    using TickMath for int24;</span>
  11 |     | <span class='neutral'>    </span>
  12 |     | <span class='neutral'>    //audit Not sure on what the function is suppose to do. Missing Naspec</span>
  13 |     | <span class='unexecuted'>    function floor(int24 tick, int24 tickSpacing) internal pure returns (int24) {</span>
  14 |     | <span class='unexecuted'>        int24 compressed = tick / tickSpacing;</span>
  15 |     | <span class='unexecuted'>        if (tick &lt; 0 &amp;&amp; tick % tickSpacing != 0) compressed--;</span>
  16 |     | <span class='unexecuted'>        return compressed * tickSpacing;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    /// @dev Calc base ticks depending on base threshold and tickspacing</span>
  20 |     | <span class='unexecuted'>    function baseTicks(</span>
  21 |     | <span class='neutral'>        int24 currentTick,</span>
  22 |     | <span class='neutral'>        int24 baseThreshold,</span>
  23 |     | <span class='neutral'>        int24 tickSpacing</span>
  24 |     | <span class='unexecuted'>    ) internal pure returns (int24 tickLower, int24 tickUpper) {</span>
  25 |     | <span class='unexecuted'>        int24 tickFloor = floor(currentTick, tickSpacing);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>        tickLower = tickFloor - baseThreshold;</span>
  28 |     | <span class='unexecuted'>        tickUpper = tickFloor + baseThreshold;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function quoteAddLiquidity(int24 _currentTick, int24 _lowerTick, int24 _upperTick, uint256 _amt0, uint256 _amt1) internal pure returns(uint256 _actualAmount0, uint256 _actualAmount1, uint256 _liquidity) {</span>
  32 |     | <span class='neutral'>        // Grab the amount of liquidity for our token balances</span>
  33 |     | <span class='neutral'>        _liquidity = LiquidityAmounts.getLiquidityForAmounts(</span>
  34 |     | <span class='neutral'>                _currentTick.getSqrtRatioAtTick(),</span>
  35 |     | <span class='neutral'>                _lowerTick.getSqrtRatioAtTick(),</span>
  36 |     | <span class='neutral'>                _upperTick.getSqrtRatioAtTick(),</span>
  37 |     | <span class='neutral'>                _amt0,</span>
  38 |     | <span class='neutral'>                _amt1</span>
  39 |     | <span class='neutral'>        );</span>
  40 |     | <span class='neutral'>        </span>
  41 |     | <span class='neutral'>        ( _actualAmount0,  _actualAmount1) = LiquidityAmounts.getAmountsForLiquidity(</span>
  42 |     | <span class='neutral'>                _currentTick.getSqrtRatioAtTick(),</span>
  43 |     | <span class='neutral'>                _lowerTick.getSqrtRatioAtTick(),</span>
  44 |     | <span class='neutral'>                _upperTick.getSqrtRatioAtTick(),</span>
  45 |     | <span class='neutral'>                uint128(_liquidity)</span>
  46 |     | <span class='neutral'>        );</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    //audit-info Get deeper in this function</span>
  51 |     | <span class='neutral'>    function getQuoteAtTick(</span>
  52 |     | <span class='neutral'>        int24 tick,</span>
  53 |     | <span class='neutral'>        uint128 baseAmount,</span>
  54 |     | <span class='neutral'>        address baseToken,</span>
  55 |     | <span class='neutral'>        address quoteToken</span>
  56 |     | <span class='neutral'>    ) internal pure returns (uint256 quoteAmount) {</span>
  57 |     | <span class='neutral'>        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // Calculate quoteAmount with better precision if it doesn&#39;t overflow when multiplied by itself</span>
  60 |     | <span class='neutral'>        if (sqrtRatioX96 &lt;= type(uint128).max) {</span>
  61 |     | <span class='neutral'>            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;</span>
  62 |     | <span class='neutral'>            quoteAmount = baseToken &lt; quoteToken</span>
  63 |     | <span class='neutral'>                ? FullMath.mulDiv(ratioX192, baseAmount, 1 &lt;&lt; 192)</span>
  64 |     | <span class='neutral'>                : FullMath.mulDiv(1 &lt;&lt; 192, baseAmount, ratioX192);</span>
  65 |     | <span class='neutral'>        } else {</span>
  66 |     | <span class='neutral'>            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 &lt;&lt; 64);</span>
  67 |     | <span class='neutral'>            quoteAmount = baseToken &lt; quoteToken</span>
  68 |     | <span class='neutral'>                ? FullMath.mulDiv(ratioX128, baseAmount, 1 &lt;&lt; 128)</span>
  69 |     | <span class='neutral'>                : FullMath.mulDiv(1 &lt;&lt; 128, baseAmount, ratioX128);</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    // Convert encoded path to token route</span>
  74 |     | <span class='neutral'>    function pathToRoute(bytes memory _path) internal pure returns (address[] memory, uint24[] memory) {</span>
  75 |     | <span class='neutral'>        uint256 numPools = _path.numPools();</span>
  76 |     | <span class='neutral'>        address[] memory route = new address[](numPools + 1);</span>
  77 |     | <span class='neutral'>        uint24[] memory fees = new uint24[](numPools);</span>
  78 |     | <span class='neutral'>        for (uint256 i; i &lt; numPools; i++) {</span>
  79 |     | <span class='neutral'>            (address tokenA, address tokenB, uint24 fee) = _path.decodeFirstPool();</span>
  80 |     | <span class='neutral'>            route[i] = tokenA;</span>
  81 |     | <span class='neutral'>            route[i + 1] = tokenB;</span>
  82 |     | <span class='neutral'>            fees[i] = fee;</span>
  83 |     | <span class='neutral'>            _path = _path.skipToken();</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'>        return (route, fees);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    // Convert token route to encoded path</span>
  89 |     | <span class='neutral'>    // uint24 type for fees so path is packed tightly</span>
  90 |     | <span class='neutral'>    function routeToPath(</span>
  91 |     | <span class='neutral'>        address[] memory _route,</span>
  92 |     | <span class='neutral'>        uint24[] memory _fee</span>
  93 |     | <span class='neutral'>    ) internal pure returns (bytes memory path) {</span>
  94 |     | <span class='neutral'>        path = abi.encodePacked(_route[0]);</span>
  95 |     | <span class='neutral'>        uint256 feeLength = _fee.length;</span>
  96 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; feeLength; i++) {</span>
  97 |     | <span class='neutral'>            path = abi.encodePacked(path, _fee[i], _route[i+1]);</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/UniV3Utils.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;./Path.sol&#39;;</span>
  6 |     | <span class='neutral'>import &quot;../interfaces/uniswap/IUniswapRouterV3.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library UniV3Utils {</span>
  9 |     | <span class='neutral'>    using Path for bytes;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Swap along an encoded path using known amountIn</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function swap(</span>
 14 |     | <span class='neutral'>        address _user,</span>
 15 |     | <span class='neutral'>        address _router,</span>
 16 |     | <span class='neutral'>        bytes memory _path,</span>
 17 |     | <span class='neutral'>        uint256 _amountIn</span>
 18 |     | <span class='neutral'>    ) internal returns (uint256 amountOut) {</span>
 19 |     | <span class='neutral'>        IUniswapRouterV3.ExactInputParams memory params = IUniswapRouterV3.ExactInputParams({</span>
 20 |     | <span class='neutral'>            path: _path,</span>
 21 |     | <span class='neutral'>            recipient: _user,</span>
 22 |     | <span class='neutral'>            amountIn: _amountIn,</span>
 23 |     | <span class='neutral'>            amountOutMinimum: 0</span>
 24 |     | <span class='neutral'>        });</span>
 25 |     | <span class='neutral'>        return IUniswapRouterV3(_router).exactInput(params);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function swap(</span>
 29 |     | <span class='neutral'>        address _router,</span>
 30 |     | <span class='neutral'>        bytes memory _path,</span>
 31 |     | <span class='neutral'>        uint256 _amountIn</span>
 32 |     | <span class='neutral'>    ) internal returns (uint256 amountOut) {</span>
 33 |     | <span class='neutral'>        IUniswapRouterV3.ExactInputParams memory params = IUniswapRouterV3.ExactInputParams({</span>
 34 |     | <span class='neutral'>            path: _path,</span>
 35 |     | <span class='neutral'>            recipient: address(this),</span>
 36 |     | <span class='neutral'>            amountIn: _amountIn,</span>
 37 |     | <span class='neutral'>            amountOutMinimum: 0</span>
 38 |     | <span class='neutral'>        });</span>
 39 |     | <span class='neutral'>        return IUniswapRouterV3(_router).exactInput(params);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    // Swap along a token route using known fees and amountIn</span>
 43 |     | <span class='neutral'>    function swap(</span>
 44 |     | <span class='neutral'>        address _router,</span>
 45 |     | <span class='neutral'>        address[] memory _route,</span>
 46 |     | <span class='neutral'>        uint24[] memory _fee,</span>
 47 |     | <span class='neutral'>        uint256 _amountIn</span>
 48 |     | <span class='neutral'>    ) internal returns (uint256 amountOut) {</span>
 49 |     | <span class='neutral'>        return swap(_router, routeToPath(_route, _fee), _amountIn);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    // Convert encoded path to token route</span>
 53 |     | <span class='neutral'>    function pathToRoute(bytes memory _path) internal pure returns (address[] memory) {</span>
 54 |     | <span class='neutral'>        uint256 numPools = _path.numPools();</span>
 55 |     | <span class='neutral'>        address[] memory route = new address[](numPools + 1);</span>
 56 |     | <span class='neutral'>        for (uint256 i; i &lt; numPools; i++) {</span>
 57 |     | <span class='neutral'>            (address tokenA, address tokenB,) = _path.decodeFirstPool();</span>
 58 |     | <span class='neutral'>            route[i] = tokenA;</span>
 59 |     | <span class='neutral'>            route[i + 1] = tokenB;</span>
 60 |     | <span class='neutral'>            _path = _path.skipToken();</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'>        return route;</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    // Convert token route to encoded path</span>
 66 |     | <span class='neutral'>    // uint24 type for fees so path is packed tightly</span>
 67 |     | <span class='neutral'>    function routeToPath(</span>
 68 |     | <span class='neutral'>        address[] memory _route,</span>
 69 |     | <span class='neutral'>        uint24[] memory _fee</span>
 70 |     | <span class='neutral'>    ) internal pure returns (bytes memory path) {</span>
 71 |     | <span class='neutral'>        path = abi.encodePacked(_route[0]);</span>
 72 |     | <span class='neutral'>        uint256 feeLength = _fee.length;</span>
 73 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; feeLength; i++) {</span>
 74 |     | <span class='neutral'>            path = abi.encodePacked(path, _fee[i], _route[i+1]);</span>
 75 |     | <span class='neutral'>        }</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/utils/VeloSwapUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &#39;./Path.sol&#39;;</span>
   6 |     | <span class='neutral'>import &quot;../interfaces/velodrome/IVeloRouter.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library VeloSwapUtils {</span>
   9 |     | <span class='neutral'>    struct Route {</span>
  10 |     | <span class='neutral'>        address from;</span>
  11 |     | <span class='neutral'>        address to;</span>
  12 |     | <span class='neutral'>        bool stable;</span>
  13 |     | <span class='neutral'>        address factory;</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    using Path for bytes;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    bytes1 constant V3_SWAP_EXACT_IN = 0x00;</span>
  19 |     | <span class='unexecuted'>    bytes1 constant V2_SWAP_EXACT_IN = 0x08;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    // Swap along an encoded path using known amountIn</span>
  22 |     | <span class='neutral'>    //audit-info Check on Velodrome Finance for Swap Execution.</span>
  23 |     | <span class='neutral'>    //audit-info Also check on Solodit for related issue in Velodrome Integration.</span>
  24 |     | <span class='unexecuted'>    function swap(</span>
  25 |     | <span class='neutral'>        address _router,</span>
  26 |     | <span class='neutral'>        bytes memory _path,</span>
  27 |     | <span class='neutral'>        uint256 _amountIn,</span>
  28 |     | <span class='neutral'>        bool _isV3</span>
  29 |     | <span class='neutral'>    ) internal {</span>
  30 |     | <span class='unexecuted'>        if (_isV3) {</span>
  31 |     | <span class='unexecuted'>            bytes memory input = abi.encode(address(this), _amountIn, 0, _path, true);</span>
  32 |     | <span class='unexecuted'>            bytes[] memory inputs = new bytes[](1);</span>
  33 |     | <span class='unexecuted'>            inputs[0] = input;</span>
  34 |     | <span class='unexecuted'>            IVeloRouter(_router).execute(abi.encodePacked(V3_SWAP_EXACT_IN), inputs, block.timestamp);</span>
  35 |     | <span class='neutral'>        } else {</span>
  36 |     | <span class='unexecuted'>            address[] memory route = pathToRoute(_path);</span>
  37 |     | <span class='unexecuted'>            bytes memory input = abi.encode(address(this), _amountIn, 0, route, true);</span>
  38 |     | <span class='unexecuted'>            bytes[] memory inputs = new bytes[](1);</span>
  39 |     | <span class='unexecuted'>            inputs[0] = input;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>            IVeloRouter(_router).execute(abi.encodePacked(V2_SWAP_EXACT_IN), inputs, block.timestamp);</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    // Swap along an encoded path using known amountIn</span>
  46 |     | <span class='neutral'>    //audit-info Only for V2 then ? </span>
  47 |     | <span class='neutral'>    function swap(</span>
  48 |     | <span class='neutral'>        address _router,</span>
  49 |     | <span class='neutral'>        IVeloRouter.Route[] memory _route,</span>
  50 |     | <span class='neutral'>        uint256 _amountIn</span>
  51 |     | <span class='neutral'>    ) internal {</span>
  52 |     | <span class='neutral'>        bytes memory input = abi.encode(address(this), _amountIn, 0, _route, true);</span>
  53 |     | <span class='neutral'>        bytes[] memory inputs = new bytes[](1);</span>
  54 |     | <span class='neutral'>        inputs[0] = input;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        IVeloRouter(_router).execute(abi.encodePacked(V2_SWAP_EXACT_IN), inputs, block.timestamp);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    // Swap along an encoded path using known amountIn</span>
  60 |     | <span class='neutral'>    //audit-info Swap on behalf of someone else ? </span>
  61 |     | <span class='neutral'>    function swap(</span>
  62 |     | <span class='neutral'>        address _who,</span>
  63 |     | <span class='neutral'>        address _router,</span>
  64 |     | <span class='neutral'>        bytes memory _path,</span>
  65 |     | <span class='neutral'>        uint256 _amountIn,</span>
  66 |     | <span class='neutral'>        bool _isV3</span>
  67 |     | <span class='neutral'>    ) internal {</span>
  68 |     | <span class='neutral'>        if (_isV3) {</span>
  69 |     | <span class='neutral'>            bytes memory input = abi.encode(_who, _amountIn, 0, _path, true);</span>
  70 |     | <span class='neutral'>            bytes[] memory inputs = new bytes[](1);</span>
  71 |     | <span class='neutral'>            inputs[0] = input;</span>
  72 |     | <span class='neutral'>            IVeloRouter(_router).execute(abi.encodePacked(V3_SWAP_EXACT_IN), inputs, block.timestamp);</span>
  73 |     | <span class='neutral'>        } else {</span>
  74 |     | <span class='neutral'>            address[] memory route = pathToRoute(_path);</span>
  75 |     | <span class='neutral'>            bytes memory input = abi.encode(_who, _amountIn, 0, route, true);</span>
  76 |     | <span class='neutral'>            bytes[] memory inputs = new bytes[](1);</span>
  77 |     | <span class='neutral'>            inputs[0] = input;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>            IVeloRouter(_router).execute(abi.encodePacked(V2_SWAP_EXACT_IN), inputs, block.timestamp);</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    // Convert encoded path to token route</span>
  84 |     | <span class='unexecuted'>    function pathToRoute(bytes memory _path) internal pure returns (address[] memory) {</span>
  85 |     | <span class='unexecuted'>        uint256 numPools = _path.numPools();</span>
  86 |     | <span class='unexecuted'>        address[] memory route = new address[](numPools + 1);</span>
  87 |     | <span class='unexecuted'>        for (uint256 i; i &lt; numPools; i++) {</span>
  88 |     | <span class='unexecuted'>            (address tokenA, address tokenB,) = _path.decodeFirstPool();</span>
  89 |     | <span class='unexecuted'>            route[i] = tokenA;</span>
  90 |     | <span class='unexecuted'>            route[i + 1] = tokenB;</span>
  91 |     | <span class='unexecuted'>            _path = _path.skipToken();</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='unexecuted'>        return route;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    // Convert token route to encoded path</span>
  97 |     | <span class='neutral'>    // uint24 type for fees so path is packed tightly</span>
  98 |     | <span class='neutral'>    function routeToPath(</span>
  99 |     | <span class='neutral'>        address[] memory _route,</span>
 100 |     | <span class='neutral'>        uint24[] memory _fee</span>
 101 |     | <span class='neutral'>    ) internal pure returns (bytes memory path) {</span>
 102 |     | <span class='neutral'>        path = abi.encodePacked(_route[0]);</span>
 103 |     | <span class='neutral'>        uint256 feeLength = _fee.length;</span>
 104 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; feeLength; i++) {</span>
 105 |     | <span class='neutral'>            path = abi.encodePacked(path, _fee[i], _route[i+1]);</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'>}</span>
 109 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/vault/BeefyVaultConcLiq.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20Metadata} from &quot;@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ERC20Upgradeable, IERC20Upgradeable} from &quot;@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {SafeERC20Upgradeable} from &quot;@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {OwnableUpgradeable} from &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ReentrancyGuardUpgradeable} from &quot;@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IStrategyConcLiq} from &quot;../interfaces/beefy/IStrategyConcLiq.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Implementation of a vault to deposit funds for yield optimizing.</span>
  13 |     | <span class='neutral'> * This is the contract that receives funds and that users interface with.</span>
  14 |     | <span class='neutral'> * The yield optimizing strategy itself is implemented in a separate &#39;Strategy.sol&#39; contract.</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='unexecuted'>contract BeefyVaultConcLiq is ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {</span>
  17 |     | <span class='neutral'>    using SafeERC20Upgradeable for IERC20Upgradeable;</span>
  18 |     | <span class='neutral'>    </span>
  19 |     | <span class='neutral'>    /// @notice The strategy currently in use by the vault.</span>
  20 |     | <span class='unexecuted'>    IStrategyConcLiq public strategy;</span>
  21 |     | <span class='neutral'>   </span>
  22 |     | <span class='neutral'>    /// @notice The initial shares that are burned as part of the first vault deposit. </span>
  23 |     | <span class='unexecuted'>    uint256 private constant MINIMUM_SHARES = 10**3;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @notice The precision used to calculate the shares.</span>
  26 |     | <span class='unexecuted'>    uint256 private constant PRECISION = 1e36;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @notice The address we are sending the burned shares to.</span>
  29 |     | <span class='unexecuted'>    address private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // Errors</span>
  32 |     | <span class='neutral'>    error NoShares();</span>
  33 |     | <span class='neutral'>    error TooMuchSlippage();</span>
  34 |     | <span class='neutral'>    error NotEnoughTokens();</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // Events </span>
  37 |     | <span class='neutral'>    event Deposit(address indexed user, uint256 shares, uint256 amount0, uint256 amount1);</span>
  38 |     | <span class='neutral'>    event Withdraw(address indexed user, uint256 shares, uint256 amount0, uint256 amount1);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @custom:oz-upgrades-unsafe-allow constructor</span>
  41 |     | <span class='unexecuted'>    constructor() {</span>
  42 |     | <span class='unexecuted'>        _disableInitializers();</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @notice Initializes the vault, sets the strategy name and creates a new token.</span>
  47 |     | <span class='neutral'>     * @param _strategy the address of the strategy.</span>
  48 |     | <span class='neutral'>     * @param _name the name of the vault token.</span>
  49 |     | <span class='neutral'>     * @param _symbol the symbol of the vault token.</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='unexecuted'>     function initialize(</span>
  52 |     | <span class='neutral'>        address _strategy,</span>
  53 |     | <span class='neutral'>        string calldata _name,</span>
  54 |     | <span class='neutral'>        string calldata _symbol</span>
  55 |     | <span class='neutral'>    ) external initializer {</span>
  56 |     | <span class='unexecuted'>        __ERC20_init(_name, _symbol);</span>
  57 |     | <span class='unexecuted'>        __Ownable_init();</span>
  58 |     | <span class='unexecuted'>        __ReentrancyGuard_init();</span>
  59 |     | <span class='unexecuted'>        strategy = IStrategyConcLiq(_strategy);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /** </span>
  63 |     | <span class='neutral'>     * @notice returns whether the pool is calm for deposits</span>
  64 |     | <span class='neutral'>     * @return boolean true if the pool is calm </span>
  65 |     | <span class='neutral'>    */</span>
  66 |     | <span class='unexecuted'>    function isCalm() external view returns (bool) {</span>
  67 |     | <span class='unexecuted'>        return strategy.isCalm();</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /** </span>
  71 |     | <span class='neutral'>     * @notice returns the concentrated liquidity pool address</span>
  72 |     | <span class='neutral'>     * @return _want the address of the concentrated liquidity pool</span>
  73 |     | <span class='neutral'>    */</span>
  74 |     | <span class='unexecuted'>    function want() external view returns (address _want) {</span>
  75 |     | <span class='unexecuted'>        return strategy.pool();</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /** @notice returns the tokens that the strategy wants</span>
  79 |     | <span class='neutral'>     * @return token0 the address of the first token</span>
  80 |     | <span class='neutral'>     * @return token1 the address of the second token</span>
  81 |     | <span class='neutral'>    */</span>
  82 |     | <span class='unexecuted'>    function wants() public view returns (address token0, address token1) {</span>
  83 |     | <span class='unexecuted'>        token0 = strategy.lpToken0();</span>
  84 |     | <span class='unexecuted'>        token1 = strategy.lpToken1();</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @notice It calculates the total underlying value of {tokens} held by the system.</span>
  89 |     | <span class='neutral'>     * It takes into account the vault contract balance, the strategy contract balance</span>
  90 |     | <span class='neutral'>     *  and the balance deployed in other contracts as part of the strategy.</span>
  91 |     | <span class='neutral'>     * @return amount0 the amount of token0</span>
  92 |     | <span class='neutral'>     * @return amount1 the amount of token1</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function balances() public view returns (uint amount0, uint amount1) {</span>
  95 |     | <span class='unexecuted'>        (amount0, amount1) = IStrategyConcLiq(strategy).balances();</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @notice Returns the amount of token0 and token1 that a number of shares represents.</span>
 100 |     | <span class='neutral'>     * @param _shares the number of shares to convert to tokens.</span>
 101 |     | <span class='neutral'>     * @return amount0 the amount of token0 a user will recieve for the shares.</span>
 102 |     | <span class='neutral'>     * @return amount1 the amount of token1 a user will recieve for the shares.</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='unexecuted'>    function previewWithdraw(uint256 _shares) external view returns (uint256 amount0, uint256 amount1) {</span>
 105 |     | <span class='unexecuted'>        (uint bal0, uint bal1) = balances();</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        uint256 _totalSupply = totalSupply();</span>
 108 |     | <span class='unexecuted'>        amount0 = (bal0 * _shares) / _totalSupply;</span>
 109 |     | <span class='unexecuted'>        amount1 = (bal1 * _shares) / _totalSupply;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>      /**</span>
 113 |     | <span class='neutral'>     * @notice Get a expected shares amount for token deposits. </span>
 114 |     | <span class='neutral'>     * @param _amount0 the amount of token0 to deposit.</span>
 115 |     | <span class='neutral'>     * @param _amount1 the amount of token1 to deposit.</span>
 116 |     | <span class='neutral'>     * @return shares amount of shares that the deposit will represent.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='unexecuted'>    function previewDeposit(uint256 _amount0, uint256 _amount1) external view returns (uint256 shares, uint256 amount0, uint256 amount1) {</span>
 119 |     | <span class='unexecuted'>        uint256 price = strategy.price();</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        (uint bal0, uint bal1) = balances();</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        (amount0, amount1) = _getTokensRequired(price, _amount0, _amount1, bal0, bal1);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        uint256 _totalSupply = totalSupply();</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        if (_totalSupply == 0) {</span>
 128 |     | <span class='unexecuted'>            bal0 = _amount0;</span>
 129 |     | <span class='unexecuted'>            bal1 = _amount1;</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        shares = amount1 + (amount0 * price / PRECISION); </span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        if (_totalSupply &gt; 0) {</span>
 135 |     | <span class='neutral'>            // How much of wants() do we have in token 1 equivalents;</span>
 136 |     | <span class='unexecuted'>            uint256 token1EquivalentBalance = (((bal0 * price) + PRECISION - 1) / PRECISION) + bal1;</span>
 137 |     | <span class='unexecuted'>            shares = shares * _totalSupply / token1EquivalentBalance;</span>
 138 |     | <span class='neutral'>        } else {</span>
 139 |     | <span class='neutral'>            // First user donates MINIMUM_SHARES for security of the vault. </span>
 140 |     | <span class='unexecuted'>            shares =  shares - MINIMUM_SHARES;</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @notice Get the amount of tokens required to deposit to reach the desired balance of the strategy.</span>
 145 |     | <span class='unexecuted'>    function _getTokensRequired(uint256 _price, uint256 _amount0, uint256 _amount1, uint256 _bal0, uint256 _bal1) private pure returns (uint256 depositAmount0, uint256 depositAmount1) {</span>
 146 |     | <span class='neutral'>        // get the amount of bal0 that is equivalent to bal1</span>
 147 |     | <span class='unexecuted'>        if (_bal0 == 0 &amp;&amp; _bal1 == 0) return (_amount0, _amount1);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>        uint256 bal0InBal1 = (_bal0 * _price) / PRECISION;</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>        // check which side is lower and supply as much as possible</span>
 152 |     | <span class='unexecuted'>        if (_bal1 &lt; bal0InBal1) {</span>
 153 |     | <span class='unexecuted'>            uint256 finalBalanceForAmount1 = _bal1 + _amount1;</span>
 154 |     | <span class='unexecuted'>            uint256 owedAmount0 = finalBalanceForAmount1 &gt; bal0InBal1 </span>
 155 |     | <span class='unexecuted'>                ? (finalBalanceForAmount1 - bal0InBal1) * PRECISION / _price </span>
 156 |     | <span class='unexecuted'>                : 0;</span>
 157 |     | <span class='unexecuted'>            if (owedAmount0 &gt; _amount0) {</span>
 158 |     | <span class='unexecuted'>                depositAmount0 = _amount0;</span>
 159 |     | <span class='unexecuted'>                depositAmount1 = _amount1 - ( (owedAmount0 - _amount0) * _price / PRECISION );</span>
 160 |     | <span class='neutral'>            } else {</span>
 161 |     | <span class='unexecuted'>                depositAmount0 = owedAmount0;</span>
 162 |     | <span class='unexecuted'>                depositAmount1 = _amount1;</span>
 163 |     | <span class='neutral'>            }</span>
 164 |     | <span class='unexecuted'>        } else {</span>
 165 |     | <span class='unexecuted'>            uint256 finalBalanceForAmount0 = bal0InBal1 + ( _amount0 * _price / PRECISION );</span>
 166 |     | <span class='unexecuted'>            uint256 owedAmount1 = finalBalanceForAmount0 &gt; _bal1 </span>
 167 |     | <span class='unexecuted'>                ? finalBalanceForAmount0 - _bal1</span>
 168 |     | <span class='unexecuted'>                : 0;</span>
 169 |     | <span class='unexecuted'>            if (owedAmount1 &gt; _amount1) {</span>
 170 |     | <span class='unexecuted'>                depositAmount0 = _amount0 - ( (owedAmount1 - _amount1) * PRECISION / _price );</span>
 171 |     | <span class='unexecuted'>                depositAmount1 = _amount1;</span>
 172 |     | <span class='neutral'>            } else {</span>
 173 |     | <span class='unexecuted'>                depositAmount0 = _amount0;</span>
 174 |     | <span class='unexecuted'>                depositAmount1 = owedAmount1;</span>
 175 |     | <span class='neutral'>            }</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /**</span>
 180 |     | <span class='neutral'>     * @notice The entrypoint of funds into the system. People deposit with this function</span>
 181 |     | <span class='neutral'>     * into the vault. The vault is then in charge of sending funds into the strategy.</span>
 182 |     | <span class='neutral'>     * @dev Use previewDeposit to find the proper ratio to deposit into the vault. </span>
 183 |     | <span class='neutral'>     * @param _amount0 the amount of token0 to deposit.</span>
 184 |     | <span class='neutral'>     * @param _amount1 the amount of token1 to deposit.</span>
 185 |     | <span class='neutral'>     * @param _minShares the minimum amount of shares that the user wants to recieve with slippage.</span>
 186 |     | <span class='neutral'>     */</span>
 187 |     | <span class='unexecuted'>    function deposit(uint256 _amount0, uint256 _amount1, uint256 _minShares) public nonReentrant {</span>
 188 |     | <span class='unexecuted'>        (address token0, address token1) = wants();</span>
 189 |     | <span class='neutral'>        </span>
 190 |     | <span class='neutral'>        // Have the strategy remove all liquidity from the pool.</span>
 191 |     | <span class='unexecuted'>        strategy.beforeAction();</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>        /// @dev Do not allow deposits of inflationary tokens.</span>
 194 |     | <span class='neutral'>        // Transfer funds from user and send to strategy.</span>
 195 |     | <span class='unexecuted'>        (uint256 _bal0, uint256 _bal1) = balances();</span>
 196 |     | <span class='unexecuted'>        uint256 price = strategy.price();</span>
 197 |     | <span class='unexecuted'>        (uint256 amount0, uint256 amount1) = _getTokensRequired(price, _amount0, _amount1, _bal0, _bal1);</span>
 198 |     | <span class='unexecuted'>        if (amount0 &gt; _amount0 || amount1 &gt; _amount1) revert NotEnoughTokens();</span>
 199 |     | <span class='neutral'>        </span>
 200 |     | <span class='unexecuted'>        if (amount0 &gt; 0) IERC20Upgradeable(token0).safeTransferFrom(msg.sender, address(strategy), amount0);</span>
 201 |     | <span class='unexecuted'>        if (amount1 &gt; 0) IERC20Upgradeable(token1).safeTransferFrom(msg.sender, address(strategy), amount1);</span>
 202 |     | <span class='unexecuted'>        (uint256 _after0, uint256 _after1) = balances();</span>
 203 |     | <span class='unexecuted'>        strategy.deposit();</span>
 204 |     | <span class='neutral'>        </span>
 205 |     | <span class='unexecuted'>        amount0 = _after0 - _bal0;</span>
 206 |     | <span class='unexecuted'>        amount1 = _after1 - _bal1;</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        uint256 shares = amount1 + (amount0 * price / PRECISION);</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        uint256 _totalSupply = totalSupply();</span>
 211 |     | <span class='unexecuted'>        if (_totalSupply &gt; 0) {</span>
 212 |     | <span class='neutral'>            // How much of wants() do we have in token 1 equivalents;</span>
 213 |     | <span class='unexecuted'>            uint256 token1EquivalentBalance = (((_bal0 * price) + PRECISION - 1) / PRECISION) + _bal1;</span>
 214 |     | <span class='unexecuted'>            shares = shares * _totalSupply / token1EquivalentBalance;</span>
 215 |     | <span class='neutral'>        } else {</span>
 216 |     | <span class='neutral'>            // First user donates MINIMUM_SHARES for security of the vault. </span>
 217 |     | <span class='unexecuted'>            shares =  shares - MINIMUM_SHARES;</span>
 218 |     | <span class='unexecuted'>            _mint(BURN_ADDRESS, MINIMUM_SHARES); // permanently lock the first MINIMUM_SHARES</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>        if (shares &lt; _minShares) revert TooMuchSlippage();</span>
 222 |     | <span class='unexecuted'>        if (shares == 0) revert NoShares();</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='unexecuted'>        _mint(msg.sender, shares);</span>
 225 |     | <span class='unexecuted'>        emit Deposit(msg.sender, shares, amount0, amount1);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    /**</span>
 229 |     | <span class='neutral'>     * @dev A helper function to call withdraw() with all the sender&#39;s funds.</span>
 230 |     | <span class='neutral'>     * @param _minAmount0 the minimum amount of token0 that the user wants to recieve with slippage.</span>
 231 |     | <span class='neutral'>     * @param _minAmount1 the minimum amount of token1 that the user wants to recieve with slippage.</span>
 232 |     | <span class='neutral'>     */</span>
 233 |     | <span class='unexecuted'>    function withdrawAll(uint256 _minAmount0, uint256 _minAmount1) external {</span>
 234 |     | <span class='unexecuted'>        withdraw(balanceOf(msg.sender), _minAmount0, _minAmount1);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @notice Function to exit the system. The vault will withdraw the required tokens</span>
 239 |     | <span class='neutral'>     * from the strategy and pay up the token holder. A proportional number of IOU</span>
 240 |     | <span class='neutral'>     * tokens are burned in the process.</span>
 241 |     | <span class='neutral'>     * @param _shares the number of shares to withdraw.</span>
 242 |     | <span class='neutral'>     * @param _minAmount0 the minimum amount of token0 that the user wants to recieve with slippage.</span>
 243 |     | <span class='neutral'>     * @param _minAmount1 the minimum amount of token1 that the user wants to recieve with slippage.</span>
 244 |     | <span class='neutral'>     */</span>
 245 |     | <span class='unexecuted'>    function withdraw(uint256 _shares, uint256 _minAmount0, uint256 _minAmount1) public {</span>
 246 |     | <span class='unexecuted'>        if (_shares == 0) revert NoShares();</span>
 247 |     | <span class='neutral'>        </span>
 248 |     | <span class='neutral'>        // Withdraw All Liquidity to Strat for Accounting.</span>
 249 |     | <span class='unexecuted'>        strategy.beforeAction();</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>        uint256 _totalSupply = totalSupply();</span>
 252 |     | <span class='unexecuted'>        _burn(msg.sender, _shares);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='unexecuted'>        (uint256 _bal0, uint256 _bal1) = balances();</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>        uint256 _amount0 = (_bal0 * _shares) / _totalSupply;</span>
 257 |     | <span class='unexecuted'>        uint256 _amount1 = (_bal1 * _shares) / _totalSupply;</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>        strategy.withdraw(_amount0, _amount1);</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='unexecuted'>        if (</span>
 262 |     | <span class='unexecuted'>            _amount0 &lt; _minAmount0 || </span>
 263 |     | <span class='unexecuted'>            _amount1 &lt; _minAmount1 ||</span>
 264 |     | <span class='unexecuted'>            (_amount0 == 0 &amp;&amp; _amount1 == 0)</span>
 265 |     | <span class='unexecuted'>        ) revert TooMuchSlippage();</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>        (address token0, address token1) = wants();</span>
 268 |     | <span class='unexecuted'>        IERC20Upgradeable(token0).safeTransfer(msg.sender, _amount0);</span>
 269 |     | <span class='unexecuted'>        IERC20Upgradeable(token1).safeTransfer(msg.sender, _amount1);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='unexecuted'>        emit Withdraw(msg.sender, _shares, _amount0, _amount1);</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    /**</span>
 275 |     | <span class='neutral'>     * @dev Rescues random funds stuck that the strat can&#39;t handle.</span>
 276 |     | <span class='neutral'>     * @param _token address of the token to rescue.</span>
 277 |     | <span class='neutral'>     */</span>
 278 |     | <span class='unexecuted'>    function inCaseTokensGetStuck(address _token) external onlyOwner {</span>
 279 |     | <span class='unexecuted'>        uint256 amount = IERC20Upgradeable(_token).balanceOf(address(this));</span>
 280 |     | <span class='unexecuted'>        IERC20Upgradeable(_token).safeTransfer(msg.sender, amount);</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/contracts/vault/BeefyVaultConcLiqFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.23;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BeefyVaultConcLiq} from &quot;./BeefyVaultConcLiq.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ClonesUpgradeable} from &quot;@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// Beefy Finance Vault ConcLiq Proxy Factory</span>
  8 |     | <span class='neutral'>// Minimal proxy pattern for creating new Beefy concentrated liquidity vaults</span>
  9 | *   | <span class='executed'>contract BeefyVaultConcLiqFactory {</span>
 10 |     | <span class='neutral'>  using ClonesUpgradeable for address;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  /// @notice Contract template for deploying proxied Beefy vaults</span>
 13 | *   | <span class='executed'>  BeefyVaultConcLiq public instance;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>  /// @notice Emitted when a new Beefy Vault is created</span>
 16 |     | <span class='neutral'>  event ProxyCreated(address proxy);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>  /** </span>
 19 |     | <span class='neutral'>   * @notice Constructor initializes the Beefy Vault template instance</span>
 20 |     | <span class='neutral'>   * @param _instance The address of the Beefy Vault template instance</span>
 21 |     | <span class='neutral'>   */</span>
 22 |     | <span class='unexecuted'>  constructor(address _instance) {</span>
 23 |     | <span class='unexecuted'>    if (_instance == address(0)) {</span>
 24 |     | <span class='unexecuted'>      instance = new BeefyVaultConcLiq();</span>
 25 |     | <span class='neutral'>    } else {</span>
 26 |     | <span class='unexecuted'>      instance = BeefyVaultConcLiq(_instance);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>  }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>  /**</span>
 31 |     | <span class='neutral'>   * @notice Create a new Beefy Conc Liq Vault as a proxy of the template instance</span>
 32 |     | <span class='neutral'>   * @return A reference to the new proxied Beefy Vault</span>
 33 |     | <span class='neutral'>   */</span>
 34 | *   | <span class='executed'>  function cloneVault(</span>
 35 | *   | <span class='executed'>  ) external returns (BeefyVaultConcLiq) {</span>
 36 | *   | <span class='executed'>    BeefyVaultConcLiq vault = BeefyVaultConcLiq(_cloneContract(address(instance)));</span>
 37 |     | <span class='neutral'>    return vault;</span>
 38 |     | <span class='neutral'>  }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>  /**</span>
 41 |     | <span class='neutral'>   * Deploys and returns the address of a clone that mimics the behaviour of `implementation`</span>
 42 |     | <span class='neutral'>   * @param implementation The address of the contract to clone</span>
 43 |     | <span class='neutral'>   * @return The address of the newly created clone</span>
 44 |     | <span class='neutral'>  */</span>
 45 | *   | <span class='executed'>  function _cloneContract(address implementation) private returns (address) {</span>
 46 | *   | <span class='executed'>    address proxy = implementation.clone();</span>
 47 | *   | <span class='executed'>    emit ProxyCreated(proxy);</span>
 48 | *   | <span class='executed'>    return proxy;</span>
 49 |     | <span class='neutral'>  }</span>
 50 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/access/Ownable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Context} from &quot;../utils/Context.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
  10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
  11 |     | <span class='neutral'> * specific functions.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The initial owner is set to the address provided by the deployer. This can</span>
  14 |     | <span class='neutral'> * later be changed with {transferOwnership}.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
  17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
  18 |     | <span class='neutral'> * the owner.</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
  21 |     | <span class='neutral'>    address private _owner;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev The caller account is not authorized to perform an operation.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    error OwnableUnauthorizedAccount(address account);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /**</span>
  29 |     | <span class='neutral'>     * @dev The owner is not a valid owner account. (eg. `address(0)`)</span>
  30 |     | <span class='neutral'>     */</span>
  31 |     | <span class='neutral'>    error OwnableInvalidOwner(address owner);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.</span>
  37 |     | <span class='neutral'>     */</span>
  38 |     | <span class='neutral'>    constructor(address initialOwner) {</span>
  39 |     | <span class='neutral'>        if (initialOwner == address(0)) {</span>
  40 |     | <span class='neutral'>            revert OwnableInvalidOwner(address(0));</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>        _transferOwnership(initialOwner);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  49 |     | <span class='neutral'>        _checkOwner();</span>
  50 |     | <span class='neutral'>        _;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    function owner() public view virtual returns (address) {</span>
  57 |     | <span class='neutral'>        return _owner;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    function _checkOwner() internal view virtual {</span>
  64 |     | <span class='neutral'>        if (owner() != _msgSender()) {</span>
  65 |     | <span class='neutral'>            revert OwnableUnauthorizedAccount(_msgSender());</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
  71 |     | <span class='neutral'>     * `onlyOwner` functions. Can only be called by the current owner.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
  74 |     | <span class='neutral'>     * thereby disabling any functionality that is only available to the owner.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function renounceOwnership() public virtual onlyOwner {</span>
  77 |     | <span class='neutral'>        _transferOwnership(address(0));</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  82 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
  85 |     | <span class='neutral'>        if (newOwner == address(0)) {</span>
  86 |     | <span class='neutral'>            revert OwnableInvalidOwner(address(0));</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'>        _transferOwnership(newOwner);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  93 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function _transferOwnership(address newOwner) internal virtual {</span>
  96 |     | <span class='neutral'>        address oldOwner = _owner;</span>
  97 |     | <span class='neutral'>        _owner = newOwner;</span>
  98 |     | <span class='neutral'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'>}</span>
 101 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)</span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>/**</span>
   6 |     | <span class='neutral'> * @dev Standard ERC20 Errors</span>
   7 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IERC20Errors {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.</span>
  12 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  13 |     | <span class='neutral'>     * @param balance Current balance for the interacting account.</span>
  14 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
  20 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    error ERC20InvalidSender(address sender);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
  26 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    error ERC20InvalidReceiver(address receiver);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.</span>
  32 |     | <span class='neutral'>     * @param spender Address that may be allowed to operate on tokens without being their owner.</span>
  33 |     | <span class='neutral'>     * @param allowance Amount of tokens a `spender` is allowed to operate with.</span>
  34 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
  40 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    error ERC20InvalidApprover(address approver);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.</span>
  46 |     | <span class='neutral'>     * @param spender Address that may be allowed to operate on tokens without being their owner.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    error ERC20InvalidSpender(address spender);</span>
  49 |     | <span class='neutral'>}</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>/**</span>
  52 |     | <span class='neutral'> * @dev Standard ERC721 Errors</span>
  53 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.</span>
  54 |     | <span class='neutral'> */</span>
  55 |     | <span class='neutral'>interface IERC721Errors {</span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Indicates that an address can&#39;t be an owner. For example, `address(0)` is a forbidden owner in EIP-20.</span>
  58 |     | <span class='neutral'>     * Used in balance queries.</span>
  59 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    error ERC721InvalidOwner(address owner);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Indicates a `tokenId` whose `owner` is the zero address.</span>
  65 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='neutral'>    error ERC721NonexistentToken(uint256 tokenId);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.</span>
  71 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  72 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  73 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
  79 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    error ERC721InvalidSender(address sender);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
  85 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    error ERC721InvalidReceiver(address receiver);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator`s approval. Used in transfers.</span>
  91 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
  92 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='neutral'>    error ERC721InsufficientApproval(address operator, uint256 tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
  98 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
  99 |     | <span class='neutral'>     */</span>
 100 |     | <span class='neutral'>    error ERC721InvalidApprover(address approver);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.</span>
 104 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    error ERC721InvalidOperator(address operator);</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>/**</span>
 110 |     | <span class='neutral'> * @dev Standard ERC1155 Errors</span>
 111 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.</span>
 112 |     | <span class='neutral'> */</span>
 113 |     | <span class='neutral'>interface IERC1155Errors {</span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.</span>
 116 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
 117 |     | <span class='neutral'>     * @param balance Current balance for the interacting account.</span>
 118 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
 119 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
 125 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='neutral'>    error ERC1155InvalidSender(address sender);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
 131 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
 132 |     | <span class='neutral'>     */</span>
 133 |     | <span class='neutral'>    error ERC1155InvalidReceiver(address receiver);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator`s approval. Used in transfers.</span>
 137 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 138 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    error ERC1155MissingApprovalForAll(address operator, address owner);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
 144 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
 145 |     | <span class='neutral'>     */</span>
 146 |     | <span class='neutral'>    error ERC1155InvalidApprover(address approver);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.</span>
 150 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    error ERC1155InvalidOperator(address operator);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /**</span>
 155 |     | <span class='neutral'>     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.</span>
 156 |     | <span class='neutral'>     * Used in batch transfers.</span>
 157 |     | <span class='neutral'>     * @param idsLength Length of the array of token identifiers</span>
 158 |     | <span class='neutral'>     * @param valuesLength Length of the array of token amounts</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);</span>
 161 |     | <span class='neutral'>}</span>
 162 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20Metadata} from &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Context} from &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IERC20Errors} from &quot;../../interfaces/draft-IERC6093.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  15 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='neutral'>abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {</span>
  35 |     | <span class='neutral'>    mapping(address account =&gt; uint256) private _balances;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    string private _name;</span>
  42 |     | <span class='neutral'>    string private _symbol;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  46 |     | <span class='neutral'>     *</span>
  47 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  48 |     | <span class='neutral'>     * construction.</span>
  49 |     | <span class='neutral'>     */</span>
  50 |     | <span class='neutral'>    constructor(string memory name_, string memory symbol_) {</span>
  51 |     | <span class='neutral'>        _name = name_;</span>
  52 |     | <span class='neutral'>        _symbol = symbol_;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    function name() public view virtual returns (string memory) {</span>
  59 |     | <span class='neutral'>        return _name;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  64 |     | <span class='neutral'>     * name.</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    function symbol() public view virtual returns (string memory) {</span>
  67 |     | <span class='neutral'>        return _symbol;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  72 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  73 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  76 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  77 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  80 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  81 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    function decimals() public view virtual returns (uint8) {</span>
  84 |     | <span class='neutral'>        return 18;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function totalSupply() public view virtual returns (uint256) {</span>
  91 |     | <span class='neutral'>        return _totalSupply;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function balanceOf(address account) public view virtual returns (uint256) {</span>
  98 |     | <span class='neutral'>        return _balances[account];</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * Requirements:</span>
 105 |     | <span class='neutral'>     *</span>
 106 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 107 |     | <span class='neutral'>     * - the caller must have a balance of at least `value`.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    function transfer(address to, uint256 value) public virtual returns (bool) {</span>
 110 |     | <span class='neutral'>        address owner = _msgSender();</span>
 111 |     | <span class='neutral'>        _transfer(owner, to, value);</span>
 112 |     | <span class='neutral'>        return true;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /**</span>
 116 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function allowance(address owner, address spender) public view virtual returns (uint256) {</span>
 119 |     | <span class='neutral'>        return _allowances[owner][spender];</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 124 |     | <span class='neutral'>     *</span>
 125 |     | <span class='neutral'>     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on</span>
 126 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 127 |     | <span class='neutral'>     *</span>
 128 |     | <span class='neutral'>     * Requirements:</span>
 129 |     | <span class='neutral'>     *</span>
 130 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    function approve(address spender, uint256 value) public virtual returns (bool) {</span>
 133 |     | <span class='neutral'>        address owner = _msgSender();</span>
 134 |     | <span class='neutral'>        _approve(owner, spender, value);</span>
 135 |     | <span class='neutral'>        return true;</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    /**</span>
 139 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 140 |     | <span class='neutral'>     *</span>
 141 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 142 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 143 |     | <span class='neutral'>     *</span>
 144 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 145 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 146 |     | <span class='neutral'>     *</span>
 147 |     | <span class='neutral'>     * Requirements:</span>
 148 |     | <span class='neutral'>     *</span>
 149 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 150 |     | <span class='neutral'>     * - `from` must have a balance of at least `value`.</span>
 151 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 152 |     | <span class='neutral'>     * `value`.</span>
 153 |     | <span class='neutral'>     */</span>
 154 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {</span>
 155 |     | <span class='neutral'>        address spender = _msgSender();</span>
 156 |     | <span class='neutral'>        _spendAllowance(from, spender, value);</span>
 157 |     | <span class='neutral'>        _transfer(from, to, value);</span>
 158 |     | <span class='neutral'>        return true;</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to`.</span>
 163 |     | <span class='neutral'>     *</span>
 164 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 165 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 166 |     | <span class='neutral'>     *</span>
 167 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 168 |     | <span class='neutral'>     *</span>
 169 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 170 |     | <span class='neutral'>     */</span>
 171 |     | <span class='neutral'>    function _transfer(address from, address to, uint256 value) internal {</span>
 172 |     | <span class='neutral'>        if (from == address(0)) {</span>
 173 |     | <span class='neutral'>            revert ERC20InvalidSender(address(0));</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>        if (to == address(0)) {</span>
 176 |     | <span class='neutral'>            revert ERC20InvalidReceiver(address(0));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        _update(from, to, value);</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    /**</span>
 182 |     | <span class='neutral'>     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`</span>
 183 |     | <span class='neutral'>     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding</span>
 184 |     | <span class='neutral'>     * this function.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 187 |     | <span class='neutral'>     */</span>
 188 |     | <span class='neutral'>    function _update(address from, address to, uint256 value) internal virtual {</span>
 189 |     | <span class='neutral'>        if (from == address(0)) {</span>
 190 |     | <span class='neutral'>            // Overflow check required: The rest of the code assumes that totalSupply never overflows</span>
 191 |     | <span class='neutral'>            _totalSupply += value;</span>
 192 |     | <span class='neutral'>        } else {</span>
 193 |     | <span class='neutral'>            uint256 fromBalance = _balances[from];</span>
 194 |     | <span class='neutral'>            if (fromBalance &lt; value) {</span>
 195 |     | <span class='neutral'>                revert ERC20InsufficientBalance(from, fromBalance, value);</span>
 196 |     | <span class='neutral'>            }</span>
 197 |     | <span class='neutral'>            unchecked {</span>
 198 |     | <span class='neutral'>                // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span>
 199 |     | <span class='neutral'>                _balances[from] = fromBalance - value;</span>
 200 |     | <span class='neutral'>            }</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        if (to == address(0)) {</span>
 204 |     | <span class='neutral'>            unchecked {</span>
 205 |     | <span class='neutral'>                // Overflow not possible: value &lt;= totalSupply or value &lt;= fromBalance &lt;= totalSupply.</span>
 206 |     | <span class='neutral'>                _totalSupply -= value;</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='neutral'>            unchecked {</span>
 210 |     | <span class='neutral'>                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.</span>
 211 |     | <span class='neutral'>                _balances[to] += value;</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        emit Transfer(from, to, value);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    /**</span>
 219 |     | <span class='neutral'>     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).</span>
 220 |     | <span class='neutral'>     * Relies on the `_update` mechanism</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 223 |     | <span class='neutral'>     *</span>
 224 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 225 |     | <span class='neutral'>     */</span>
 226 |     | <span class='neutral'>    function _mint(address account, uint256 value) internal {</span>
 227 |     | <span class='neutral'>        if (account == address(0)) {</span>
 228 |     | <span class='neutral'>            revert ERC20InvalidReceiver(address(0));</span>
 229 |     | <span class='neutral'>        }</span>
 230 |     | <span class='neutral'>        _update(address(0), account, value);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    /**</span>
 234 |     | <span class='neutral'>     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.</span>
 235 |     | <span class='neutral'>     * Relies on the `_update` mechanism.</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 238 |     | <span class='neutral'>     *</span>
 239 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='neutral'>    function _burn(address account, uint256 value) internal {</span>
 242 |     | <span class='neutral'>        if (account == address(0)) {</span>
 243 |     | <span class='neutral'>            revert ERC20InvalidSender(address(0));</span>
 244 |     | <span class='neutral'>        }</span>
 245 |     | <span class='neutral'>        _update(account, address(0), value);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 252 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 253 |     | <span class='neutral'>     *</span>
 254 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 255 |     | <span class='neutral'>     *</span>
 256 |     | <span class='neutral'>     * Requirements:</span>
 257 |     | <span class='neutral'>     *</span>
 258 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 259 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 260 |     | <span class='neutral'>     *</span>
 261 |     | <span class='neutral'>     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.</span>
 262 |     | <span class='neutral'>     */</span>
 263 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value) internal {</span>
 264 |     | <span class='neutral'>        _approve(owner, spender, value, true);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    /**</span>
 268 |     | <span class='neutral'>     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by</span>
 271 |     | <span class='neutral'>     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any</span>
 272 |     | <span class='neutral'>     * `Approval` event during `transferFrom` operations.</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to</span>
 275 |     | <span class='neutral'>     * true using the following override:</span>
 276 |     | <span class='neutral'>     * ```</span>
 277 |     | <span class='neutral'>     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {</span>
 278 |     | <span class='neutral'>     *     super._approve(owner, spender, value, true);</span>
 279 |     | <span class='neutral'>     * }</span>
 280 |     | <span class='neutral'>     * ```</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * Requirements are the same as {_approve}.</span>
 283 |     | <span class='neutral'>     */</span>
 284 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {</span>
 285 |     | <span class='neutral'>        if (owner == address(0)) {</span>
 286 |     | <span class='neutral'>            revert ERC20InvalidApprover(address(0));</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'>        if (spender == address(0)) {</span>
 289 |     | <span class='neutral'>            revert ERC20InvalidSpender(address(0));</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>        _allowances[owner][spender] = value;</span>
 292 |     | <span class='neutral'>        if (emitEvent) {</span>
 293 |     | <span class='neutral'>            emit Approval(owner, spender, value);</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `value`.</span>
 299 |     | <span class='neutral'>     *</span>
 300 |     | <span class='neutral'>     * Does not update the allowance value in case of infinite allowance.</span>
 301 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Does not emit an {Approval} event.</span>
 304 |     | <span class='neutral'>     */</span>
 305 |     | <span class='neutral'>    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {</span>
 306 |     | <span class='neutral'>        uint256 currentAllowance = allowance(owner, spender);</span>
 307 |     | <span class='neutral'>        if (currentAllowance != type(uint256).max) {</span>
 308 |     | <span class='neutral'>            if (currentAllowance &lt; value) {</span>
 309 |     | <span class='neutral'>                revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span>
 310 |     | <span class='neutral'>            }</span>
 311 |     | <span class='neutral'>            unchecked {</span>
 312 |     | <span class='neutral'>                _approve(owner, spender, currentAllowance - value, false);</span>
 313 |     | <span class='neutral'>            }</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'>}</span>
 317 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the value of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the value of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the</span>
 54 |     | <span class='neutral'>     * caller&#39;s tokens.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 59 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 60 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 61 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 62 |     | <span class='neutral'>     * desired value afterwards:</span>
 63 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 64 |     | <span class='neutral'>     *</span>
 65 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    /**</span>
 70 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to` using the</span>
 71 |     | <span class='neutral'>     * allowance mechanism. `value` is then deducted from the caller&#39;s</span>
 72 |     | <span class='neutral'>     * allowance.</span>
 73 |     | <span class='neutral'>     *</span>
 74 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 75 |     | <span class='neutral'>     *</span>
 76 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 |     | <span class='neutral'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 26 |     | <span class='neutral'>        return 0;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/lib/solmate/lib/ds-test/src/test.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
   4 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
   5 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
   6 |     | <span class='neutral'>// (at your option) any later version.</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
   9 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  10 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  11 |     | <span class='neutral'>// GNU General Public License for more details.</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
  14 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>contract DSTest {</span>
  19 |     | <span class='neutral'>    event log                    (string);</span>
  20 |     | <span class='neutral'>    event logs                   (bytes);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event log_address            (address);</span>
  23 |     | <span class='neutral'>    event log_bytes32            (bytes32);</span>
  24 |     | <span class='neutral'>    event log_int                (int);</span>
  25 |     | <span class='neutral'>    event log_uint               (uint);</span>
  26 |     | <span class='neutral'>    event log_bytes              (bytes);</span>
  27 |     | <span class='neutral'>    event log_string             (string);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_named_address      (string key, address val);</span>
  30 |     | <span class='neutral'>    event log_named_bytes32      (string key, bytes32 val);</span>
  31 |     | <span class='neutral'>    event log_named_decimal_int  (string key, int val, uint decimals);</span>
  32 |     | <span class='neutral'>    event log_named_decimal_uint (string key, uint val, uint decimals);</span>
  33 |     | <span class='neutral'>    event log_named_int          (string key, int val);</span>
  34 |     | <span class='neutral'>    event log_named_uint         (string key, uint val);</span>
  35 |     | <span class='neutral'>    event log_named_bytes        (string key, bytes val);</span>
  36 |     | <span class='neutral'>    event log_named_string       (string key, string val);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    bool public IS_TEST = true;</span>
  39 |     | <span class='neutral'>    bool private _failed;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    address constant HEVM_ADDRESS =</span>
  42 |     | <span class='unexecuted'>        address(bytes20(uint160(uint256(keccak256(&#39;hevm cheat code&#39;)))));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    modifier mayRevert() { _; }</span>
  45 |     | <span class='neutral'>    modifier testopts(string memory) { _; }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function failed() public returns (bool) {</span>
  48 |     | <span class='unexecuted'>        if (_failed) {</span>
  49 |     | <span class='unexecuted'>            return _failed;</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='unexecuted'>            bool globalFailed = false;</span>
  52 |     | <span class='unexecuted'>            if (hasHEVMContext()) {</span>
  53 |     | <span class='unexecuted'>                (, bytes memory retdata) = HEVM_ADDRESS.call(</span>
  54 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
  55 |     | <span class='unexecuted'>                        bytes4(keccak256(&quot;load(address,bytes32)&quot;)),</span>
  56 |     | <span class='unexecuted'>                        abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;))</span>
  57 |     | <span class='neutral'>                    )</span>
  58 |     | <span class='neutral'>                );</span>
  59 |     | <span class='unexecuted'>                globalFailed = abi.decode(retdata, (bool));</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='unexecuted'>            return globalFailed;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    } </span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function fail() internal {</span>
  66 |     | <span class='neutral'>        if (hasHEVMContext()) {</span>
  67 |     | <span class='neutral'>            (bool status, ) = HEVM_ADDRESS.call(</span>
  68 |     | <span class='neutral'>                abi.encodePacked(</span>
  69 |     | <span class='neutral'>                    bytes4(keccak256(&quot;store(address,bytes32,bytes32)&quot;)),</span>
  70 |     | <span class='neutral'>                    abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;), bytes32(uint256(0x01)))</span>
  71 |     | <span class='neutral'>                )</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>            status; // Silence compiler warnings</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>        _failed = true;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function hasHEVMContext() internal view returns (bool) {</span>
  79 |     | <span class='neutral'>        uint256 hevmCodeSize = 0;</span>
  80 |     | <span class='neutral'>        assembly {</span>
  81 |     | <span class='unexecuted'>            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='unexecuted'>        return hevmCodeSize &gt; 0;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    modifier logs_gas() {</span>
  87 |     | <span class='neutral'>        uint startGas = gasleft();</span>
  88 |     | <span class='neutral'>        _;</span>
  89 |     | <span class='neutral'>        uint endGas = gasleft();</span>
  90 |     | <span class='neutral'>        emit log_named_uint(&quot;gas&quot;, startGas - endGas);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function assertTrue(bool condition) internal {</span>
  94 |     | <span class='neutral'>        if (!condition) {</span>
  95 |     | <span class='neutral'>            emit log(&quot;Error: Assertion Failed&quot;);</span>
  96 |     | <span class='neutral'>            fail();</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function assertTrue(bool condition, string memory err) internal {</span>
 101 |     | <span class='neutral'>        if (!condition) {</span>
 102 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 103 |     | <span class='neutral'>            assertTrue(condition);</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function assertEq(address a, address b) internal {</span>
 108 |     | <span class='neutral'>        if (a != b) {</span>
 109 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [address]&quot;);</span>
 110 |     | <span class='neutral'>            emit log_named_address(&quot;  Expected&quot;, b);</span>
 111 |     | <span class='neutral'>            emit log_named_address(&quot;    Actual&quot;, a);</span>
 112 |     | <span class='neutral'>            fail();</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'>    function assertEq(address a, address b, string memory err) internal {</span>
 116 |     | <span class='neutral'>        if (a != b) {</span>
 117 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 118 |     | <span class='neutral'>            assertEq(a, b);</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b) internal {</span>
 123 |     | <span class='neutral'>        if (a != b) {</span>
 124 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes32]&quot;);</span>
 125 |     | <span class='neutral'>            emit log_named_bytes32(&quot;  Expected&quot;, b);</span>
 126 |     | <span class='neutral'>            emit log_named_bytes32(&quot;    Actual&quot;, a);</span>
 127 |     | <span class='neutral'>            fail();</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b, string memory err) internal {</span>
 131 |     | <span class='neutral'>        if (a != b) {</span>
 132 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 133 |     | <span class='neutral'>            assertEq(a, b);</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b) internal {</span>
 137 |     | <span class='neutral'>        assertEq(a, b);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {</span>
 140 |     | <span class='neutral'>        assertEq(a, b, err);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(int a, int b) internal {</span>
 144 |     | <span class='neutral'>        if (a != b) {</span>
 145 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int]&quot;);</span>
 146 |     | <span class='neutral'>            emit log_named_int(&quot;  Expected&quot;, b);</span>
 147 |     | <span class='neutral'>            emit log_named_int(&quot;    Actual&quot;, a);</span>
 148 |     | <span class='neutral'>            fail();</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'>    function assertEq(int a, int b, string memory err) internal {</span>
 152 |     | <span class='neutral'>        if (a != b) {</span>
 153 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 154 |     | <span class='neutral'>            assertEq(a, b);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'>    function assertEq(uint a, uint b) internal {</span>
 158 |     | <span class='neutral'>        if (a != b) {</span>
 159 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [uint]&quot;);</span>
 160 |     | <span class='neutral'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 161 |     | <span class='neutral'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 162 |     | <span class='neutral'>            fail();</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'>    function assertEq(uint a, uint b, string memory err) internal {</span>
 166 |     | <span class='neutral'>        if (a != b) {</span>
 167 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 168 |     | <span class='neutral'>            assertEq(a, b);</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals) internal {</span>
 172 |     | <span class='neutral'>        if (a != b) {</span>
 173 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal int]&quot;);</span>
 174 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Expected&quot;, b, decimals);</span>
 175 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;    Actual&quot;, a, decimals);</span>
 176 |     | <span class='neutral'>            fail();</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 180 |     | <span class='neutral'>        if (a != b) {</span>
 181 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 182 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals) internal {</span>
 186 |     | <span class='neutral'>        if (a != b) {</span>
 187 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal uint]&quot;);</span>
 188 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Expected&quot;, b, decimals);</span>
 189 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;    Actual&quot;, a, decimals);</span>
 190 |     | <span class='neutral'>            fail();</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 194 |     | <span class='neutral'>        if (a != b) {</span>
 195 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 196 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function assertGt(uint a, uint b) internal {</span>
 201 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 202 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [uint]&quot;);</span>
 203 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 204 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 205 |     | <span class='neutral'>            fail();</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'>    function assertGt(uint a, uint b, string memory err) internal {</span>
 209 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 210 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 211 |     | <span class='neutral'>            assertGt(a, b);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'>    function assertGt(int a, int b) internal {</span>
 215 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 216 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [int]&quot;);</span>
 217 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 218 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 219 |     | <span class='neutral'>            fail();</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>    function assertGt(int a, int b, string memory err) internal {</span>
 223 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 224 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 225 |     | <span class='neutral'>            assertGt(a, b);</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals) internal {</span>
 229 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 230 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal int]&quot;);</span>
 231 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 232 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 233 |     | <span class='neutral'>            fail();</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 237 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 238 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 239 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 240 |     | <span class='neutral'>        }</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals) internal {</span>
 243 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 244 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal uint]&quot;);</span>
 245 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 246 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 247 |     | <span class='neutral'>            fail();</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 251 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 252 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 253 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    function assertGe(uint a, uint b) internal {</span>
 258 |     | <span class='neutral'>        if (a &lt; b) {</span>
 259 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [uint]&quot;);</span>
 260 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 261 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 262 |     | <span class='neutral'>            fail();</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'>    function assertGe(uint a, uint b, string memory err) internal {</span>
 266 |     | <span class='neutral'>        if (a &lt; b) {</span>
 267 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 268 |     | <span class='neutral'>            assertGe(a, b);</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'>    function assertGe(int a, int b) internal {</span>
 272 |     | <span class='neutral'>        if (a &lt; b) {</span>
 273 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [int]&quot;);</span>
 274 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 275 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 276 |     | <span class='neutral'>            fail();</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'>    function assertGe(int a, int b, string memory err) internal {</span>
 280 |     | <span class='neutral'>        if (a &lt; b) {</span>
 281 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 282 |     | <span class='neutral'>            assertGe(a, b);</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals) internal {</span>
 286 |     | <span class='neutral'>        if (a &lt; b) {</span>
 287 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal int]&quot;);</span>
 288 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 289 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 290 |     | <span class='neutral'>            fail();</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 294 |     | <span class='neutral'>        if (a &lt; b) {</span>
 295 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 296 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 297 |     | <span class='neutral'>        }</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals) internal {</span>
 300 |     | <span class='neutral'>        if (a &lt; b) {</span>
 301 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal uint]&quot;);</span>
 302 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 303 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 304 |     | <span class='neutral'>            fail();</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 308 |     | <span class='neutral'>        if (a &lt; b) {</span>
 309 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 310 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function assertLt(uint a, uint b) internal {</span>
 315 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 316 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [uint]&quot;);</span>
 317 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 318 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 319 |     | <span class='neutral'>            fail();</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'>    function assertLt(uint a, uint b, string memory err) internal {</span>
 323 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 324 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 325 |     | <span class='neutral'>            assertLt(a, b);</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'>    function assertLt(int a, int b) internal {</span>
 329 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 330 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [int]&quot;);</span>
 331 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 332 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 333 |     | <span class='neutral'>            fail();</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'>    function assertLt(int a, int b, string memory err) internal {</span>
 337 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 338 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 339 |     | <span class='neutral'>            assertLt(a, b);</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals) internal {</span>
 343 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 344 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal int]&quot;);</span>
 345 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 346 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 347 |     | <span class='neutral'>            fail();</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 351 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 352 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 353 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals) internal {</span>
 357 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 358 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal uint]&quot;);</span>
 359 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 360 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 361 |     | <span class='neutral'>            fail();</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 365 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 366 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 367 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function assertLe(uint a, uint b) internal {</span>
 372 |     | <span class='neutral'>        if (a &gt; b) {</span>
 373 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [uint]&quot;);</span>
 374 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 375 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 376 |     | <span class='neutral'>            fail();</span>
 377 |     | <span class='neutral'>        }</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>    function assertLe(uint a, uint b, string memory err) internal {</span>
 380 |     | <span class='neutral'>        if (a &gt; b) {</span>
 381 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 382 |     | <span class='neutral'>            assertLe(a, b);</span>
 383 |     | <span class='neutral'>        }</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'>    function assertLe(int a, int b) internal {</span>
 386 |     | <span class='neutral'>        if (a &gt; b) {</span>
 387 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [int]&quot;);</span>
 388 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 389 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 390 |     | <span class='neutral'>            fail();</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'>    function assertLe(int a, int b, string memory err) internal {</span>
 394 |     | <span class='neutral'>        if (a &gt; b) {</span>
 395 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 396 |     | <span class='neutral'>            assertLe(a, b);</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals) internal {</span>
 400 |     | <span class='neutral'>        if (a &gt; b) {</span>
 401 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal int]&quot;);</span>
 402 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 403 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 404 |     | <span class='neutral'>            fail();</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 408 |     | <span class='neutral'>        if (a &gt; b) {</span>
 409 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 410 |     | <span class='neutral'>            assertLeDecimal(a, b, decimals);</span>
 411 |     | <span class='neutral'>        }</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals) internal {</span>
 414 |     | <span class='neutral'>        if (a &gt; b) {</span>
 415 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal uint]&quot;);</span>
 416 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 417 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 418 |     | <span class='neutral'>            fail();</span>
 419 |     | <span class='neutral'>        }</span>
 420 |     | <span class='neutral'>    }</span>
 421 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 422 |     | <span class='neutral'>        if (a &gt; b) {</span>
 423 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 424 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 425 |     | <span class='neutral'>        }</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertEq(string memory a, string memory b) internal {</span>
 429 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 430 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [string]&quot;);</span>
 431 |     | <span class='neutral'>            emit log_named_string(&quot;  Expected&quot;, b);</span>
 432 |     | <span class='neutral'>            emit log_named_string(&quot;    Actual&quot;, a);</span>
 433 |     | <span class='neutral'>            fail();</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'>    function assertEq(string memory a, string memory b, string memory err) internal {</span>
 437 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 438 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 439 |     | <span class='neutral'>            assertEq(a, b);</span>
 440 |     | <span class='neutral'>        }</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {</span>
 444 |     | <span class='neutral'>        ok = true;</span>
 445 |     | <span class='neutral'>        if (a.length == b.length) {</span>
 446 |     | <span class='neutral'>            for (uint i = 0; i &lt; a.length; i++) {</span>
 447 |     | <span class='neutral'>                if (a[i] != b[i]) {</span>
 448 |     | <span class='neutral'>                    ok = false;</span>
 449 |     | <span class='neutral'>                }</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>        } else {</span>
 452 |     | <span class='neutral'>            ok = false;</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b) internal {</span>
 456 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 457 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes]&quot;);</span>
 458 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Expected&quot;, b);</span>
 459 |     | <span class='neutral'>            emit log_named_bytes(&quot;    Actual&quot;, a);</span>
 460 |     | <span class='neutral'>            fail();</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {</span>
 464 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 465 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 466 |     | <span class='neutral'>            assertEq0(a, b);</span>
 467 |     | <span class='neutral'>        }</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'>}</span>
 470 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/access/Ownable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Context} from &quot;../utils/Context.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
  10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
  11 |     | <span class='neutral'> * specific functions.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The initial owner is set to the address provided by the deployer. This can</span>
  14 |     | <span class='neutral'> * later be changed with {transferOwnership}.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
  17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
  18 |     | <span class='neutral'> * the owner.</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
  21 |     | <span class='neutral'>    address private _owner;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev The caller account is not authorized to perform an operation.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    error OwnableUnauthorizedAccount(address account);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /**</span>
  29 |     | <span class='neutral'>     * @dev The owner is not a valid owner account. (eg. `address(0)`)</span>
  30 |     | <span class='neutral'>     */</span>
  31 |     | <span class='neutral'>    error OwnableInvalidOwner(address owner);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.</span>
  37 |     | <span class='neutral'>     */</span>
  38 |     | <span class='neutral'>    constructor(address initialOwner) {</span>
  39 |     | <span class='unexecuted'>        if (initialOwner == address(0)) {</span>
  40 |     | <span class='unexecuted'>            revert OwnableInvalidOwner(address(0));</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='unexecuted'>        _transferOwnership(initialOwner);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  49 | *   | <span class='executed'>        _checkOwner();</span>
  50 |     | <span class='neutral'>        _;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
  55 |     | <span class='neutral'>     */</span>
  56 | *   | <span class='executed'>    function owner() public view virtual returns (address) {</span>
  57 | *   | <span class='executed'>        return _owner;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
  62 |     | <span class='neutral'>     */</span>
  63 | *   | <span class='executed'>    function _checkOwner() internal view virtual {</span>
  64 | *   | <span class='executed'>        if (owner() != _msgSender()) {</span>
  65 | *   | <span class='executed'>            revert OwnableUnauthorizedAccount(_msgSender());</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
  71 |     | <span class='neutral'>     * `onlyOwner` functions. Can only be called by the current owner.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
  74 |     | <span class='neutral'>     * thereby disabling any functionality that is only available to the owner.</span>
  75 |     | <span class='neutral'>     */</span>
  76 | *   | <span class='executed'>    function renounceOwnership() public virtual onlyOwner {</span>
  77 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  82 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
  83 |     | <span class='neutral'>     */</span>
  84 | *   | <span class='executed'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
  85 | *   | <span class='executed'>        if (newOwner == address(0)) {</span>
  86 | *   | <span class='executed'>            revert OwnableInvalidOwner(address(0));</span>
  87 |     | <span class='neutral'>        }</span>
  88 | *   | <span class='executed'>        _transferOwnership(newOwner);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  93 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='unexecuted'>    function _transferOwnership(address newOwner) internal virtual {</span>
  96 |     | <span class='unexecuted'>        address oldOwner = _owner;</span>
  97 |     | <span class='unexecuted'>        _owner = newOwner;</span>
  98 |     | <span class='unexecuted'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'>}</span>
 101 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/interfaces/draft-IERC6093.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)</span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>/**</span>
   6 |     | <span class='neutral'> * @dev Standard ERC20 Errors</span>
   7 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IERC20Errors {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.</span>
  12 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  13 |     | <span class='neutral'>     * @param balance Current balance for the interacting account.</span>
  14 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /**</span>
  19 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
  20 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    error ERC20InvalidSender(address sender);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
  26 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    error ERC20InvalidReceiver(address receiver);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.</span>
  32 |     | <span class='neutral'>     * @param spender Address that may be allowed to operate on tokens without being their owner.</span>
  33 |     | <span class='neutral'>     * @param allowance Amount of tokens a `spender` is allowed to operate with.</span>
  34 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
  40 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    error ERC20InvalidApprover(address approver);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.</span>
  46 |     | <span class='neutral'>     * @param spender Address that may be allowed to operate on tokens without being their owner.</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='neutral'>    error ERC20InvalidSpender(address spender);</span>
  49 |     | <span class='neutral'>}</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>/**</span>
  52 |     | <span class='neutral'> * @dev Standard ERC721 Errors</span>
  53 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.</span>
  54 |     | <span class='neutral'> */</span>
  55 |     | <span class='neutral'>interface IERC721Errors {</span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Indicates that an address can&#39;t be an owner. For example, `address(0)` is a forbidden owner in EIP-20.</span>
  58 |     | <span class='neutral'>     * Used in balance queries.</span>
  59 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    error ERC721InvalidOwner(address owner);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Indicates a `tokenId` whose `owner` is the zero address.</span>
  65 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='neutral'>    error ERC721NonexistentToken(uint256 tokenId);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.</span>
  71 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  72 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  73 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
  79 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    error ERC721InvalidSender(address sender);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
  85 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    error ERC721InvalidReceiver(address receiver);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator`s approval. Used in transfers.</span>
  91 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
  92 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='neutral'>    error ERC721InsufficientApproval(address operator, uint256 tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
  98 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
  99 |     | <span class='neutral'>     */</span>
 100 |     | <span class='neutral'>    error ERC721InvalidApprover(address approver);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.</span>
 104 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    error ERC721InvalidOperator(address operator);</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>/**</span>
 110 |     | <span class='neutral'> * @dev Standard ERC1155 Errors</span>
 111 |     | <span class='neutral'> * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.</span>
 112 |     | <span class='neutral'> */</span>
 113 |     | <span class='neutral'>interface IERC1155Errors {</span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.</span>
 116 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
 117 |     | <span class='neutral'>     * @param balance Current balance for the interacting account.</span>
 118 |     | <span class='neutral'>     * @param needed Minimum amount required to perform a transfer.</span>
 119 |     | <span class='neutral'>     * @param tokenId Identifier number of a token.</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /**</span>
 124 |     | <span class='neutral'>     * @dev Indicates a failure with the token `sender`. Used in transfers.</span>
 125 |     | <span class='neutral'>     * @param sender Address whose tokens are being transferred.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='neutral'>    error ERC1155InvalidSender(address sender);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Indicates a failure with the token `receiver`. Used in transfers.</span>
 131 |     | <span class='neutral'>     * @param receiver Address to which tokens are being transferred.</span>
 132 |     | <span class='neutral'>     */</span>
 133 |     | <span class='neutral'>    error ERC1155InvalidReceiver(address receiver);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator`s approval. Used in transfers.</span>
 137 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 138 |     | <span class='neutral'>     * @param owner Address of the current owner of a token.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    error ERC1155MissingApprovalForAll(address operator, address owner);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.</span>
 144 |     | <span class='neutral'>     * @param approver Address initiating an approval operation.</span>
 145 |     | <span class='neutral'>     */</span>
 146 |     | <span class='neutral'>    error ERC1155InvalidApprover(address approver);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.</span>
 150 |     | <span class='neutral'>     * @param operator Address that may be allowed to operate on tokens without being their owner.</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    error ERC1155InvalidOperator(address operator);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /**</span>
 155 |     | <span class='neutral'>     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.</span>
 156 |     | <span class='neutral'>     * Used in batch transfers.</span>
 157 |     | <span class='neutral'>     * @param idsLength Length of the array of token identifiers</span>
 158 |     | <span class='neutral'>     * @param valuesLength Length of the array of token amounts</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);</span>
 161 |     | <span class='neutral'>}</span>
 162 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/ERC1967/ERC1967Utils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IBeacon} from &quot;../beacon/IBeacon.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Address} from &quot;../../utils/Address.sol&quot;;</span>
   8 |     | <span class='neutral'>import {StorageSlot} from &quot;../../utils/StorageSlot.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev This abstract contract provides getters and event emitting update functions for</span>
  12 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>library ERC1967Utils {</span>
  15 |     | <span class='neutral'>    // We re-declare ERC-1967 events here because they can&#39;t be used directly from IERC1967.</span>
  16 |     | <span class='neutral'>    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.</span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Emitted when the implementation is upgraded.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    event Upgraded(address indexed implementation);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when the admin account has changed.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event AdminChanged(address previousAdmin, address newAdmin);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Emitted when the beacon is changed.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    event BeaconUpgraded(address indexed beacon);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Storage slot with the address of the current implementation.</span>
  34 |     | <span class='neutral'>     * This is the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    // solhint-disable-next-line private-vars-leading-underscore</span>
  37 |     | <span class='neutral'>    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev The `implementation` of the proxy is invalid.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    error ERC1967InvalidImplementation(address implementation);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev The `admin` of the proxy is invalid.</span>
  46 |     | <span class='neutral'>     */</span>
  47 |     | <span class='neutral'>    error ERC1967InvalidAdmin(address admin);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev The `beacon` of the proxy is invalid.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    error ERC1967InvalidBeacon(address beacon);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @dev An upgrade function sees `msg.value &gt; 0` that may be lost.</span>
  56 |     | <span class='neutral'>     */</span>
  57 |     | <span class='neutral'>    error ERC1967NonPayable();</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the current implementation address.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function getImplementation() internal view returns (address) {</span>
  63 |     | <span class='neutral'>        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Stores a new address in the EIP1967 implementation slot.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function _setImplementation(address newImplementation) private {</span>
  70 |     | <span class='neutral'>        if (newImplementation.code.length == 0) {</span>
  71 |     | <span class='neutral'>            revert ERC1967InvalidImplementation(newImplementation);</span>
  72 |     | <span class='neutral'>        }</span>
  73 |     | <span class='neutral'>        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev Performs implementation upgrade with additional setup call if data is nonempty.</span>
  78 |     | <span class='neutral'>     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected</span>
  79 |     | <span class='neutral'>     * to avoid stuck value in the contract.</span>
  80 |     | <span class='neutral'>     *</span>
  81 |     | <span class='neutral'>     * Emits an {IERC1967-Upgraded} event.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    function upgradeToAndCall(address newImplementation, bytes memory data) internal {</span>
  84 |     | <span class='neutral'>        _setImplementation(newImplementation);</span>
  85 |     | <span class='neutral'>        emit Upgraded(newImplementation);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        if (data.length &gt; 0) {</span>
  88 |     | <span class='neutral'>            Address.functionDelegateCall(newImplementation, data);</span>
  89 |     | <span class='neutral'>        } else {</span>
  90 |     | <span class='neutral'>            _checkNonPayable();</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Storage slot with the admin of the contract.</span>
  96 |     | <span class='neutral'>     * This is the keccak-256 hash of &quot;eip1967.proxy.admin&quot; subtracted by 1.</span>
  97 |     | <span class='neutral'>     */</span>
  98 |     | <span class='neutral'>    // solhint-disable-next-line private-vars-leading-underscore</span>
  99 |     | <span class='neutral'>    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Returns the current admin.</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using</span>
 105 |     | <span class='neutral'>     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.</span>
 106 |     | <span class='neutral'>     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='neutral'>    function getAdmin() internal view returns (address) {</span>
 109 |     | <span class='neutral'>        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @dev Stores a new address in the EIP1967 admin slot.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function _setAdmin(address newAdmin) private {</span>
 116 |     | <span class='neutral'>        if (newAdmin == address(0)) {</span>
 117 |     | <span class='neutral'>            revert ERC1967InvalidAdmin(address(0));</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Changes the admin of the proxy.</span>
 124 |     | <span class='neutral'>     *</span>
 125 |     | <span class='neutral'>     * Emits an {IERC1967-AdminChanged} event.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='neutral'>    function changeAdmin(address newAdmin) internal {</span>
 128 |     | <span class='neutral'>        emit AdminChanged(getAdmin(), newAdmin);</span>
 129 |     | <span class='neutral'>        _setAdmin(newAdmin);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /**</span>
 133 |     | <span class='neutral'>     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.</span>
 134 |     | <span class='neutral'>     * This is the keccak-256 hash of &quot;eip1967.proxy.beacon&quot; subtracted by 1.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    // solhint-disable-next-line private-vars-leading-underscore</span>
 137 |     | <span class='unexecuted'>    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Returns the current beacon.</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='neutral'>    function getBeacon() internal view returns (address) {</span>
 143 |     | <span class='neutral'>        return StorageSlot.getAddressSlot(BEACON_SLOT).value;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /**</span>
 147 |     | <span class='neutral'>     * @dev Stores a new beacon in the EIP1967 beacon slot.</span>
 148 |     | <span class='neutral'>     */</span>
 149 |     | <span class='unexecuted'>    function _setBeacon(address newBeacon) private {</span>
 150 |     | <span class='unexecuted'>        if (newBeacon.code.length == 0) {</span>
 151 |     | <span class='unexecuted'>            revert ERC1967InvalidBeacon(newBeacon);</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        address beaconImplementation = IBeacon(newBeacon).implementation();</span>
 157 |     | <span class='unexecuted'>        if (beaconImplementation.code.length == 0) {</span>
 158 |     | <span class='unexecuted'>            revert ERC1967InvalidImplementation(beaconImplementation);</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /**</span>
 163 |     | <span class='neutral'>     * @dev Change the beacon and trigger a setup call if data is nonempty.</span>
 164 |     | <span class='neutral'>     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected</span>
 165 |     | <span class='neutral'>     * to avoid stuck value in the contract.</span>
 166 |     | <span class='neutral'>     *</span>
 167 |     | <span class='neutral'>     * Emits an {IERC1967-BeaconUpgraded} event.</span>
 168 |     | <span class='neutral'>     *</span>
 169 |     | <span class='neutral'>     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since</span>
 170 |     | <span class='neutral'>     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for</span>
 171 |     | <span class='neutral'>     * efficiency.</span>
 172 |     | <span class='neutral'>     */</span>
 173 |     | <span class='unexecuted'>    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {</span>
 174 |     | <span class='unexecuted'>        _setBeacon(newBeacon);</span>
 175 |     | <span class='unexecuted'>        emit BeaconUpgraded(newBeacon);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        if (data.length &gt; 0) {</span>
 178 |     | <span class='unexecuted'>            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);</span>
 179 |     | <span class='neutral'>        } else {</span>
 180 |     | <span class='unexecuted'>            _checkNonPayable();</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    /**</span>
 185 |     | <span class='neutral'>     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract</span>
 186 |     | <span class='neutral'>     * if an upgrade doesn&#39;t perform an initialization call.</span>
 187 |     | <span class='neutral'>     */</span>
 188 |     | <span class='unexecuted'>    function _checkNonPayable() private {</span>
 189 |     | <span class='unexecuted'>        if (msg.value &gt; 0) {</span>
 190 |     | <span class='unexecuted'>            revert ERC1967NonPayable();</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/Proxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM</span>
  8 |     | <span class='neutral'> * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to</span>
  9 |     | <span class='neutral'> * be specified by overriding the virtual {_implementation} function.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a</span>
 12 |     | <span class='neutral'> * different contract through the {_delegate} function.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * The success and return data of the delegated call will be returned back to the caller of the proxy.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Proxy {</span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Delegates the current call to `implementation`.</span>
 19 |     | <span class='neutral'>     *</span>
 20 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 21 |     | <span class='neutral'>     */</span>
 22 | *   | <span class='executed'>    function _delegate(address implementation) internal virtual {</span>
 23 |     | <span class='neutral'>        assembly {</span>
 24 |     | <span class='neutral'>            // Copy msg.data. We take full control of memory in this inline assembly</span>
 25 |     | <span class='neutral'>            // block because it will not return to Solidity code. We overwrite the</span>
 26 |     | <span class='neutral'>            // Solidity scratch pad at memory position 0.</span>
 27 | *   | <span class='executed'>            calldatacopy(0, 0, calldatasize())</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>            // Call the implementation.</span>
 30 |     | <span class='neutral'>            // out and outsize are 0 because we don&#39;t know the size yet.</span>
 31 | *   | <span class='executed'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>            // Copy the returned data.</span>
 34 | *   | <span class='executed'>            returndatacopy(0, 0, returndatasize())</span>
 35 |     | <span class='neutral'></span>
 36 | *   | <span class='executed'>            switch result</span>
 37 |     | <span class='neutral'>            // delegatecall returns 0 on error.</span>
 38 | *   | <span class='executed'>            case 0 {</span>
 39 | *   | <span class='executed'>                revert(0, returndatasize())</span>
 40 |     | <span class='neutral'>            }</span>
 41 |     | <span class='neutral'>            default {</span>
 42 |     | <span class='unexecuted'>                return(0, returndatasize())</span>
 43 |     | <span class='neutral'>            }</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback</span>
 49 |     | <span class='neutral'>     * function and {_fallback} should delegate.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    function _implementation() internal view virtual returns (address);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /**</span>
 54 |     | <span class='neutral'>     * @dev Delegates the current call to the address returned by `_implementation()`.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 57 |     | <span class='neutral'>     */</span>
 58 | *   | <span class='executed'>    function _fallback() internal virtual {</span>
 59 | *   | <span class='executed'>        _delegate(_implementation());</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    /**</span>
 63 |     | <span class='neutral'>     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other</span>
 64 |     | <span class='neutral'>     * function in the contract matches the call data.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    fallback() external payable virtual {</span>
 67 | *   | <span class='executed'>        _fallback();</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'>}</span>
 70 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/beacon/BeaconProxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/BeaconProxy.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IBeacon} from &quot;./IBeacon.sol&quot;;</span>
  7 |     | <span class='neutral'>import {Proxy} from &quot;../Proxy.sol&quot;;</span>
  8 |     | <span class='neutral'>import {ERC1967Utils} from &quot;../ERC1967/ERC1967Utils.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/**</span>
 11 |     | <span class='neutral'> * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an</span>
 14 |     | <span class='neutral'> * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by</span>
 15 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] so that it can be accessed externally.</span>
 16 |     | <span class='neutral'> *</span>
 17 |     | <span class='neutral'> * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust</span>
 18 |     | <span class='neutral'> * the beacon to not upgrade the implementation maliciously.</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in</span>
 21 |     | <span class='neutral'> * an inconsistent state where the beacon storage slot does not match the beacon address.</span>
 22 |     | <span class='neutral'> */</span>
 23 | *   | <span class='executed'>contract BeaconProxy is Proxy {</span>
 24 |     | <span class='neutral'>    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.</span>
 25 |     | <span class='neutral'>    address private immutable _beacon;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /**</span>
 28 |     | <span class='neutral'>     * @dev Initializes the proxy with `beacon`.</span>
 29 |     | <span class='neutral'>     *</span>
 30 |     | <span class='neutral'>     * If `data` is nonempty, it&#39;s used as data in a delegate call to the implementation returned by the beacon. This</span>
 31 |     | <span class='neutral'>     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity</span>
 32 |     | <span class='neutral'>     * constructor.</span>
 33 |     | <span class='neutral'>     *</span>
 34 |     | <span class='neutral'>     * Requirements:</span>
 35 |     | <span class='neutral'>     *</span>
 36 |     | <span class='neutral'>     * - `beacon` must be a contract with the interface {IBeacon}.</span>
 37 |     | <span class='neutral'>     * - If `data` is empty, `msg.value` must be zero.</span>
 38 |     | <span class='neutral'>     */</span>
 39 | *   | <span class='executed'>    constructor(address beacon, bytes memory data) payable {</span>
 40 |     | <span class='unexecuted'>        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);</span>
 41 |     | <span class='unexecuted'>        _beacon = beacon;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Returns the current implementation address of the associated beacon.</span>
 46 |     | <span class='neutral'>     */</span>
 47 | *   | <span class='executed'>    function _implementation() internal view virtual override returns (address) {</span>
 48 | *   | <span class='executed'>        return IBeacon(_getBeacon()).implementation();</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /**</span>
 52 |     | <span class='neutral'>     * @dev Returns the beacon.</span>
 53 |     | <span class='neutral'>     */</span>
 54 |     | <span class='neutral'>    function _getBeacon() internal view virtual returns (address) {</span>
 55 | *   | <span class='executed'>        return _beacon;</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/beacon/IBeacon.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This is the interface that {BeaconProxy} expects of its beacon.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IBeacon {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Must return an address that can be used as a delegate call target.</span>
 12 |     | <span class='neutral'>     *</span>
 13 |     | <span class='neutral'>     * {UpgradeableBeacon} will check that this address is a contract.</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function implementation() external view returns (address);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/proxy/beacon/UpgradeableBeacon.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/UpgradeableBeacon.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IBeacon} from &quot;./IBeacon.sol&quot;;</span>
  7 |     | <span class='neutral'>import {Ownable} from &quot;../../access/Ownable.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their</span>
 11 |     | <span class='neutral'> * implementation contract, which is where they will delegate all function calls.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.</span>
 14 |     | <span class='neutral'> */</span>
 15 | *   | <span class='executed'>contract UpgradeableBeacon is IBeacon, Ownable {</span>
 16 |     | <span class='neutral'>    address private _implementation;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev The `implementation` of the beacon is invalid.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    error BeaconInvalidImplementation(address implementation);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev Emitted when the implementation returned by the beacon is changed.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    event Upgraded(address indexed implementation);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /**</span>
 29 |     | <span class='neutral'>     * @dev Sets the address of the initial implementation, and the initial owner who can upgrade the beacon.</span>
 30 |     | <span class='neutral'>     */</span>
 31 |     | <span class='unexecuted'>    constructor(address implementation_, address initialOwner) Ownable(initialOwner) {</span>
 32 |     | <span class='unexecuted'>        _setImplementation(implementation_);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev Returns the current implementation address.</span>
 37 |     | <span class='neutral'>     */</span>
 38 | *   | <span class='executed'>    function implementation() public view virtual returns (address) {</span>
 39 | *   | <span class='executed'>        return _implementation;</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /**</span>
 43 |     | <span class='neutral'>     * @dev Upgrades the beacon to a new implementation.</span>
 44 |     | <span class='neutral'>     *</span>
 45 |     | <span class='neutral'>     * Emits an {Upgraded} event.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * Requirements:</span>
 48 |     | <span class='neutral'>     *</span>
 49 |     | <span class='neutral'>     * - msg.sender must be the owner of the contract.</span>
 50 |     | <span class='neutral'>     * - `newImplementation` must be a contract.</span>
 51 |     | <span class='neutral'>     */</span>
 52 | *   | <span class='executed'>    function upgradeTo(address newImplementation) public virtual onlyOwner {</span>
 53 | *   | <span class='executed'>        _setImplementation(newImplementation);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    /**</span>
 57 |     | <span class='neutral'>     * @dev Sets the implementation contract address for this beacon</span>
 58 |     | <span class='neutral'>     *</span>
 59 |     | <span class='neutral'>     * Requirements:</span>
 60 |     | <span class='neutral'>     *</span>
 61 |     | <span class='neutral'>     * - `newImplementation` must be a contract.</span>
 62 |     | <span class='neutral'>     */</span>
 63 | *   | <span class='executed'>    function _setImplementation(address newImplementation) private {</span>
 64 | *   | <span class='executed'>        if (newImplementation.code.length == 0) {</span>
 65 | *   | <span class='executed'>            revert BeaconInvalidImplementation(newImplementation);</span>
 66 |     | <span class='neutral'>        }</span>
 67 | *   | <span class='executed'>        _implementation = newImplementation;</span>
 68 |     | <span class='unexecuted'>        emit Upgraded(newImplementation);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'>}</span>
 71 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20Metadata} from &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Context} from &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IERC20Errors} from &quot;../../interfaces/draft-IERC6093.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  15 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='neutral'>abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {</span>
  35 |     | <span class='neutral'>    mapping(address account =&gt; uint256) private _balances;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    string private _name;</span>
  42 |     | <span class='neutral'>    string private _symbol;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  46 |     | <span class='neutral'>     *</span>
  47 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  48 |     | <span class='neutral'>     * construction.</span>
  49 |     | <span class='neutral'>     */</span>
  50 |     | <span class='neutral'>    constructor(string memory name_, string memory symbol_) {</span>
  51 |     | <span class='neutral'>        _name = name_;</span>
  52 |     | <span class='neutral'>        _symbol = symbol_;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    function name() public view virtual returns (string memory) {</span>
  59 |     | <span class='neutral'>        return _name;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  64 |     | <span class='neutral'>     * name.</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    function symbol() public view virtual returns (string memory) {</span>
  67 |     | <span class='neutral'>        return _symbol;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  72 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  73 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  76 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  77 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  80 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  81 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='neutral'>    function decimals() public view virtual returns (uint8) {</span>
  84 |     | <span class='neutral'>        return 18;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function totalSupply() public view virtual returns (uint256) {</span>
  91 |     | <span class='neutral'>        return _totalSupply;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function balanceOf(address account) public view virtual returns (uint256) {</span>
  98 |     | <span class='neutral'>        return _balances[account];</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * Requirements:</span>
 105 |     | <span class='neutral'>     *</span>
 106 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 107 |     | <span class='neutral'>     * - the caller must have a balance of at least `value`.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    function transfer(address to, uint256 value) public virtual returns (bool) {</span>
 110 |     | <span class='neutral'>        address owner = _msgSender();</span>
 111 |     | <span class='neutral'>        _transfer(owner, to, value);</span>
 112 |     | <span class='neutral'>        return true;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /**</span>
 116 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function allowance(address owner, address spender) public view virtual returns (uint256) {</span>
 119 |     | <span class='neutral'>        return _allowances[owner][spender];</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 124 |     | <span class='neutral'>     *</span>
 125 |     | <span class='neutral'>     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on</span>
 126 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 127 |     | <span class='neutral'>     *</span>
 128 |     | <span class='neutral'>     * Requirements:</span>
 129 |     | <span class='neutral'>     *</span>
 130 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    function approve(address spender, uint256 value) public virtual returns (bool) {</span>
 133 |     | <span class='neutral'>        address owner = _msgSender();</span>
 134 |     | <span class='neutral'>        _approve(owner, spender, value);</span>
 135 |     | <span class='neutral'>        return true;</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    /**</span>
 139 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 140 |     | <span class='neutral'>     *</span>
 141 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 142 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 143 |     | <span class='neutral'>     *</span>
 144 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 145 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 146 |     | <span class='neutral'>     *</span>
 147 |     | <span class='neutral'>     * Requirements:</span>
 148 |     | <span class='neutral'>     *</span>
 149 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 150 |     | <span class='neutral'>     * - `from` must have a balance of at least `value`.</span>
 151 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 152 |     | <span class='neutral'>     * `value`.</span>
 153 |     | <span class='neutral'>     */</span>
 154 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {</span>
 155 |     | <span class='neutral'>        address spender = _msgSender();</span>
 156 |     | <span class='neutral'>        _spendAllowance(from, spender, value);</span>
 157 |     | <span class='neutral'>        _transfer(from, to, value);</span>
 158 |     | <span class='neutral'>        return true;</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to`.</span>
 163 |     | <span class='neutral'>     *</span>
 164 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 165 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 166 |     | <span class='neutral'>     *</span>
 167 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 168 |     | <span class='neutral'>     *</span>
 169 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 170 |     | <span class='neutral'>     */</span>
 171 |     | <span class='neutral'>    function _transfer(address from, address to, uint256 value) internal {</span>
 172 |     | <span class='neutral'>        if (from == address(0)) {</span>
 173 |     | <span class='neutral'>            revert ERC20InvalidSender(address(0));</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>        if (to == address(0)) {</span>
 176 |     | <span class='neutral'>            revert ERC20InvalidReceiver(address(0));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        _update(from, to, value);</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    /**</span>
 182 |     | <span class='neutral'>     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`</span>
 183 |     | <span class='neutral'>     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding</span>
 184 |     | <span class='neutral'>     * this function.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 187 |     | <span class='neutral'>     */</span>
 188 |     | <span class='neutral'>    function _update(address from, address to, uint256 value) internal virtual {</span>
 189 |     | <span class='neutral'>        if (from == address(0)) {</span>
 190 |     | <span class='neutral'>            // Overflow check required: The rest of the code assumes that totalSupply never overflows</span>
 191 |     | <span class='neutral'>            _totalSupply += value;</span>
 192 |     | <span class='neutral'>        } else {</span>
 193 |     | <span class='neutral'>            uint256 fromBalance = _balances[from];</span>
 194 |     | <span class='neutral'>            if (fromBalance &lt; value) {</span>
 195 |     | <span class='neutral'>                revert ERC20InsufficientBalance(from, fromBalance, value);</span>
 196 |     | <span class='neutral'>            }</span>
 197 |     | <span class='neutral'>            unchecked {</span>
 198 |     | <span class='neutral'>                // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span>
 199 |     | <span class='neutral'>                _balances[from] = fromBalance - value;</span>
 200 |     | <span class='neutral'>            }</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        if (to == address(0)) {</span>
 204 |     | <span class='neutral'>            unchecked {</span>
 205 |     | <span class='neutral'>                // Overflow not possible: value &lt;= totalSupply or value &lt;= fromBalance &lt;= totalSupply.</span>
 206 |     | <span class='neutral'>                _totalSupply -= value;</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='neutral'>            unchecked {</span>
 210 |     | <span class='neutral'>                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.</span>
 211 |     | <span class='neutral'>                _balances[to] += value;</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        emit Transfer(from, to, value);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    /**</span>
 219 |     | <span class='neutral'>     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).</span>
 220 |     | <span class='neutral'>     * Relies on the `_update` mechanism</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 223 |     | <span class='neutral'>     *</span>
 224 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead.</span>
 225 |     | <span class='neutral'>     */</span>
 226 |     | <span class='neutral'>    function _mint(address account, uint256 value) internal {</span>
 227 |     | <span class='neutral'>        if (account == address(0)) {</span>
 228 |     | <span class='neutral'>            revert ERC20InvalidReceiver(address(0));</span>
 229 |     | <span class='neutral'>        }</span>
 230 |     | <span class='neutral'>        _update(address(0), account, value);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    /**</span>
 234 |     | <span class='neutral'>     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.</span>
 235 |     | <span class='neutral'>     * Relies on the `_update` mechanism.</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 238 |     | <span class='neutral'>     *</span>
 239 |     | <span class='neutral'>     * NOTE: This function is not virtual, {_update} should be overridden instead</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='neutral'>    function _burn(address account, uint256 value) internal {</span>
 242 |     | <span class='neutral'>        if (account == address(0)) {</span>
 243 |     | <span class='neutral'>            revert ERC20InvalidSender(address(0));</span>
 244 |     | <span class='neutral'>        }</span>
 245 |     | <span class='neutral'>        _update(account, address(0), value);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 252 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 253 |     | <span class='neutral'>     *</span>
 254 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 255 |     | <span class='neutral'>     *</span>
 256 |     | <span class='neutral'>     * Requirements:</span>
 257 |     | <span class='neutral'>     *</span>
 258 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 259 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 260 |     | <span class='neutral'>     *</span>
 261 |     | <span class='neutral'>     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.</span>
 262 |     | <span class='neutral'>     */</span>
 263 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value) internal {</span>
 264 |     | <span class='neutral'>        _approve(owner, spender, value, true);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    /**</span>
 268 |     | <span class='neutral'>     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by</span>
 271 |     | <span class='neutral'>     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any</span>
 272 |     | <span class='neutral'>     * `Approval` event during `transferFrom` operations.</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to</span>
 275 |     | <span class='neutral'>     * true using the following override:</span>
 276 |     | <span class='neutral'>     * ```</span>
 277 |     | <span class='neutral'>     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {</span>
 278 |     | <span class='neutral'>     *     super._approve(owner, spender, value, true);</span>
 279 |     | <span class='neutral'>     * }</span>
 280 |     | <span class='neutral'>     * ```</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * Requirements are the same as {_approve}.</span>
 283 |     | <span class='neutral'>     */</span>
 284 |     | <span class='neutral'>    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {</span>
 285 |     | <span class='neutral'>        if (owner == address(0)) {</span>
 286 |     | <span class='neutral'>            revert ERC20InvalidApprover(address(0));</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'>        if (spender == address(0)) {</span>
 289 |     | <span class='neutral'>            revert ERC20InvalidSpender(address(0));</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>        _allowances[owner][spender] = value;</span>
 292 |     | <span class='neutral'>        if (emitEvent) {</span>
 293 |     | <span class='neutral'>            emit Approval(owner, spender, value);</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `value`.</span>
 299 |     | <span class='neutral'>     *</span>
 300 |     | <span class='neutral'>     * Does not update the allowance value in case of infinite allowance.</span>
 301 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Does not emit an {Approval} event.</span>
 304 |     | <span class='neutral'>     */</span>
 305 |     | <span class='neutral'>    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {</span>
 306 |     | <span class='neutral'>        uint256 currentAllowance = allowance(owner, spender);</span>
 307 |     | <span class='neutral'>        if (currentAllowance != type(uint256).max) {</span>
 308 |     | <span class='neutral'>            if (currentAllowance &lt; value) {</span>
 309 |     | <span class='neutral'>                revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span>
 310 |     | <span class='neutral'>            }</span>
 311 |     | <span class='neutral'>            unchecked {</span>
 312 |     | <span class='neutral'>                _approve(owner, spender, currentAllowance - value, false);</span>
 313 |     | <span class='neutral'>            }</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'>}</span>
 317 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the value of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the value of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the</span>
 54 |     | <span class='neutral'>     * caller&#39;s tokens.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 59 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 60 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 61 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 62 |     | <span class='neutral'>     * desired value afterwards:</span>
 63 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 64 |     | <span class='neutral'>     *</span>
 65 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    /**</span>
 70 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to` using the</span>
 71 |     | <span class='neutral'>     * allowance mechanism. `value` is then deducted from the caller&#39;s</span>
 72 |     | <span class='neutral'>     * allowance.</span>
 73 |     | <span class='neutral'>     *</span>
 74 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 75 |     | <span class='neutral'>     *</span>
 76 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ==== Security Considerations</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature</span>
 17 |     | <span class='neutral'> * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be</span>
 18 |     | <span class='neutral'> * considered as an intention to spend the allowance in any specific way. The second is that because permits have</span>
 19 |     | <span class='neutral'> * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should</span>
 20 |     | <span class='neutral'> * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be</span>
 21 |     | <span class='neutral'> * generally recommended is:</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * ```solidity</span>
 24 |     | <span class='neutral'> * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {</span>
 25 |     | <span class='neutral'> *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}</span>
 26 |     | <span class='neutral'> *     doThing(..., value);</span>
 27 |     | <span class='neutral'> * }</span>
 28 |     | <span class='neutral'> *</span>
 29 |     | <span class='neutral'> * function doThing(..., uint256 value) public {</span>
 30 |     | <span class='neutral'> *     token.safeTransferFrom(msg.sender, address(this), value);</span>
 31 |     | <span class='neutral'> *     ...</span>
 32 |     | <span class='neutral'> * }</span>
 33 |     | <span class='neutral'> * ```</span>
 34 |     | <span class='neutral'> *</span>
 35 |     | <span class='neutral'> * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of</span>
 36 |     | <span class='neutral'> * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also</span>
 37 |     | <span class='neutral'> * {SafeERC20-safeTransferFrom}).</span>
 38 |     | <span class='neutral'> *</span>
 39 |     | <span class='neutral'> * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so</span>
 40 |     | <span class='neutral'> * contracts should have entry points that don&#39;t rely on permit.</span>
 41 |     | <span class='neutral'> */</span>
 42 |     | <span class='neutral'>interface IERC20Permit {</span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 45 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 48 |     | <span class='neutral'>     * ordering also apply here.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 51 |     | <span class='neutral'>     *</span>
 52 |     | <span class='neutral'>     * Requirements:</span>
 53 |     | <span class='neutral'>     *</span>
 54 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 55 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 56 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 57 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 58 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 59 |     | <span class='neutral'>     *</span>
 60 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 61 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 62 |     | <span class='neutral'>     * section].</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * CAUTION: See Security Considerations above.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function permit(</span>
 67 |     | <span class='neutral'>        address owner,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 value,</span>
 70 |     | <span class='neutral'>        uint256 deadline,</span>
 71 |     | <span class='neutral'>        uint8 v,</span>
 72 |     | <span class='neutral'>        bytes32 r,</span>
 73 |     | <span class='neutral'>        bytes32 s</span>
 74 |     | <span class='neutral'>    ) external;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 78 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 81 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 89 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20Permit} from &quot;../extensions/IERC20Permit.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Address} from &quot;../../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library SafeERC20 {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev An operation with an ERC20 token failed.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    error SafeERC20FailedOperation(address token);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Indicates a failed `decreaseAllowance` request.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
  34 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='unexecuted'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
  37 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the</span>
  42 |     | <span class='neutral'>     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='neutral'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
  45 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Increase the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  50 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  53 |     | <span class='neutral'>        uint256 oldAllowance = token.allowance(address(this), spender);</span>
  54 |     | <span class='neutral'>        forceApprove(token, spender, oldAllowance + value);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev Decrease the calling contract&#39;s allowance toward `spender` by `requestedDecrease`. If `token` returns no</span>
  59 |     | <span class='neutral'>     * value, non-reverting calls are assumed to be successful.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {</span>
  62 |     | <span class='neutral'>        unchecked {</span>
  63 |     | <span class='neutral'>            uint256 currentAllowance = token.allowance(address(this), spender);</span>
  64 |     | <span class='neutral'>            if (currentAllowance &lt; requestedDecrease) {</span>
  65 |     | <span class='neutral'>                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'>            forceApprove(token, spender, currentAllowance - requestedDecrease);</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Set the calling contract&#39;s allowance toward `spender` to `value`. If `token` returns no value,</span>
  73 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval</span>
  74 |     | <span class='neutral'>     * to be set to zero before setting it to a non-zero value, such as USDT.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='unexecuted'>    function forceApprove(IERC20 token, address spender, uint256 value) internal {</span>
  77 |     | <span class='unexecuted'>        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        if (!_callOptionalReturnBool(token, approvalCall)) {</span>
  80 |     | <span class='unexecuted'>            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));</span>
  81 |     | <span class='unexecuted'>            _callOptionalReturn(token, approvalCall);</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
  87 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
  88 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
  89 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='unexecuted'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
  92 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
  93 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
  94 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        bytes memory returndata = address(token).functionCall(data);</span>
  97 |     | <span class='unexecuted'>        if (returndata.length != 0 &amp;&amp; !abi.decode(returndata, (bool))) {</span>
  98 |     | <span class='unexecuted'>            revert SafeERC20FailedOperation(address(token));</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 104 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 105 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 106 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.</span>
 109 |     | <span class='neutral'>     */</span>
 110 |     | <span class='unexecuted'>    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {</span>
 111 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 112 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false</span>
 113 |     | <span class='neutral'>        // and not revert is the subcall reverts.</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        (bool success, bytes memory returndata) = address(token).call(data);</span>
 116 |     | <span class='unexecuted'>        return success &amp;&amp; (returndata.length == 0 || abi.decode(returndata, (bool))) &amp;&amp; address(token).code.length &gt; 0;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'>}</span>
 119 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/token/ERC721/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC165} from &quot;../../utils/introspection/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Required interface of an ERC721 compliant contract.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Returns the number of tokens in ``owner``&#39;s account.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256 balance);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId` token.</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Requirements:</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 tokenId) external view returns (address owner);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`.</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * Requirements:</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  47 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  48 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  49 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  50 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon</span>
  51 |     | <span class='neutral'>     *   a safe transfer.</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
  59 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
  60 |     | <span class='neutral'>     *</span>
  61 |     | <span class='neutral'>     * Requirements:</span>
  62 |     | <span class='neutral'>     *</span>
  63 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  64 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  65 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  66 |     | <span class='neutral'>     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or</span>
  67 |     | <span class='neutral'>     *   {setApprovalForAll}.</span>
  68 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon</span>
  69 |     | <span class='neutral'>     *   a safe transfer.</span>
  70 |     | <span class='neutral'>     *</span>
  71 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId) external;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Transfers `tokenId` token from `from` to `to`.</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721</span>
  79 |     | <span class='neutral'>     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must</span>
  80 |     | <span class='neutral'>     * understand this adds an external call which potentially creates a reentrancy vulnerability.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Requirements:</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  85 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  86 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
  87 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 tokenId) external;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account.</span>
  95 |     | <span class='neutral'>     * The approval is cleared when the token is transferred.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * Requirements:</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * - The caller must own the token or be an approved operator.</span>
 102 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='neutral'>    function approve(address to, uint256 tokenId) external;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @dev Approve or remove `operator` as an operator for the caller.</span>
 110 |     | <span class='neutral'>     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * Requirements:</span>
 113 |     | <span class='neutral'>     *</span>
 114 |     | <span class='neutral'>     * - The `operator` cannot be the address zero.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) external;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /**</span>
 121 |     | <span class='neutral'>     * @dev Returns the account approved for `tokenId` token.</span>
 122 |     | <span class='neutral'>     *</span>
 123 |     | <span class='neutral'>     * Requirements:</span>
 124 |     | <span class='neutral'>     *</span>
 125 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='neutral'>    function getApproved(uint256 tokenId) external view returns (address operator);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * See {setApprovalForAll}</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function isApprovedForAll(address owner, address operator) external view returns (bool);</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev The ETH balance of the account is not enough to perform the operation.</span>
  12 |     | <span class='neutral'>     */</span>
  13 |     | <span class='neutral'>    error AddressInsufficientBalance(address account);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @dev There&#39;s no code at `target` (it is not a contract).</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='neutral'>    error AddressEmptyCode(address target);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @dev A call to an address target failed. The target may have reverted.</span>
  22 |     | <span class='neutral'>     */</span>
  23 |     | <span class='neutral'>    error FailedInnerCall();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /**</span>
  26 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  27 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  28 |     | <span class='neutral'>     *</span>
  29 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  30 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  31 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  32 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  33 |     | <span class='neutral'>     *</span>
  34 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  35 |     | <span class='neutral'>     *</span>
  36 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  37 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  38 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  39 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  42 |     | <span class='neutral'>        if (address(this).balance &lt; amount) {</span>
  43 |     | <span class='neutral'>            revert AddressInsufficientBalance(address(this));</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  47 |     | <span class='neutral'>        if (!success) {</span>
  48 |     | <span class='neutral'>            revert FailedInnerCall();</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  54 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  55 |     | <span class='neutral'>     * function instead.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * If `target` reverts with a revert reason or custom error, it is bubbled</span>
  58 |     | <span class='neutral'>     * up by this function (like regular Solidity function calls). However, if</span>
  59 |     | <span class='neutral'>     * the call reverted with no returned reason, this function reverts with a</span>
  60 |     | <span class='neutral'>     * {FailedInnerCall} error.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  63 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  64 |     | <span class='neutral'>     *</span>
  65 |     | <span class='neutral'>     * Requirements:</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  68 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  71 |     | <span class='unexecuted'>        return functionCallWithValue(target, data, 0);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
  76 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * Requirements:</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
  81 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='unexecuted'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
  84 |     | <span class='unexecuted'>        if (address(this).balance &lt; value) {</span>
  85 |     | <span class='unexecuted'>            revert AddressInsufficientBalance(address(this));</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='unexecuted'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
  88 |     | <span class='unexecuted'>        return verifyCallResultFromTarget(target, success, returndata);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
  93 |     | <span class='neutral'>     * but performing a static call.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
  96 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
  97 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 102 |     | <span class='neutral'>     * but performing a delegate call.</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='unexecuted'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 105 |     | <span class='unexecuted'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 106 |     | <span class='unexecuted'>        return verifyCallResultFromTarget(target, success, returndata);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target</span>
 111 |     | <span class='neutral'>     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an</span>
 112 |     | <span class='neutral'>     * unsuccessful call.</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='unexecuted'>    function verifyCallResultFromTarget(</span>
 115 |     | <span class='neutral'>        address target,</span>
 116 |     | <span class='neutral'>        bool success,</span>
 117 |     | <span class='neutral'>        bytes memory returndata</span>
 118 |     | <span class='unexecuted'>    ) internal view returns (bytes memory) {</span>
 119 |     | <span class='unexecuted'>        if (!success) {</span>
 120 |     | <span class='unexecuted'>            _revert(returndata);</span>
 121 |     | <span class='neutral'>        } else {</span>
 122 |     | <span class='neutral'>            // only check if target is a contract if the call was successful and the return data is empty</span>
 123 |     | <span class='neutral'>            // otherwise we already know that it was a contract</span>
 124 |     | <span class='unexecuted'>            if (returndata.length == 0 &amp;&amp; target.code.length == 0) {</span>
 125 |     | <span class='unexecuted'>                revert AddressEmptyCode(target);</span>
 126 |     | <span class='neutral'>            }</span>
 127 |     | <span class='unexecuted'>            return returndata;</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and reverts if it wasn&#39;t, either by bubbling the</span>
 133 |     | <span class='neutral'>     * revert reason or with a default {FailedInnerCall} error.</span>
 134 |     | <span class='neutral'>     */</span>
 135 |     | <span class='neutral'>    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {</span>
 136 |     | <span class='neutral'>        if (!success) {</span>
 137 |     | <span class='neutral'>            _revert(returndata);</span>
 138 |     | <span class='neutral'>        } else {</span>
 139 |     | <span class='neutral'>            return returndata;</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.</span>
 145 |     | <span class='neutral'>     */</span>
 146 |     | <span class='unexecuted'>    function _revert(bytes memory returndata) private pure {</span>
 147 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 148 |     | <span class='unexecuted'>        if (returndata.length &gt; 0) {</span>
 149 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 150 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 151 |     | <span class='neutral'>            assembly {</span>
 152 |     | <span class='unexecuted'>                let returndata_size := mload(returndata)</span>
 153 |     | <span class='unexecuted'>                revert(add(32, returndata), returndata_size)</span>
 154 |     | <span class='neutral'>            }</span>
 155 |     | <span class='neutral'>        } else {</span>
 156 |     | <span class='unexecuted'>            revert FailedInnerCall();</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'>}</span>
 160 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 26 |     | <span class='neutral'>        return 0;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/StorageSlot.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Library for reading and writing primitive types to specific storage slots.</span>
   9 |     | <span class='neutral'> *</span>
  10 |     | <span class='neutral'> * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.</span>
  11 |     | <span class='neutral'> * This library helps with reading and writing to such slots without the need for inline assembly.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * Example usage to set ERC1967 implementation slot:</span>
  16 |     | <span class='neutral'> * ```solidity</span>
  17 |     | <span class='neutral'> * contract ERC1967 {</span>
  18 |     | <span class='neutral'> *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> *     function _getImplementation() internal view returns (address) {</span>
  21 |     | <span class='neutral'> *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;</span>
  22 |     | <span class='neutral'> *     }</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> *     function _setImplementation(address newImplementation) internal {</span>
  25 |     | <span class='neutral'> *         require(newImplementation.code.length &gt; 0);</span>
  26 |     | <span class='neutral'> *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;</span>
  27 |     | <span class='neutral'> *     }</span>
  28 |     | <span class='neutral'> * }</span>
  29 |     | <span class='neutral'> * ```</span>
  30 |     | <span class='neutral'> */</span>
  31 |     | <span class='unexecuted'>library StorageSlot {</span>
  32 |     | <span class='neutral'>    struct AddressSlot {</span>
  33 |     | <span class='neutral'>        address value;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    struct BooleanSlot {</span>
  37 |     | <span class='neutral'>        bool value;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    struct Bytes32Slot {</span>
  41 |     | <span class='neutral'>        bytes32 value;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    struct Uint256Slot {</span>
  45 |     | <span class='neutral'>        uint256 value;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    struct StringSlot {</span>
  49 |     | <span class='neutral'>        string value;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    struct BytesSlot {</span>
  53 |     | <span class='neutral'>        bytes value;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Returns an `AddressSlot` with member `value` located at `slot`.</span>
  58 |     | <span class='neutral'>     */</span>
  59 |     | <span class='neutral'>    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {</span>
  60 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  61 |     | <span class='neutral'>        assembly {</span>
  62 |     | <span class='neutral'>            r.slot := slot</span>
  63 |     | <span class='neutral'>        }</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {</span>
  70 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  71 |     | <span class='neutral'>        assembly {</span>
  72 |     | <span class='neutral'>            r.slot := slot</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='neutral'>    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {</span>
  80 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='neutral'>            r.slot := slot</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {</span>
  90 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  91 |     | <span class='neutral'>        assembly {</span>
  92 |     | <span class='neutral'>            r.slot := slot</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Returns an `StringSlot` with member `value` located at `slot`.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {</span>
 100 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 101 |     | <span class='neutral'>        assembly {</span>
 102 |     | <span class='neutral'>            r.slot := slot</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /**</span>
 107 |     | <span class='neutral'>     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.</span>
 108 |     | <span class='neutral'>     */</span>
 109 |     | <span class='neutral'>    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {</span>
 110 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 111 |     | <span class='neutral'>        assembly {</span>
 112 |     | <span class='neutral'>            r.slot := store.slot</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /**</span>
 117 |     | <span class='neutral'>     * @dev Returns an `BytesSlot` with member `value` located at `slot`.</span>
 118 |     | <span class='neutral'>     */</span>
 119 |     | <span class='neutral'>    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {</span>
 120 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 121 |     | <span class='neutral'>        assembly {</span>
 122 |     | <span class='neutral'>            r.slot := slot</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.</span>
 128 |     | <span class='neutral'>     */</span>
 129 |     | <span class='neutral'>    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {</span>
 130 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 131 |     | <span class='neutral'>        assembly {</span>
 132 |     | <span class='neutral'>            r.slot := store.slot</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'>}</span>
 136 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin-4/contracts/utils/math/SignedMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Standard signed math utilities missing in the Solidity language.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library SignedMath {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Returns the largest of two signed numbers.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='unexecuted'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
 14 |     | <span class='unexecuted'>        return a &gt; b ? a : b;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the smallest of two signed numbers.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
 21 |     | <span class='unexecuted'>        return a &lt; b ? a : b;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the average of two signed numbers without overflow.</span>
 26 |     | <span class='neutral'>     * The result is rounded towards zero.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function average(int256 a, int256 b) internal pure returns (int256) {</span>
 29 |     | <span class='neutral'>        // Formula from the book &quot;Hacker&#39;s Delight&quot;</span>
 30 |     | <span class='neutral'>        int256 x = (a &amp; b) + ((a ^ b) &gt;&gt; 1);</span>
 31 |     | <span class='neutral'>        return x + (int256(uint256(x) &gt;&gt; 255) &amp; (a ^ b));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Returns the absolute unsigned value of a signed value.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        unchecked {</span>
 39 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 40 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../utils/ContextUpgradeable.sol&quot;;</span>
  7 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 11 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 12 |     | <span class='neutral'> * specific functions.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 15 |     | <span class='neutral'> * can later be changed with {transferOwnership}.</span>
 16 |     | <span class='neutral'> *</span>
 17 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 18 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 19 |     | <span class='neutral'> * the owner.</span>
 20 |     | <span class='neutral'> */</span>
 21 |     | <span class='neutral'>abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {</span>
 22 |     | <span class='neutral'>    address private _owner;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /**</span>
 27 |     | <span class='neutral'>     * @dev Initializes the contract setting the deployer as the initial owner.</span>
 28 |     | <span class='neutral'>     */</span>
 29 | *   | <span class='executed'>    function __Ownable_init() internal onlyInitializing {</span>
 30 | *   | <span class='executed'>        __Ownable_init_unchained();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function __Ownable_init_unchained() internal onlyInitializing {</span>
 34 | *   | <span class='executed'>        _transferOwnership(_msgSender());</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    /**</span>
 38 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 41 |     | <span class='unexecuted'>        _checkOwner();</span>
 42 |     | <span class='neutral'>        _;</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /**</span>
 46 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
 47 |     | <span class='neutral'>     */</span>
 48 |     | <span class='unexecuted'>    function owner() public view virtual returns (address) {</span>
 49 |     | <span class='unexecuted'>        return _owner;</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 54 |     | <span class='neutral'>     */</span>
 55 |     | <span class='unexecuted'>    function _checkOwner() internal view virtual {</span>
 56 |     | <span class='unexecuted'>        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /**</span>
 60 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 61 |     | <span class='neutral'>     * `onlyOwner` functions. Can only be called by the current owner.</span>
 62 |     | <span class='neutral'>     *</span>
 63 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 64 |     | <span class='neutral'>     * thereby disabling any functionality that is only available to the owner.</span>
 65 |     | <span class='neutral'>     */</span>
 66 | *   | <span class='executed'>    function renounceOwnership() public virtual onlyOwner {</span>
 67 | *   | <span class='executed'>        _transferOwnership(address(0));</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 72 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 73 |     | <span class='neutral'>     */</span>
 74 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 75 |     | <span class='unexecuted'>        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span>
 76 |     | <span class='unexecuted'>        _transferOwnership(newOwner);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 81 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 82 |     | <span class='neutral'>     */</span>
 83 | *   | <span class='executed'>    function _transferOwnership(address newOwner) internal virtual {</span>
 84 | *   | <span class='executed'>        address oldOwner = _owner;</span>
 85 | *   | <span class='executed'>        _owner = newOwner;</span>
 86 | *   | <span class='executed'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'></span>
 89 |     | <span class='neutral'>    /**</span>
 90 |     | <span class='neutral'>     * @dev This empty reserved space is put in place to allow future versions to add new</span>
 91 |     | <span class='neutral'>     * variables without shifting down storage in the inheritance chain.</span>
 92 |     | <span class='neutral'>     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps</span>
 93 |     | <span class='neutral'>     */</span>
 94 |     | <span class='neutral'>    uint256[49] private __gap;</span>
 95 |     | <span class='neutral'>}</span>
 96 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for</span>
  8 |     | <span class='neutral'> * deploying minimal proxy contracts, also known as &quot;clones&quot;.</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * &gt; To simply and cheaply clone contract functionality in an immutable way, this standard specifies</span>
 11 |     | <span class='neutral'> * &gt; a minimal bytecode implementation that delegates all calls to a known, fixed address.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`</span>
 14 |     | <span class='neutral'> * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the</span>
 15 |     | <span class='neutral'> * deterministic method.</span>
 16 |     | <span class='neutral'> *</span>
 17 |     | <span class='neutral'> * _Available since v3.4._</span>
 18 |     | <span class='neutral'> */</span>
 19 |     | <span class='unexecuted'>library ClonesUpgradeable {</span>
 20 |     | <span class='neutral'>    /**</span>
 21 |     | <span class='neutral'>     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.</span>
 22 |     | <span class='neutral'>     *</span>
 23 |     | <span class='neutral'>     * This function uses the create opcode, which should never revert.</span>
 24 |     | <span class='neutral'>     */</span>
 25 | *   | <span class='executed'>    function clone(address implementation) internal returns (address instance) {</span>
 26 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 27 |     | <span class='neutral'>        assembly {</span>
 28 |     | <span class='neutral'>            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes</span>
 29 |     | <span class='neutral'>            // of the `implementation` address with the bytecode before the address.</span>
 30 | *   | <span class='executed'>            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))</span>
 31 |     | <span class='neutral'>            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.</span>
 32 | *   | <span class='executed'>            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))</span>
 33 | *   | <span class='executed'>            instance := create(0, 0x09, 0x37)</span>
 34 |     | <span class='neutral'>        }</span>
 35 | *   | <span class='executed'>        require(instance != address(0), &quot;ERC1167: create failed&quot;);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    /**</span>
 39 |     | <span class='neutral'>     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.</span>
 40 |     | <span class='neutral'>     *</span>
 41 |     | <span class='neutral'>     * This function uses the create2 opcode and a `salt` to deterministically deploy</span>
 42 |     | <span class='neutral'>     * the clone. Using the same `implementation` and `salt` multiple time will revert, since</span>
 43 |     | <span class='neutral'>     * the clones cannot be deployed twice at the same address.</span>
 44 |     | <span class='neutral'>     */</span>
 45 |     | <span class='neutral'>    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {</span>
 46 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 47 |     | <span class='neutral'>        assembly {</span>
 48 |     | <span class='neutral'>            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes</span>
 49 |     | <span class='neutral'>            // of the `implementation` address with the bytecode before the address.</span>
 50 |     | <span class='neutral'>            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))</span>
 51 |     | <span class='neutral'>            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.</span>
 52 |     | <span class='neutral'>            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))</span>
 53 |     | <span class='neutral'>            instance := create2(0, 0x09, 0x37, salt)</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>        require(instance != address(0), &quot;ERC1167: create2 failed&quot;);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    /**</span>
 59 |     | <span class='neutral'>     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='neutral'>    function predictDeterministicAddress(</span>
 62 |     | <span class='neutral'>        address implementation,</span>
 63 |     | <span class='neutral'>        bytes32 salt,</span>
 64 |     | <span class='neutral'>        address deployer</span>
 65 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
 66 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 67 |     | <span class='neutral'>        assembly {</span>
 68 |     | <span class='neutral'>            let ptr := mload(0x40)</span>
 69 |     | <span class='neutral'>            mstore(add(ptr, 0x38), deployer)</span>
 70 |     | <span class='neutral'>            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)</span>
 71 |     | <span class='neutral'>            mstore(add(ptr, 0x14), implementation)</span>
 72 |     | <span class='neutral'>            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)</span>
 73 |     | <span class='neutral'>            mstore(add(ptr, 0x58), salt)</span>
 74 |     | <span class='neutral'>            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))</span>
 75 |     | <span class='neutral'>            predicted := keccak256(add(ptr, 0x43), 0x55)</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.</span>
 81 |     | <span class='neutral'>     */</span>
 82 |     | <span class='neutral'>    function predictDeterministicAddress(</span>
 83 |     | <span class='neutral'>        address implementation,</span>
 84 |     | <span class='neutral'>        bytes32 salt</span>
 85 |     | <span class='neutral'>    ) internal view returns (address predicted) {</span>
 86 |     | <span class='neutral'>        return predictDeterministicAddress(implementation, salt, address(this));</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../../utils/AddressUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed</span>
  10 |     | <span class='neutral'> * behind a proxy. Since proxied contracts do not make use of a constructor, it&#39;s common to move constructor logic to an</span>
  11 |     | <span class='neutral'> * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer</span>
  12 |     | <span class='neutral'> * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be</span>
  15 |     | <span class='neutral'> * reused. This mechanism prevents re-execution of each &quot;step&quot; but allows the creation of new initialization steps in</span>
  16 |     | <span class='neutral'> * case an upgrade adds a module that needs to be initialized.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * For example:</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> * [.hljs-theme-light.nopadding]</span>
  21 |     | <span class='neutral'> * ```solidity</span>
  22 |     | <span class='neutral'> * contract MyToken is ERC20Upgradeable {</span>
  23 |     | <span class='neutral'> *     function initialize() initializer public {</span>
  24 |     | <span class='neutral'> *         __ERC20_init(&quot;MyToken&quot;, &quot;MTK&quot;);</span>
  25 |     | <span class='neutral'> *     }</span>
  26 |     | <span class='neutral'> * }</span>
  27 |     | <span class='neutral'> *</span>
  28 |     | <span class='neutral'> * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {</span>
  29 |     | <span class='neutral'> *     function initializeV2() reinitializer(2) public {</span>
  30 |     | <span class='neutral'> *         __ERC20Permit_init(&quot;MyToken&quot;);</span>
  31 |     | <span class='neutral'> *     }</span>
  32 |     | <span class='neutral'> * }</span>
  33 |     | <span class='neutral'> * ```</span>
  34 |     | <span class='neutral'> *</span>
  35 |     | <span class='neutral'> * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as</span>
  36 |     | <span class='neutral'> * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.</span>
  37 |     | <span class='neutral'> *</span>
  38 |     | <span class='neutral'> * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure</span>
  39 |     | <span class='neutral'> * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.</span>
  40 |     | <span class='neutral'> *</span>
  41 |     | <span class='neutral'> * [CAUTION]</span>
  42 |     | <span class='neutral'> * ====</span>
  43 |     | <span class='neutral'> * Avoid leaving a contract uninitialized.</span>
  44 |     | <span class='neutral'> *</span>
  45 |     | <span class='neutral'> * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation</span>
  46 |     | <span class='neutral'> * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke</span>
  47 |     | <span class='neutral'> * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:</span>
  48 |     | <span class='neutral'> *</span>
  49 |     | <span class='neutral'> * [.hljs-theme-light.nopadding]</span>
  50 |     | <span class='neutral'> * ```</span>
  51 |     | <span class='neutral'> * /// @custom:oz-upgrades-unsafe-allow constructor</span>
  52 |     | <span class='neutral'> * constructor() {</span>
  53 |     | <span class='neutral'> *     _disableInitializers();</span>
  54 |     | <span class='neutral'> * }</span>
  55 |     | <span class='neutral'> * ```</span>
  56 |     | <span class='neutral'> * ====</span>
  57 |     | <span class='neutral'> */</span>
  58 |     | <span class='neutral'>abstract contract Initializable {</span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Indicates that the contract has been initialized.</span>
  61 |     | <span class='neutral'>     * @custom:oz-retyped-from bool</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    uint8 private _initialized;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Indicates that the contract is in the process of being initialized.</span>
  67 |     | <span class='neutral'>     */</span>
  68 |     | <span class='neutral'>    bool private _initializing;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Triggered when the contract has been initialized or reinitialized.</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='neutral'>    event Initialized(uint8 version);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,</span>
  77 |     | <span class='neutral'>     * `onlyInitializing` functions can be used to initialize parent contracts.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a</span>
  80 |     | <span class='neutral'>     * constructor.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Emits an {Initialized} event.</span>
  83 |     | <span class='neutral'>     */</span>
  84 | *   | <span class='executed'>    modifier initializer() {</span>
  85 | *   | <span class='executed'>        bool isTopLevelCall = !_initializing;</span>
  86 | *   | <span class='executed'>        require(</span>
  87 | *   | <span class='executed'>            (isTopLevelCall &amp;&amp; _initialized &lt; 1) || (!AddressUpgradeable.isContract(address(this)) &amp;&amp; _initialized == 1),</span>
  88 |     | <span class='neutral'>            &quot;Initializable: contract is already initialized&quot;</span>
  89 |     | <span class='neutral'>        );</span>
  90 | *   | <span class='executed'>        _initialized = 1;</span>
  91 | *   | <span class='executed'>        if (isTopLevelCall) {</span>
  92 | *   | <span class='executed'>            _initializing = true;</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>        _;</span>
  95 | *   | <span class='executed'>        if (isTopLevelCall) {</span>
  96 | *   | <span class='executed'>            _initializing = false;</span>
  97 | *   | <span class='executed'>            emit Initialized(1);</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the</span>
 103 |     | <span class='neutral'>     * contract hasn&#39;t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be</span>
 104 |     | <span class='neutral'>     * used to initialize parent contracts.</span>
 105 |     | <span class='neutral'>     *</span>
 106 |     | <span class='neutral'>     * A reinitializer may be used after the original initialization step. This is essential to configure modules that</span>
 107 |     | <span class='neutral'>     * are added through upgrades and that require initialization.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`</span>
 110 |     | <span class='neutral'>     * cannot be nested. If one is invoked in the context of another, execution will revert.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in</span>
 113 |     | <span class='neutral'>     * a contract, executing them in the right order is up to the developer or operator.</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * WARNING: setting the version to 255 will prevent any future reinitialization.</span>
 116 |     | <span class='neutral'>     *</span>
 117 |     | <span class='neutral'>     * Emits an {Initialized} event.</span>
 118 |     | <span class='neutral'>     */</span>
 119 |     | <span class='neutral'>    modifier reinitializer(uint8 version) {</span>
 120 |     | <span class='neutral'>        require(!_initializing &amp;&amp; _initialized &lt; version, &quot;Initializable: contract is already initialized&quot;);</span>
 121 |     | <span class='neutral'>        _initialized = version;</span>
 122 |     | <span class='neutral'>        _initializing = true;</span>
 123 |     | <span class='neutral'>        _;</span>
 124 |     | <span class='neutral'>        _initializing = false;</span>
 125 |     | <span class='neutral'>        emit Initialized(version);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    /**</span>
 129 |     | <span class='neutral'>     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the</span>
 130 |     | <span class='neutral'>     * {initializer} and {reinitializer} modifiers, directly or indirectly.</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    modifier onlyInitializing() {</span>
 133 | *   | <span class='executed'>        require(_initializing, &quot;Initializable: contract is not initializing&quot;);</span>
 134 |     | <span class='neutral'>        _;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /**</span>
 138 |     | <span class='neutral'>     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.</span>
 139 |     | <span class='neutral'>     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized</span>
 140 |     | <span class='neutral'>     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called</span>
 141 |     | <span class='neutral'>     * through proxies.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * Emits an {Initialized} event the first time it is successfully executed.</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='unexecuted'>    function _disableInitializers() internal virtual {</span>
 146 |     | <span class='unexecuted'>        require(!_initializing, &quot;Initializable: contract is initializing&quot;);</span>
 147 |     | <span class='unexecuted'>        if (_initialized != type(uint8).max) {</span>
 148 |     | <span class='unexecuted'>            _initialized = type(uint8).max;</span>
 149 |     | <span class='unexecuted'>            emit Initialized(type(uint8).max);</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /**</span>
 154 |     | <span class='neutral'>     * @dev Returns the highest version that has been initialized. See {reinitializer}.</span>
 155 |     | <span class='neutral'>     */</span>
 156 |     | <span class='neutral'>    function _getInitializedVersion() internal view returns (uint8) {</span>
 157 |     | <span class='neutral'>        return _initialized;</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.</span>
 162 |     | <span class='neutral'>     */</span>
 163 |     | <span class='neutral'>    function _isInitializing() internal view returns (bool) {</span>
 164 |     | <span class='neutral'>        return _initializing;</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'>}</span>
 167 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../utils/ContextUpgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev Contract module which allows children to implement an emergency stop</span>
  11 |     | <span class='neutral'> * mechanism that can be triggered by an authorized account.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This module is used through inheritance. It will make available the</span>
  14 |     | <span class='neutral'> * modifiers `whenNotPaused` and `whenPaused`, which can be applied to</span>
  15 |     | <span class='neutral'> * the functions of your contract. Note that they will not be pausable by</span>
  16 |     | <span class='neutral'> * simply including this module, only once the modifiers are put in place.</span>
  17 |     | <span class='neutral'> */</span>
  18 |     | <span class='neutral'>abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {</span>
  19 |     | <span class='neutral'>    /**</span>
  20 |     | <span class='neutral'>     * @dev Emitted when the pause is triggered by `account`.</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    event Paused(address account);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /**</span>
  25 |     | <span class='neutral'>     * @dev Emitted when the pause is lifted by `account`.</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='neutral'>    event Unpaused(address account);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    bool private _paused;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @dev Initializes the contract in unpaused state.</span>
  33 |     | <span class='neutral'>     */</span>
  34 | *   | <span class='executed'>    function __Pausable_init() internal onlyInitializing {</span>
  35 | *   | <span class='executed'>        __Pausable_init_unchained();</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>    function __Pausable_init_unchained() internal onlyInitializing {</span>
  39 | *   | <span class='executed'>        _paused = false;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is not paused.</span>
  44 |     | <span class='neutral'>     *</span>
  45 |     | <span class='neutral'>     * Requirements:</span>
  46 |     | <span class='neutral'>     *</span>
  47 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  48 |     | <span class='neutral'>     */</span>
  49 |     | <span class='neutral'>    modifier whenNotPaused() {</span>
  50 |     | <span class='unexecuted'>        _requireNotPaused();</span>
  51 |     | <span class='neutral'>        _;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is paused.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * Requirements:</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * - The contract must be paused.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    modifier whenPaused() {</span>
  62 |     | <span class='unexecuted'>        _requirePaused();</span>
  63 |     | <span class='neutral'>        _;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns true if the contract is paused, and false otherwise.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='unexecuted'>    function paused() public view virtual returns (bool) {</span>
  70 |     | <span class='unexecuted'>        return _paused;</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>     * @dev Throws if the contract is paused.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='unexecuted'>    function _requireNotPaused() internal view virtual {</span>
  77 |     | <span class='unexecuted'>        require(!paused(), &quot;Pausable: paused&quot;);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Throws if the contract is not paused.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='unexecuted'>    function _requirePaused() internal view virtual {</span>
  84 |     | <span class='unexecuted'>        require(paused(), &quot;Pausable: not paused&quot;);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @dev Triggers stopped state.</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * Requirements:</span>
  91 |     | <span class='neutral'>     *</span>
  92 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function _pause() internal virtual whenNotPaused {</span>
  95 |     | <span class='unexecuted'>        _paused = true;</span>
  96 |     | <span class='unexecuted'>        emit Paused(_msgSender());</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Returns to normal state.</span>
 101 |     | <span class='neutral'>     *</span>
 102 |     | <span class='neutral'>     * Requirements:</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * - The contract must be paused.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='unexecuted'>    function _unpause() internal virtual whenPaused {</span>
 107 |     | <span class='unexecuted'>        _paused = false;</span>
 108 |     | <span class='unexecuted'>        emit Unpaused(_msgSender());</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev This empty reserved space is put in place to allow future versions to add new</span>
 113 |     | <span class='neutral'>     * variables without shifting down storage in the inheritance chain.</span>
 114 |     | <span class='neutral'>     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps</span>
 115 |     | <span class='neutral'>     */</span>
 116 |     | <span class='neutral'>    uint256[49] private __gap;</span>
 117 |     | <span class='neutral'>}</span>
 118 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 11 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 12 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 15 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 16 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 17 |     | <span class='neutral'> * points to them.</span>
 18 |     | <span class='neutral'> *</span>
 19 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 20 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 21 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 22 |     | <span class='neutral'> */</span>
 23 |     | <span class='neutral'>abstract contract ReentrancyGuardUpgradeable is Initializable {</span>
 24 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 25 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 26 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 27 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 28 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 31 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 32 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 33 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 34 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 35 |     | <span class='unexecuted'>    uint256 private constant _NOT_ENTERED = 1;</span>
 36 |     | <span class='unexecuted'>    uint256 private constant _ENTERED = 2;</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    uint256 private _status;</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function __ReentrancyGuard_init() internal onlyInitializing {</span>
 41 |     | <span class='unexecuted'>        __ReentrancyGuard_init_unchained();</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>    function __ReentrancyGuard_init_unchained() internal onlyInitializing {</span>
 45 |     | <span class='neutral'>        _status = _NOT_ENTERED;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 50 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 51 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 52 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 53 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 54 |     | <span class='neutral'>     */</span>
 55 |     | <span class='neutral'>    modifier nonReentrant() {</span>
 56 |     | <span class='unexecuted'>        _nonReentrantBefore();</span>
 57 |     | <span class='neutral'>        _;</span>
 58 |     | <span class='unexecuted'>        _nonReentrantAfter();</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='unexecuted'>    function _nonReentrantBefore() private {</span>
 62 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 63 |     | <span class='unexecuted'>        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 66 |     | <span class='unexecuted'>        _status = _ENTERED;</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='unexecuted'>    function _nonReentrantAfter() private {</span>
 70 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 71 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 72 |     | <span class='unexecuted'>        _status = _NOT_ENTERED;</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    /**</span>
 76 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 77 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 78 |     | <span class='neutral'>     */</span>
 79 |     | <span class='neutral'>    function _reentrancyGuardEntered() internal view returns (bool) {</span>
 80 |     | <span class='neutral'>        return _status == _ENTERED;</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='neutral'>    /**</span>
 84 |     | <span class='neutral'>     * @dev This empty reserved space is put in place to allow future versions to add new</span>
 85 |     | <span class='neutral'>     * variables without shifting down storage in the inheritance chain.</span>
 86 |     | <span class='neutral'>     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    uint256[49] private __gap;</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20Upgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20MetadataUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/ContextUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Initializable} from &quot;../../proxy/utils/Initializable.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  15 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  16 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  19 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  20 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  23 |     | <span class='neutral'> * this function so it returns a different value.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  26 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  27 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  28 |     | <span class='neutral'> * applications.</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  31 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  32 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  33 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  34 |     | <span class='neutral'> *</span>
  35 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  36 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  37 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  38 |     | <span class='neutral'> */</span>
  39 |     | <span class='unexecuted'>contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {</span>
  40 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    string private _name;</span>
  47 |     | <span class='neutral'>    string private _symbol;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  53 |     | <span class='neutral'>     * construction.</span>
  54 |     | <span class='neutral'>     */</span>
  55 | *   | <span class='executed'>    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {</span>
  56 | *   | <span class='executed'>        __ERC20_init_unchained(name_, symbol_);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 | *   | <span class='executed'>    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {</span>
  60 | *   | <span class='executed'>        _name = name_;</span>
  61 | *   | <span class='executed'>        _symbol = symbol_;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  68 |     | <span class='unexecuted'>        return _name;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  73 |     | <span class='neutral'>     * name.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  76 |     | <span class='unexecuted'>        return _symbol;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  81 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  82 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  85 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  86 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  87 |     | <span class='neutral'>     *</span>
  88 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  89 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  90 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  93 |     | <span class='unexecuted'>        return 18;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
 100 |     | <span class='unexecuted'>        return _totalSupply;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='unexecuted'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 107 |     | <span class='unexecuted'>        return _balances[account];</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * Requirements:</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 116 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 119 |     | <span class='neutral'>        address owner = _msgSender();</span>
 120 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 121 |     | <span class='neutral'>        return true;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='unexecuted'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 128 |     | <span class='unexecuted'>        return _allowances[owner][spender];</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 135 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 136 |     | <span class='neutral'>     *</span>
 137 |     | <span class='neutral'>     * Requirements:</span>
 138 |     | <span class='neutral'>     *</span>
 139 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 140 |     | <span class='neutral'>     */</span>
 141 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 142 |     | <span class='neutral'>        address owner = _msgSender();</span>
 143 |     | <span class='unexecuted'>        _approve(owner, spender, amount);</span>
 144 |     | <span class='unexecuted'>        return true;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 149 |     | <span class='neutral'>     *</span>
 150 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 151 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 154 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 155 |     | <span class='neutral'>     *</span>
 156 |     | <span class='neutral'>     * Requirements:</span>
 157 |     | <span class='neutral'>     *</span>
 158 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 159 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 160 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 161 |     | <span class='neutral'>     * `amount`.</span>
 162 |     | <span class='neutral'>     */</span>
 163 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 164 |     | <span class='neutral'>        address spender = _msgSender();</span>
 165 |     | <span class='unexecuted'>        _spendAllowance(from, spender, amount);</span>
 166 |     | <span class='unexecuted'>        _transfer(from, to, amount);</span>
 167 |     | <span class='unexecuted'>        return true;</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /**</span>
 171 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 174 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 175 |     | <span class='neutral'>     *</span>
 176 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * Requirements:</span>
 179 |     | <span class='neutral'>     *</span>
 180 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 181 |     | <span class='neutral'>     */</span>
 182 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 183 |     | <span class='neutral'>        address owner = _msgSender();</span>
 184 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 185 |     | <span class='neutral'>        return true;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /**</span>
 189 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 192 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 193 |     | <span class='neutral'>     *</span>
 194 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 195 |     | <span class='neutral'>     *</span>
 196 |     | <span class='neutral'>     * Requirements:</span>
 197 |     | <span class='neutral'>     *</span>
 198 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 199 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 200 |     | <span class='neutral'>     * `subtractedValue`.</span>
 201 |     | <span class='neutral'>     */</span>
 202 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 203 |     | <span class='neutral'>        address owner = _msgSender();</span>
 204 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 205 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 206 |     | <span class='neutral'>        unchecked {</span>
 207 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        return true;</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 217 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 218 |     | <span class='neutral'>     *</span>
 219 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 220 |     | <span class='neutral'>     *</span>
 221 |     | <span class='neutral'>     * Requirements:</span>
 222 |     | <span class='neutral'>     *</span>
 223 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 224 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 225 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 226 |     | <span class='neutral'>     */</span>
 227 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 228 |     | <span class='unexecuted'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 229 |     | <span class='unexecuted'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        uint256 fromBalance = _balances[from];</span>
 234 |     | <span class='unexecuted'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 235 |     | <span class='neutral'>        unchecked {</span>
 236 |     | <span class='unexecuted'>            _balances[from] = fromBalance - amount;</span>
 237 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 238 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 239 |     | <span class='unexecuted'>            _balances[to] += amount;</span>
 240 |     | <span class='neutral'>        }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>        _afterTokenTransfer(from, to, amount);</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 248 |     | <span class='neutral'>     * the total supply.</span>
 249 |     | <span class='neutral'>     *</span>
 250 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 251 |     | <span class='neutral'>     *</span>
 252 |     | <span class='neutral'>     * Requirements:</span>
 253 |     | <span class='neutral'>     *</span>
 254 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 255 |     | <span class='neutral'>     */</span>
 256 |     | <span class='unexecuted'>    function _mint(address account, uint256 amount) internal virtual {</span>
 257 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='unexecuted'>        _totalSupply += amount;</span>
 262 |     | <span class='neutral'>        unchecked {</span>
 263 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 264 |     | <span class='unexecuted'>            _balances[account] += amount;</span>
 265 |     | <span class='neutral'>        }</span>
 266 |     | <span class='unexecuted'>        emit Transfer(address(0), account, amount);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    /**</span>
 272 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 273 |     | <span class='neutral'>     * total supply.</span>
 274 |     | <span class='neutral'>     *</span>
 275 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 276 |     | <span class='neutral'>     *</span>
 277 |     | <span class='neutral'>     * Requirements:</span>
 278 |     | <span class='neutral'>     *</span>
 279 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 280 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 281 |     | <span class='neutral'>     */</span>
 282 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 283 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 288 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 289 |     | <span class='neutral'>        unchecked {</span>
 290 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 291 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 292 |     | <span class='unexecuted'>            _totalSupply -= amount;</span>
 293 |     | <span class='neutral'>        }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    /**</span>
 301 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 304 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 305 |     | <span class='neutral'>     *</span>
 306 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 307 |     | <span class='neutral'>     *</span>
 308 |     | <span class='neutral'>     * Requirements:</span>
 309 |     | <span class='neutral'>     *</span>
 310 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 311 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 312 |     | <span class='neutral'>     */</span>
 313 |     | <span class='unexecuted'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 314 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 315 |     | <span class='unexecuted'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='unexecuted'>        _allowances[owner][spender] = amount;</span>
 318 |     | <span class='unexecuted'>        emit Approval(owner, spender, amount);</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    /**</span>
 322 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 323 |     | <span class='neutral'>     *</span>
 324 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 325 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 326 |     | <span class='neutral'>     *</span>
 327 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 328 |     | <span class='neutral'>     */</span>
 329 |     | <span class='unexecuted'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 330 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 331 |     | <span class='unexecuted'>        if (currentAllowance != type(uint256).max) {</span>
 332 |     | <span class='unexecuted'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 333 |     | <span class='neutral'>            unchecked {</span>
 334 |     | <span class='unexecuted'>                _approve(owner, spender, currentAllowance - amount);</span>
 335 |     | <span class='neutral'>            }</span>
 336 |     | <span class='neutral'>        }</span>
 337 |     | <span class='neutral'>    }</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    /**</span>
 340 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 341 |     | <span class='neutral'>     * minting and burning.</span>
 342 |     | <span class='neutral'>     *</span>
 343 |     | <span class='neutral'>     * Calling conditions:</span>
 344 |     | <span class='neutral'>     *</span>
 345 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 346 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 347 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 348 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 349 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 350 |     | <span class='neutral'>     *</span>
 351 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 352 |     | <span class='neutral'>     */</span>
 353 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='neutral'>    /**</span>
 356 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 357 |     | <span class='neutral'>     * minting and burning.</span>
 358 |     | <span class='neutral'>     *</span>
 359 |     | <span class='neutral'>     * Calling conditions:</span>
 360 |     | <span class='neutral'>     *</span>
 361 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 362 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 363 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 364 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 365 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 366 |     | <span class='neutral'>     *</span>
 367 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 368 |     | <span class='neutral'>     */</span>
 369 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    /**</span>
 372 |     | <span class='neutral'>     * @dev This empty reserved space is put in place to allow future versions to add new</span>
 373 |     | <span class='neutral'>     * variables without shifting down storage in the inheritance chain.</span>
 374 |     | <span class='neutral'>     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps</span>
 375 |     | <span class='neutral'>     */</span>
 376 |     | <span class='neutral'>    uint256[45] private __gap;</span>
 377 |     | <span class='neutral'>}</span>
 378 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20Upgradeable {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20Upgradeable.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20MetadataUpgradeable is IERC20Upgradeable {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ==== Security Considerations</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature</span>
 17 |     | <span class='neutral'> * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be</span>
 18 |     | <span class='neutral'> * considered as an intention to spend the allowance in any specific way. The second is that because permits have</span>
 19 |     | <span class='neutral'> * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should</span>
 20 |     | <span class='neutral'> * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be</span>
 21 |     | <span class='neutral'> * generally recommended is:</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * ```solidity</span>
 24 |     | <span class='neutral'> * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {</span>
 25 |     | <span class='neutral'> *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}</span>
 26 |     | <span class='neutral'> *     doThing(..., value);</span>
 27 |     | <span class='neutral'> * }</span>
 28 |     | <span class='neutral'> *</span>
 29 |     | <span class='neutral'> * function doThing(..., uint256 value) public {</span>
 30 |     | <span class='neutral'> *     token.safeTransferFrom(msg.sender, address(this), value);</span>
 31 |     | <span class='neutral'> *     ...</span>
 32 |     | <span class='neutral'> * }</span>
 33 |     | <span class='neutral'> * ```</span>
 34 |     | <span class='neutral'> *</span>
 35 |     | <span class='neutral'> * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of</span>
 36 |     | <span class='neutral'> * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also</span>
 37 |     | <span class='neutral'> * {SafeERC20-safeTransferFrom}).</span>
 38 |     | <span class='neutral'> *</span>
 39 |     | <span class='neutral'> * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so</span>
 40 |     | <span class='neutral'> * contracts should have entry points that don&#39;t rely on permit.</span>
 41 |     | <span class='neutral'> */</span>
 42 |     | <span class='neutral'>interface IERC20PermitUpgradeable {</span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 45 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 48 |     | <span class='neutral'>     * ordering also apply here.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 51 |     | <span class='neutral'>     *</span>
 52 |     | <span class='neutral'>     * Requirements:</span>
 53 |     | <span class='neutral'>     *</span>
 54 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 55 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 56 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 57 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 58 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 59 |     | <span class='neutral'>     *</span>
 60 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 61 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 62 |     | <span class='neutral'>     * section].</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * CAUTION: See Security Considerations above.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function permit(</span>
 67 |     | <span class='neutral'>        address owner,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 value,</span>
 70 |     | <span class='neutral'>        uint256 deadline,</span>
 71 |     | <span class='neutral'>        uint8 v,</span>
 72 |     | <span class='neutral'>        bytes32 r,</span>
 73 |     | <span class='neutral'>        bytes32 s</span>
 74 |     | <span class='neutral'>    ) external;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 78 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 81 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 89 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../IERC20Upgradeable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../extensions/IERC20PermitUpgradeable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../../utils/AddressUpgradeable.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library SafeERC20Upgradeable {</span>
  20 |     | <span class='neutral'>    using AddressUpgradeable for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
  24 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  25 |     | <span class='neutral'>     */</span>
  26 | *   | <span class='executed'>    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {</span>
  27 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the</span>
  32 |     | <span class='neutral'>     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='unexecuted'>    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {</span>
  35 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Deprecated. This function has issues similar to the ones found in</span>
  40 |     | <span class='neutral'>     * {IERC20-approve}, and its usage is discouraged.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Whenever possible, use {safeIncreaseAllowance} and</span>
  43 |     | <span class='neutral'>     * {safeDecreaseAllowance} instead.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {</span>
  46 |     | <span class='neutral'>        // safeApprove should only be called when setting an initial allowance,</span>
  47 |     | <span class='neutral'>        // or when resetting it to zero. To increase and decrease it, use</span>
  48 |     | <span class='neutral'>        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;</span>
  49 |     | <span class='neutral'>        require(</span>
  50 |     | <span class='neutral'>            (value == 0) || (token.allowance(address(this), spender) == 0),</span>
  51 |     | <span class='neutral'>            &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;</span>
  52 |     | <span class='neutral'>        );</span>
  53 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Increase the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  58 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {</span>
  61 |     | <span class='neutral'>        uint256 oldAllowance = token.allowance(address(this), spender);</span>
  62 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Decrease the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  67 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {</span>
  70 |     | <span class='neutral'>        unchecked {</span>
  71 |     | <span class='neutral'>            uint256 oldAllowance = token.allowance(address(this), spender);</span>
  72 |     | <span class='neutral'>            require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);</span>
  73 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Set the calling contract&#39;s allowance toward `spender` to `value`. If `token` returns no value,</span>
  79 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval</span>
  80 |     | <span class='neutral'>     * to be set to zero before setting it to a non-zero value, such as USDT.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {</span>
  83 |     | <span class='neutral'>        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        if (!_callOptionalReturnBool(token, approvalCall)) {</span>
  86 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));</span>
  87 |     | <span class='neutral'>            _callOptionalReturn(token, approvalCall);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.</span>
  93 |     | <span class='neutral'>     * Revert on invalid signature.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function safePermit(</span>
  96 |     | <span class='neutral'>        IERC20PermitUpgradeable token,</span>
  97 |     | <span class='neutral'>        address owner,</span>
  98 |     | <span class='neutral'>        address spender,</span>
  99 |     | <span class='neutral'>        uint256 value,</span>
 100 |     | <span class='neutral'>        uint256 deadline,</span>
 101 |     | <span class='neutral'>        uint8 v,</span>
 102 |     | <span class='neutral'>        bytes32 r,</span>
 103 |     | <span class='neutral'>        bytes32 s</span>
 104 |     | <span class='neutral'>    ) internal {</span>
 105 |     | <span class='neutral'>        uint256 nonceBefore = token.nonces(owner);</span>
 106 |     | <span class='neutral'>        token.permit(owner, spender, value, deadline, v, r, s);</span>
 107 |     | <span class='neutral'>        uint256 nonceAfter = token.nonces(owner);</span>
 108 |     | <span class='neutral'>        require(nonceAfter == nonceBefore + 1, &quot;SafeERC20: permit did not succeed&quot;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 113 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 114 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 115 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='unexecuted'>    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {</span>
 118 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 119 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
 120 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);</span>
 123 |     | <span class='unexecuted'>        require(returndata.length == 0 || abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 128 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 129 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 130 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {</span>
 135 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 136 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false</span>
 137 |     | <span class='neutral'>        // and not revert is the subcall reverts.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        (bool success, bytes memory returndata) = address(token).call(data);</span>
 140 |     | <span class='neutral'>        return</span>
 141 |     | <span class='neutral'>            success &amp;&amp; (returndata.length == 0 || abi.decode(returndata, (bool))) &amp;&amp; AddressUpgradeable.isContract(address(token));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library AddressUpgradeable {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Furthermore, `isContract` will also return true if the target contract within</span>
  27 |     | <span class='neutral'>     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,</span>
  28 |     | <span class='neutral'>     * which only has an effect at the end of a transaction.</span>
  29 |     | <span class='neutral'>     * ====</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * [IMPORTANT]</span>
  32 |     | <span class='neutral'>     * ====</span>
  33 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  36 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  37 |     | <span class='neutral'>     * constructor.</span>
  38 |     | <span class='neutral'>     * ====</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  41 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  42 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  43 |     | <span class='neutral'>        // of the constructor execution.</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  50 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  53 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  54 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  55 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  60 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  61 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  62 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  65 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  68 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  73 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  74 |     | <span class='neutral'>     * function instead.</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  77 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  80 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Requirements:</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  85 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * _Available since v3.1._</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  90 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  95 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * _Available since v3.1._</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='unexecuted'>    function functionCall(</span>
 100 |     | <span class='neutral'>        address target,</span>
 101 |     | <span class='neutral'>        bytes memory data,</span>
 102 |     | <span class='neutral'>        string memory errorMessage</span>
 103 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 104 |     | <span class='unexecuted'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 109 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 114 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * _Available since v3.1._</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
 119 |     | <span class='neutral'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='unexecuted'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 134 |     | <span class='unexecuted'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 |     | <span class='unexecuted'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 |     | <span class='unexecuted'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='neutral'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='unexecuted'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 |     | <span class='unexecuted'>    ) internal view returns (bytes memory) {</span>
 201 |     | <span class='unexecuted'>        if (success) {</span>
 202 |     | <span class='unexecuted'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 |     | <span class='unexecuted'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='unexecuted'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='unexecuted'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 |     | <span class='unexecuted'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>            assembly {</span>
 237 |     | <span class='unexecuted'>                let returndata_size := mload(returndata)</span>
 238 |     | <span class='unexecuted'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='unexecuted'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'>import {Initializable} from &quot;../proxy/utils/Initializable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  9 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
 10 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 11 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 12 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 13 |     | <span class='neutral'> * is concerned).</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='neutral'>abstract contract ContextUpgradeable is Initializable {</span>
 18 |     | <span class='neutral'>    function __Context_init() internal onlyInitializing {</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function __Context_init_unchained() internal onlyInitializing {</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='unexecuted'>    function _msgSender() internal view virtual returns (address) {</span>
 24 | *   | <span class='executed'>        return msg.sender;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 28 |     | <span class='neutral'>        return msg.data;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 32 |     | <span class='neutral'>        return 0;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev This empty reserved space is put in place to allow future versions to add new</span>
 37 |     | <span class='neutral'>     * variables without shifting down storage in the inheritance chain.</span>
 38 |     | <span class='neutral'>     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    uint256[50] private __gap;</span>
 41 |     | <span class='neutral'>}</span>
 42 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/Script.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./Vm.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./console.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./console2.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract Script {</span>
  9 |     | <span class='neutral'>    address constant private VM_ADDRESS =</span>
 10 |     | <span class='neutral'>        address(bytes20(uint160(uint256(keccak256(&#39;hevm cheat code&#39;)))));</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    Vm public constant vm = Vm(VM_ADDRESS);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/Test.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./Script.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;ds-test/test.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>// Wrappers around Cheatcodes to avoid footguns</span>
   8 |     | <span class='neutral'>abstract contract Test is DSTest, Script {</span>
   9 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event WARNING_Deprecated(string msg);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  18 |     | <span class='neutral'>                                    STD-CHEATS</span>
  19 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
  22 |     | <span class='neutral'>    function skip(uint256 time) public {</span>
  23 |     | <span class='neutral'>        vm.warp(block.timestamp + time);</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function rewind(uint256 time) public {</span>
  27 |     | <span class='neutral'>        vm.warp(block.timestamp - time);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
  31 |     | <span class='neutral'>    function hoax(address who) public {</span>
  32 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
  33 |     | <span class='neutral'>        vm.prank(who);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function hoax(address who, uint256 give) public {</span>
  37 |     | <span class='neutral'>        vm.deal(who, give);</span>
  38 |     | <span class='neutral'>        vm.prank(who);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    function hoax(address who, address origin) public {</span>
  42 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
  43 |     | <span class='neutral'>        vm.prank(who, origin);</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function hoax(address who, address origin, uint256 give) public {</span>
  47 |     | <span class='neutral'>        vm.deal(who, give);</span>
  48 |     | <span class='neutral'>        vm.prank(who, origin);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
  52 |     | <span class='neutral'>    function startHoax(address who) public {</span>
  53 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
  54 |     | <span class='neutral'>        vm.startPrank(who);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    function startHoax(address who, uint256 give) public {</span>
  58 |     | <span class='neutral'>        vm.deal(who, give);</span>
  59 |     | <span class='neutral'>        vm.startPrank(who);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
  63 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
  64 |     | <span class='neutral'>    function startHoax(address who, address origin) public {</span>
  65 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
  66 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    function startHoax(address who, address origin, uint256 give) public {</span>
  70 |     | <span class='neutral'>        vm.deal(who, give);</span>
  71 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function changePrank(address who) internal {</span>
  75 |     | <span class='neutral'>        vm.stopPrank();</span>
  76 |     | <span class='neutral'>        vm.startPrank(who);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    // DEPRECATED: Use `deal` instead</span>
  80 |     | <span class='neutral'>    function tip(address token, address to, uint256 give) public {</span>
  81 |     | <span class='neutral'>        emit WARNING_Deprecated(&quot;The `tip` stdcheat has been deprecated. Use `deal` instead.&quot;);</span>
  82 |     | <span class='neutral'>        stdstore</span>
  83 |     | <span class='neutral'>            .target(token)</span>
  84 |     | <span class='neutral'>            .sig(0x70a08231)</span>
  85 |     | <span class='neutral'>            .with_key(to)</span>
  86 |     | <span class='neutral'>            .checked_write(give);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // The same as Hevm&#39;s `deal`</span>
  90 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
  91 |     | <span class='neutral'>    function deal(address to, uint256 give) public {</span>
  92 |     | <span class='neutral'>        vm.deal(to, give);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
  96 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
  97 |     | <span class='neutral'>    function deal(address token, address to, uint256 give) public {</span>
  98 |     | <span class='neutral'>        deal(token, to, give, false);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    function deal(address token, address to, uint256 give, bool adjust) public {</span>
 102 |     | <span class='neutral'>        // get current balance</span>
 103 |     | <span class='neutral'>        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));</span>
 104 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        // update balance</span>
 107 |     | <span class='neutral'>        stdstore</span>
 108 |     | <span class='neutral'>            .target(token)</span>
 109 |     | <span class='neutral'>            .sig(0x70a08231)</span>
 110 |     | <span class='neutral'>            .with_key(to)</span>
 111 |     | <span class='neutral'>            .checked_write(give);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // update total supply</span>
 114 |     | <span class='neutral'>        if(adjust){</span>
 115 |     | <span class='neutral'>            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));</span>
 116 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 117 |     | <span class='neutral'>            if(give &lt; prevBal) {</span>
 118 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 119 |     | <span class='neutral'>            } else {</span>
 120 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 121 |     | <span class='neutral'>            }</span>
 122 |     | <span class='neutral'>            stdstore</span>
 123 |     | <span class='neutral'>                .target(token)</span>
 124 |     | <span class='neutral'>                .sig(0x18160ddd)</span>
 125 |     | <span class='neutral'>                .checked_write(totSup);</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function bound(uint256 x, uint256 min, uint256 max) public returns (uint256 result) {</span>
 130 |     | <span class='neutral'>        require(min &lt;= max, &quot;Test bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        uint256 size = max - min;</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        if (size == 0)</span>
 135 |     | <span class='neutral'>        {</span>
 136 |     | <span class='neutral'>            result = min;</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>        else if (size == UINT256_MAX)</span>
 139 |     | <span class='neutral'>        {</span>
 140 |     | <span class='neutral'>            result = x;</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>        else</span>
 143 |     | <span class='neutral'>        {</span>
 144 |     | <span class='neutral'>            ++size; // make `max` inclusive</span>
 145 |     | <span class='neutral'>            uint256 mod = x % size;</span>
 146 |     | <span class='neutral'>            result = min + mod;</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        emit log_named_uint(&quot;Bound Result&quot;, result);</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 153 |     | <span class='neutral'>    // the artifacts directory</span>
 154 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 155 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args)</span>
 156 |     | <span class='neutral'>        public</span>
 157 |     | <span class='neutral'>        returns (address addr)</span>
 158 |     | <span class='neutral'>    {</span>
 159 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 160 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 161 |     | <span class='neutral'>        assembly {</span>
 162 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        require(</span>
 166 |     | <span class='neutral'>            addr != address(0),</span>
 167 |     | <span class='neutral'>            &quot;Test deployCode(string,bytes): Deployment failed.&quot;</span>
 168 |     | <span class='neutral'>        );</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function deployCode(string memory what)</span>
 172 |     | <span class='neutral'>        public</span>
 173 |     | <span class='neutral'>        returns (address addr)</span>
 174 |     | <span class='neutral'>    {</span>
 175 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 176 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 177 |     | <span class='neutral'>        assembly {</span>
 178 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        require(</span>
 182 |     | <span class='neutral'>            addr != address(0),</span>
 183 |     | <span class='neutral'>            &quot;Test deployCode(string): Deployment failed.&quot;</span>
 184 |     | <span class='neutral'>        );</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
 188 |     | <span class='neutral'>                                    STD-ASSERTIONS</span>
 189 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function fail(string memory err) internal virtual {</span>
 192 |     | <span class='neutral'>        emit log_named_string(&quot;Error&quot;, err);</span>
 193 |     | <span class='neutral'>        fail();</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function assertFalse(bool data) internal virtual {</span>
 197 |     | <span class='neutral'>        assertTrue(!data);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal virtual {</span>
 201 |     | <span class='neutral'>        assertTrue(!data, err);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    function assertEq(bool a, bool b) internal {</span>
 205 |     | <span class='neutral'>        if (a != b) {</span>
 206 |     | <span class='neutral'>            emit log                (&quot;Error: a == b not satisfied [bool]&quot;);</span>
 207 |     | <span class='neutral'>            emit log_named_string   (&quot;  Expected&quot;, b ? &quot;true&quot; : &quot;false&quot;);</span>
 208 |     | <span class='neutral'>            emit log_named_string   (&quot;    Actual&quot;, a ? &quot;true&quot; : &quot;false&quot;);</span>
 209 |     | <span class='neutral'>            fail();</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    function assertEq(bool a, bool b, string memory err) internal {</span>
 214 |     | <span class='neutral'>        if (a != b) {</span>
 215 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 216 |     | <span class='neutral'>            assertEq(a, b);</span>
 217 |     | <span class='neutral'>        }</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b) internal {</span>
 221 |     | <span class='neutral'>        assertEq0(a, b);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b, string memory err) internal {</span>
 225 |     | <span class='neutral'>        assertEq0(a, b, err);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function assertApproxEqAbs(</span>
 229 |     | <span class='neutral'>        uint256 a,</span>
 230 |     | <span class='neutral'>        uint256 b,</span>
 231 |     | <span class='neutral'>        uint256 maxDelta</span>
 232 |     | <span class='neutral'>    ) internal virtual {</span>
 233 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 236 |     | <span class='neutral'>            emit log            (&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 237 |     | <span class='neutral'>            emit log_named_uint (&quot;  Expected&quot;, b);</span>
 238 |     | <span class='neutral'>            emit log_named_uint (&quot;    Actual&quot;, a);</span>
 239 |     | <span class='neutral'>            emit log_named_uint (&quot; Max Delta&quot;, maxDelta);</span>
 240 |     | <span class='neutral'>            emit log_named_uint (&quot;     Delta&quot;, delta);</span>
 241 |     | <span class='neutral'>            fail();</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>    function assertApproxEqAbs(</span>
 246 |     | <span class='neutral'>        uint256 a,</span>
 247 |     | <span class='neutral'>        uint256 b,</span>
 248 |     | <span class='neutral'>        uint256 maxDelta,</span>
 249 |     | <span class='neutral'>        string memory err</span>
 250 |     | <span class='neutral'>    ) internal virtual {</span>
 251 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 254 |     | <span class='neutral'>            emit log_named_string   (&quot;Error&quot;, err);</span>
 255 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 256 |     | <span class='neutral'>        }</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>    function assertApproxEqAbs(</span>
 260 |     | <span class='neutral'>        int256 a,</span>
 261 |     | <span class='neutral'>        int256 b,</span>
 262 |     | <span class='neutral'>        uint256 maxDelta</span>
 263 |     | <span class='neutral'>    ) internal virtual {</span>
 264 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 267 |     | <span class='neutral'>            emit log            (&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 268 |     | <span class='neutral'>            emit log_named_int  (&quot;  Expected&quot;, b);</span>
 269 |     | <span class='neutral'>            emit log_named_int  (&quot;    Actual&quot;, a);</span>
 270 |     | <span class='neutral'>            emit log_named_uint (&quot; Max Delta&quot;, maxDelta);</span>
 271 |     | <span class='neutral'>            emit log_named_uint (&quot;     Delta&quot;, delta);</span>
 272 |     | <span class='neutral'>            fail();</span>
 273 |     | <span class='neutral'>        }</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function assertApproxEqAbs(</span>
 277 |     | <span class='neutral'>        int256 a,</span>
 278 |     | <span class='neutral'>        int256 b,</span>
 279 |     | <span class='neutral'>        uint256 maxDelta,</span>
 280 |     | <span class='neutral'>        string memory err</span>
 281 |     | <span class='neutral'>    ) internal virtual {</span>
 282 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 285 |     | <span class='neutral'>            emit log_named_string   (&quot;Error&quot;, err);</span>
 286 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 291 |     | <span class='neutral'>        uint256 a,</span>
 292 |     | <span class='neutral'>        uint256 b,</span>
 293 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 294 |     | <span class='neutral'>    ) internal virtual {</span>
 295 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 300 |     | <span class='neutral'>            emit log                    (&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 301 |     | <span class='neutral'>            emit log_named_uint         (&quot;    Expected&quot;, b);</span>
 302 |     | <span class='neutral'>            emit log_named_uint         (&quot;      Actual&quot;, a);</span>
 303 |     | <span class='neutral'>            emit log_named_decimal_uint (&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 304 |     | <span class='neutral'>            emit log_named_decimal_uint (&quot;     % Delta&quot;, percentDelta, 18);</span>
 305 |     | <span class='neutral'>            fail();</span>
 306 |     | <span class='neutral'>        }</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 310 |     | <span class='neutral'>        uint256 a,</span>
 311 |     | <span class='neutral'>        uint256 b,</span>
 312 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 313 |     | <span class='neutral'>        string memory err</span>
 314 |     | <span class='neutral'>    ) internal virtual {</span>
 315 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 320 |     | <span class='neutral'>            emit log_named_string       (&quot;Error&quot;, err);</span>
 321 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='neutral'>    }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 326 |     | <span class='neutral'>        int256 a,</span>
 327 |     | <span class='neutral'>        int256 b,</span>
 328 |     | <span class='neutral'>        uint256 maxPercentDelta</span>
 329 |     | <span class='neutral'>    ) internal virtual {</span>
 330 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 335 |     | <span class='neutral'>            emit log                   (&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 336 |     | <span class='neutral'>            emit log_named_int         (&quot;    Expected&quot;, b);</span>
 337 |     | <span class='neutral'>            emit log_named_int         (&quot;      Actual&quot;, a);</span>
 338 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 339 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 340 |     | <span class='neutral'>            fail();</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 345 |     | <span class='neutral'>        int256 a,</span>
 346 |     | <span class='neutral'>        int256 b,</span>
 347 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
 348 |     | <span class='neutral'>        string memory err</span>
 349 |     | <span class='neutral'>    ) internal virtual {</span>
 350 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 355 |     | <span class='neutral'>            emit log_named_string      (&quot;Error&quot;, err);</span>
 356 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 357 |     | <span class='neutral'>        }</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'>}</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>/*//////////////////////////////////////////////////////////////////////////</span>
 362 |     | <span class='neutral'>                                STD-ERRORS</span>
 363 |     | <span class='neutral'>//////////////////////////////////////////////////////////////////////////*/</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>library stdError {</span>
 366 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
 367 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
 368 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
 369 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 370 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 371 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 372 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 373 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 374 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 375 |     | <span class='neutral'>    // DEPRECATED: Use Hevm&#39;s `expectRevert` without any arguments instead</span>
 376 |     | <span class='unexecuted'>    bytes public constant lowLevelError = bytes(&quot;&quot;); // `0x`</span>
 377 |     | <span class='neutral'>}</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='neutral'>/*//////////////////////////////////////////////////////////////////////////</span>
 380 |     | <span class='neutral'>                                STD-STORAGE</span>
 381 |     | <span class='neutral'>//////////////////////////////////////////////////////////////////////////*/</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>struct StdStorage {</span>
 384 |     | <span class='neutral'>    mapping (address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; uint256))) slots;</span>
 385 |     | <span class='neutral'>    mapping (address =&gt; mapping(bytes4 =&gt;  mapping(bytes32 =&gt; bool))) finds;</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    bytes32[] _keys;</span>
 388 |     | <span class='neutral'>    bytes4 _sig;</span>
 389 |     | <span class='neutral'>    uint256 _depth;</span>
 390 |     | <span class='neutral'>    address _target;</span>
 391 |     | <span class='neutral'>    bytes32 _set;</span>
 392 |     | <span class='neutral'>}</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='unexecuted'>library stdStorage {</span>
 395 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);</span>
 396 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint slot);</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 399 |     | <span class='neutral'>    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256(&#39;hevm cheat code&#39;)))));</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='neutral'>    function sigs(</span>
 404 |     | <span class='neutral'>        string memory sigStr</span>
 405 |     | <span class='neutral'>    )</span>
 406 |     | <span class='neutral'>        internal</span>
 407 |     | <span class='neutral'>        pure</span>
 408 |     | <span class='neutral'>        returns (bytes4)</span>
 409 |     | <span class='neutral'>    {</span>
 410 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
 411 |     | <span class='neutral'>    }</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
 414 |     | <span class='neutral'>    // slot complexity:</span>
 415 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
 416 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
 417 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
 418 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
 419 |     | <span class='neutral'>    function find(</span>
 420 |     | <span class='neutral'>        StdStorage storage self</span>
 421 |     | <span class='neutral'>    )</span>
 422 |     | <span class='neutral'>        internal</span>
 423 |     | <span class='neutral'>        returns (uint256)</span>
 424 |     | <span class='neutral'>    {</span>
 425 |     | <span class='neutral'>        address who = self._target;</span>
 426 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 427 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 428 |     | <span class='neutral'>        bytes32[] memory ins = self._keys;</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='neutral'>        // calldata to test against</span>
 431 |     | <span class='neutral'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
 432 |     | <span class='neutral'>            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
 433 |     | <span class='neutral'>        }</span>
 434 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
 435 |     | <span class='neutral'>        vm_std_store.record();</span>
 436 |     | <span class='neutral'>        bytes32 fdat;</span>
 437 |     | <span class='neutral'>        {</span>
 438 |     | <span class='neutral'>            (, bytes memory rdat) = who.staticcall(cald);</span>
 439 |     | <span class='neutral'>            fdat = bytesToBytes32(rdat, 32*field_depth);</span>
 440 |     | <span class='neutral'>        }</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='neutral'>        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));</span>
 443 |     | <span class='neutral'>        if (reads.length == 1) {</span>
 444 |     | <span class='neutral'>            bytes32 curr = vm_std_store.load(who, reads[0]);</span>
 445 |     | <span class='neutral'>            if (curr == bytes32(0)) {</span>
 446 |     | <span class='neutral'>                emit WARNING_UninitedSlot(who, uint256(reads[0]));</span>
 447 |     | <span class='neutral'>            }</span>
 448 |     | <span class='neutral'>            if (fdat != curr) {</span>
 449 |     | <span class='neutral'>                require(false, &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported&quot;);</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));</span>
 452 |     | <span class='neutral'>            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);</span>
 453 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
 454 |     | <span class='neutral'>        } else if (reads.length &gt; 1) {</span>
 455 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; reads.length; i++) {</span>
 456 |     | <span class='neutral'>                bytes32 prev = vm_std_store.load(who, reads[i]);</span>
 457 |     | <span class='neutral'>                if (prev == bytes32(0)) {</span>
 458 |     | <span class='neutral'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
 459 |     | <span class='neutral'>                }</span>
 460 |     | <span class='neutral'>                // store</span>
 461 |     | <span class='neutral'>                vm_std_store.store(who, reads[i], bytes32(hex&quot;1337&quot;));</span>
 462 |     | <span class='neutral'>                bool success;</span>
 463 |     | <span class='neutral'>                bytes memory rdat;</span>
 464 |     | <span class='neutral'>                {</span>
 465 |     | <span class='neutral'>                    (success, rdat) = who.staticcall(cald);</span>
 466 |     | <span class='neutral'>                    fdat = bytesToBytes32(rdat, 32*field_depth);</span>
 467 |     | <span class='neutral'>                }</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='neutral'>                if (success &amp;&amp; fdat == bytes32(hex&quot;1337&quot;)) {</span>
 470 |     | <span class='neutral'>                    // we found which of the slots is the actual one</span>
 471 |     | <span class='neutral'>                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));</span>
 472 |     | <span class='neutral'>                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);</span>
 473 |     | <span class='neutral'>                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
 474 |     | <span class='neutral'>                    vm_std_store.store(who, reads[i], prev);</span>
 475 |     | <span class='neutral'>                    break;</span>
 476 |     | <span class='neutral'>                }</span>
 477 |     | <span class='neutral'>                vm_std_store.store(who, reads[i], prev);</span>
 478 |     | <span class='neutral'>            }</span>
 479 |     | <span class='neutral'>        } else {</span>
 480 |     | <span class='neutral'>            require(false, &quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
 481 |     | <span class='neutral'>        }</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='neutral'>        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;);</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='neutral'>        delete self._target;</span>
 486 |     | <span class='neutral'>        delete self._sig;</span>
 487 |     | <span class='neutral'>        delete self._keys;</span>
 488 |     | <span class='neutral'>        delete self._depth;</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
 491 |     | <span class='neutral'>    }</span>
 492 |     | <span class='neutral'></span>
 493 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 494 |     | <span class='neutral'>        self._target = _target;</span>
 495 |     | <span class='neutral'>        return self;</span>
 496 |     | <span class='neutral'>    }</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 499 |     | <span class='neutral'>        self._sig = _sig;</span>
 500 |     | <span class='neutral'>        return self;</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 504 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 505 |     | <span class='neutral'>        return self;</span>
 506 |     | <span class='neutral'>    }</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 509 |     | <span class='neutral'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 510 |     | <span class='neutral'>        return self;</span>
 511 |     | <span class='neutral'>    }</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 514 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 515 |     | <span class='neutral'>        return self;</span>
 516 |     | <span class='neutral'>    }</span>
 517 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 518 |     | <span class='neutral'>        self._keys.push(key);</span>
 519 |     | <span class='neutral'>        return self;</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 523 |     | <span class='neutral'>        self._depth = _depth;</span>
 524 |     | <span class='neutral'>        return self;</span>
 525 |     | <span class='neutral'>    }</span>
 526 |     | <span class='neutral'></span>
 527 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 528 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 529 |     | <span class='neutral'>    }</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='neutral'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 532 |     | <span class='neutral'>        checked_write(self, bytes32(amt));</span>
 533 |     | <span class='neutral'>    }</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 536 |     | <span class='neutral'>        bytes32 t;</span>
 537 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 538 |     | <span class='neutral'>        assembly {</span>
 539 |     | <span class='neutral'>            t := write</span>
 540 |     | <span class='neutral'>        }</span>
 541 |     | <span class='neutral'>        checked_write(self, t);</span>
 542 |     | <span class='neutral'>    }</span>
 543 |     | <span class='neutral'></span>
 544 |     | <span class='neutral'>    function checked_write(</span>
 545 |     | <span class='neutral'>        StdStorage storage self,</span>
 546 |     | <span class='neutral'>        bytes32 set</span>
 547 |     | <span class='neutral'>    ) internal {</span>
 548 |     | <span class='neutral'>        address who = self._target;</span>
 549 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 550 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 551 |     | <span class='neutral'>        bytes32[] memory ins = self._keys;</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
 554 |     | <span class='neutral'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
 555 |     | <span class='neutral'>            find(self);</span>
 556 |     | <span class='neutral'>        }</span>
 557 |     | <span class='neutral'>        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='neutral'>        bytes32 fdat;</span>
 560 |     | <span class='neutral'>        {</span>
 561 |     | <span class='neutral'>            (, bytes memory rdat) = who.staticcall(cald);</span>
 562 |     | <span class='neutral'>            fdat = bytesToBytes32(rdat, 32*field_depth);</span>
 563 |     | <span class='neutral'>        }</span>
 564 |     | <span class='neutral'>        bytes32 curr = vm_std_store.load(who, slot);</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>        if (fdat != curr) {</span>
 567 |     | <span class='neutral'>            require(false, &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported.&quot;);</span>
 568 |     | <span class='neutral'>        }</span>
 569 |     | <span class='neutral'>        vm_std_store.store(who, slot, set);</span>
 570 |     | <span class='neutral'>        delete self._target;</span>
 571 |     | <span class='neutral'>        delete self._sig;</span>
 572 |     | <span class='neutral'>        delete self._keys;</span>
 573 |     | <span class='neutral'>        delete self._depth;</span>
 574 |     | <span class='neutral'>    }</span>
 575 |     | <span class='neutral'></span>
 576 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 577 |     | <span class='neutral'>        address t = self._target;</span>
 578 |     | <span class='neutral'>        uint256 s = find(self);</span>
 579 |     | <span class='neutral'>        return abi.encode(vm_std_store.load(t, bytes32(s)));</span>
 580 |     | <span class='neutral'>    }</span>
 581 |     | <span class='neutral'></span>
 582 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 583 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 584 |     | <span class='neutral'>    }</span>
 585 |     | <span class='neutral'></span>
 586 |     | <span class='neutral'></span>
 587 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 588 |     | <span class='neutral'>        return abi.decode(read(self), (bool));</span>
 589 |     | <span class='neutral'>    }</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 592 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 593 |     | <span class='neutral'>    }</span>
 594 |     | <span class='neutral'></span>
 595 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 596 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 597 |     | <span class='neutral'>    }</span>
 598 |     | <span class='neutral'></span>
 599 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 600 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='unexecuted'>    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {</span>
 604 |     | <span class='unexecuted'>        bytes32 out;</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='unexecuted'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 607 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; max; i++) {</span>
 608 |     | <span class='unexecuted'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 609 |     | <span class='neutral'>        }</span>
 610 |     | <span class='unexecuted'>        return out;</span>
 611 |     | <span class='neutral'>    }</span>
 612 |     | <span class='neutral'></span>
 613 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory)</span>
 614 |     | <span class='neutral'>    {</span>
 615 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 616 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 617 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 618 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 619 |     | <span class='neutral'>            assembly {</span>
 620 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 621 |     | <span class='neutral'>            }</span>
 622 |     | <span class='neutral'>        }</span>
 623 |     | <span class='neutral'></span>
 624 |     | <span class='neutral'>        return result;</span>
 625 |     | <span class='neutral'>    }</span>
 626 |     | <span class='neutral'>}</span>
 627 |     | <span class='neutral'></span>
 628 |     | <span class='neutral'>/*//////////////////////////////////////////////////////////////////////////</span>
 629 |     | <span class='neutral'>                                STD-MATH</span>
 630 |     | <span class='neutral'>//////////////////////////////////////////////////////////////////////////*/</span>
 631 |     | <span class='neutral'></span>
 632 |     | <span class='unexecuted'>library stdMath {</span>
 633 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 634 |     | <span class='neutral'></span>
 635 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
 636 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
 637 |     | <span class='neutral'>        if (a == INT256_MIN)</span>
 638 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 639 |     | <span class='neutral'></span>
 640 |     | <span class='neutral'>        return uint256(a &gt;= 0 ? a : -a);</span>
 641 |     | <span class='neutral'>    }</span>
 642 |     | <span class='neutral'></span>
 643 |     | <span class='neutral'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 644 |     | <span class='neutral'>        return a &gt; b</span>
 645 |     | <span class='neutral'>            ? a - b</span>
 646 |     | <span class='neutral'>            : b - a;</span>
 647 |     | <span class='neutral'>    }</span>
 648 |     | <span class='neutral'></span>
 649 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 650 |     | <span class='neutral'>        // a and b are of the same sign</span>
 651 |     | <span class='neutral'>        if (a &gt;= 0 &amp;&amp; b &gt;= 0 || a &lt; 0 &amp;&amp; b &lt; 0) {</span>
 652 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 653 |     | <span class='neutral'>        }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 656 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 657 |     | <span class='neutral'>    }</span>
 658 |     | <span class='neutral'></span>
 659 |     | <span class='neutral'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 660 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 661 |     | <span class='neutral'></span>
 662 |     | <span class='neutral'>        return absDelta * 1e18 / b;</span>
 663 |     | <span class='neutral'>    }</span>
 664 |     | <span class='neutral'></span>
 665 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 666 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 667 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 668 |     | <span class='neutral'></span>
 669 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 670 |     | <span class='neutral'>    }</span>
 671 |     | <span class='neutral'>}</span>
 672 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/Vm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0;</span>
  3 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface Vm {</span>
  6 |     | <span class='neutral'>    // Set block.timestamp (newTimestamp)</span>
  7 |     | <span class='neutral'>    function warp(uint256) external;</span>
  8 |     | <span class='neutral'>    // Set block.height (newHeight)</span>
  9 |     | <span class='neutral'>    function roll(uint256) external;</span>
 10 |     | <span class='neutral'>    // Set block.basefee (newBasefee)</span>
 11 |     | <span class='neutral'>    function fee(uint256) external;</span>
 12 |     | <span class='neutral'>    // Set block.chainid</span>
 13 |     | <span class='neutral'>    function chainId(uint256) external;</span>
 14 |     | <span class='neutral'>    // Loads a storage slot from an address (who, slot)</span>
 15 |     | <span class='neutral'>    function load(address,bytes32) external returns (bytes32);</span>
 16 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot, (who, slot, value)</span>
 17 |     | <span class='neutral'>    function store(address,bytes32,bytes32) external;</span>
 18 |     | <span class='neutral'>    // Signs data, (privateKey, digest) =&gt; (v, r, s)</span>
 19 |     | <span class='neutral'>    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);</span>
 20 |     | <span class='neutral'>    // Gets address for a given private key, (privateKey) =&gt; (address)</span>
 21 |     | <span class='neutral'>    function addr(uint256) external returns (address);</span>
 22 |     | <span class='neutral'>    // Gets the nonce of an account</span>
 23 |     | <span class='neutral'>    function getNonce(address) external returns (uint64);</span>
 24 |     | <span class='neutral'>    // Sets the nonce of an account; must be higher than the current nonce of the account</span>
 25 |     | <span class='neutral'>    function setNonce(address, uint64) external;</span>
 26 |     | <span class='neutral'>    // Performs a foreign function call via terminal, (stringInputs) =&gt; (result)</span>
 27 |     | <span class='neutral'>    function ffi(string[] calldata) external returns (bytes memory);</span>
 28 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address</span>
 29 |     | <span class='neutral'>    function prank(address) external;</span>
 30 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called</span>
 31 |     | <span class='neutral'>    function startPrank(address) external;</span>
 32 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address, and the tx.origin to be the second input</span>
 33 |     | <span class='neutral'>    function prank(address,address) external;</span>
 34 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input</span>
 35 |     | <span class='neutral'>    function startPrank(address,address) external;</span>
 36 |     | <span class='neutral'>    // Resets subsequent calls&#39; msg.sender to be `address(this)`</span>
 37 |     | <span class='neutral'>    function stopPrank() external;</span>
 38 |     | <span class='neutral'>    // Sets an address&#39; balance, (who, newBalance)</span>
 39 |     | <span class='neutral'>    function deal(address, uint256) external;</span>
 40 |     | <span class='neutral'>    // Sets an address&#39; code, (who, newCode)</span>
 41 |     | <span class='neutral'>    function etch(address, bytes calldata) external;</span>
 42 |     | <span class='neutral'>    // Expects an error on next call</span>
 43 |     | <span class='neutral'>    function expectRevert(bytes calldata) external;</span>
 44 |     | <span class='neutral'>    function expectRevert(bytes4) external;</span>
 45 |     | <span class='neutral'>    function expectRevert() external;</span>
 46 |     | <span class='neutral'>    // Record all storage reads and writes</span>
 47 |     | <span class='neutral'>    function record() external;</span>
 48 |     | <span class='neutral'>    // Gets all accessed reads and write slot from a recording session, for a given address</span>
 49 |     | <span class='neutral'>    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);</span>
 50 |     | <span class='neutral'>    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).</span>
 51 |     | <span class='neutral'>    // Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 52 |     | <span class='neutral'>    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)</span>
 53 |     | <span class='neutral'>    function expectEmit(bool,bool,bool,bool) external;</span>
 54 |     | <span class='neutral'>    function expectEmit(bool,bool,bool,bool,address) external;</span>
 55 |     | <span class='neutral'>    // Mocks a call to an address, returning specified data.</span>
 56 |     | <span class='neutral'>    // Calldata can either be strict or a partial match, e.g. if you only</span>
 57 |     | <span class='neutral'>    // pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 58 |     | <span class='neutral'>    // function will be mocked.</span>
 59 |     | <span class='neutral'>    function mockCall(address,bytes calldata,bytes calldata) external;</span>
 60 |     | <span class='neutral'>    // Mocks a call to an address with a specific msg.value, returning specified data.</span>
 61 |     | <span class='neutral'>    // Calldata match takes precedence over msg.value in case of ambiguity.</span>
 62 |     | <span class='neutral'>    function mockCall(address,uint256,bytes calldata,bytes calldata) external;</span>
 63 |     | <span class='neutral'>    // Clears all mocked calls</span>
 64 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 65 |     | <span class='neutral'>    // Expect a call to an address with the specified calldata.</span>
 66 |     | <span class='neutral'>    // Calldata can either be strict or a partial match</span>
 67 |     | <span class='neutral'>    function expectCall(address,bytes calldata) external;</span>
 68 |     | <span class='neutral'>    // Expect a call to an address with the specified msg.value and calldata</span>
 69 |     | <span class='neutral'>    function expectCall(address,uint256,bytes calldata) external;</span>
 70 |     | <span class='neutral'>    // Gets the code from an artifact file. Takes in the relative path to the json file</span>
 71 |     | <span class='neutral'>    function getCode(string calldata) external returns (bytes memory);</span>
 72 |     | <span class='neutral'>    // Labels an address in call traces</span>
 73 |     | <span class='neutral'>    function label(address, string calldata) external;</span>
 74 |     | <span class='neutral'>    // If the condition is false, discard this run&#39;s fuzz inputs and generate new ones</span>
 75 |     | <span class='neutral'>    function assume(bool) external;</span>
 76 |     | <span class='neutral'>    // Set block.coinbase (who)</span>
 77 |     | <span class='neutral'>    function coinbase(address) external;</span>
 78 |     | <span class='neutral'>    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain</span>
 79 |     | <span class='neutral'>    function broadcast() external;</span>
 80 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain</span>
 81 |     | <span class='neutral'>    function broadcast(address) external;</span>
 82 |     | <span class='neutral'>    // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain</span>
 83 |     | <span class='neutral'>    function startBroadcast() external;</span>
 84 |     | <span class='neutral'>    // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain</span>
 85 |     | <span class='neutral'>    function startBroadcast(address) external;</span>
 86 |     | <span class='neutral'>    // Stops collecting onchain transactions</span>
 87 |     | <span class='neutral'>    function stopBroadcast() external;</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>library console {</span>
    5 | *   | <span class='executed'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 | *   | <span class='executed'>    function _sendLogPayload(bytes memory payload) private view {</span>
    8 | *   | <span class='executed'>        uint256 payloadLength = payload.length;</span>
    9 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 | *   | <span class='executed'>        assembly {</span>
   12 | *   | <span class='executed'>            let payloadStart := add(payload, 32)</span>
   13 | *   | <span class='executed'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   14 |     | <span class='neutral'>        }</span>
   15 |     | <span class='neutral'>    }</span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='neutral'>    function log() internal view {</span>
   18 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   19 |     | <span class='neutral'>    }</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    function logInt(int p0) internal view {</span>
   22 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function logUint(uint p0) internal view {</span>
   26 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   34 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function log(uint p0) internal view {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 | *   | <span class='executed'>    function log(string memory p0) internal view {</span>
  178 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(uint p0, uint p1) internal view {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal view {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(uint p0, bool p1) internal view {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(uint p0, address p1) internal view {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='unexecuted'>    function log(string memory p0, uint p1) internal view {</span>
  206 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(bool p0, uint p1) internal view {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(address p0, uint p1) internal view {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2) internal view {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal view {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal view {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal view {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal view {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal view {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal view {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal view {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal view {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal view {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal view {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal view {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal view {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal view {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal view {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal view {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2) internal view {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal view {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal view {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal view {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal view {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal view {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal view {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal view {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal view {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal view {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal view {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal view {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal view {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal view {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal view {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal view {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal view {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal view {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal view {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal view {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal view {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal view {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal view {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal view {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal view {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal view {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal view {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal view {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal view {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal view {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal view {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal view {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal view {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal view {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal view {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal view {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal view {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal view {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal view {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal view {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal view {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal view {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal view {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal view {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal view {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal view {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal view {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal view {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal view {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal view {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal view {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal view {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal view {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal view {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal view {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal view {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal view {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal view {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal view {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal view {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal view {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal view {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal view {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal view {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal view {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal view {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal view {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal view {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal view {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal view {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal view {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal view {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal view {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal view {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal view {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal view {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal view {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal view {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal view {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal view {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal view {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal view {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal view {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal view {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal view {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal view {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal view {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal view {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal view {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal view {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal view {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal view {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal view {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal view {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal view {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal view {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal view {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal view {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal view {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal view {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal view {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal view {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal view {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal view {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal view {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal view {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal view {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal view {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal view {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal view {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal view {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal view {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal view {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal view {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal view {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal view {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal view {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal view {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal view {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal view {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal view {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal view {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal view {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal view {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal view {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal view {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal view {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal view {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal view {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal view {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal view {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal view {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal view {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal view {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal view {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal view {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal view {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal view {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal view {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal view {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal view {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal view {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal view {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal view {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal view {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal view {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal view {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal view {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal view {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal view {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal view {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal view {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal view {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal view {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal view {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal view {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal view {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal view {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal view {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal view {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal view {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal view {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal view {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal view {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal view {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal view {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal view {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal view {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal view {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal view {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal view {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/node_modules/forge-std/console2.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should</span>
    5 |     | <span class='neutral'>// use `int256` and `uint256`. This modified version fixes that. This version is recommended</span>
    6 |     | <span class='neutral'>// over `console.sol` if you don&#39;t need compatibility with Hardhat as the logs will show up in</span>
    7 |     | <span class='neutral'>// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.</span>
    8 |     | <span class='neutral'>// Reference: https://github.com/NomicFoundation/hardhat/issues/2178</span>
    9 |     | <span class='neutral'></span>
   10 |     | <span class='unexecuted'>library console2 {</span>
   11 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
   12 |     | <span class='neutral'></span>
   13 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) private view {</span>
   14 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
   15 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   16 |     | <span class='neutral'>        assembly {</span>
   17 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   18 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   19 |     | <span class='neutral'>        }</span>
   20 |     | <span class='neutral'>    }</span>
   21 |     | <span class='neutral'></span>
   22 |     | <span class='neutral'>    function log() internal view {</span>
   23 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   24 |     | <span class='neutral'>    }</span>
   25 |     | <span class='neutral'></span>
   26 |     | <span class='neutral'>    function logInt(int256 p0) internal view {</span>
   27 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   28 |     | <span class='neutral'>    }</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    function logUint(uint256 p0) internal view {</span>
   31 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   32 |     | <span class='neutral'>    }</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   35 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   36 |     | <span class='neutral'>    }</span>
   37 |     | <span class='neutral'></span>
   38 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   39 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   40 |     | <span class='neutral'>    }</span>
   41 |     | <span class='neutral'></span>
   42 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   43 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   44 |     | <span class='neutral'>    }</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   47 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   48 |     | <span class='neutral'>    }</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   51 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   52 |     | <span class='neutral'>    }</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   55 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   56 |     | <span class='neutral'>    }</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   59 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   60 |     | <span class='neutral'>    }</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   63 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   64 |     | <span class='neutral'>    }</span>
   65 |     | <span class='neutral'></span>
   66 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   67 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   68 |     | <span class='neutral'>    }</span>
   69 |     | <span class='neutral'></span>
   70 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   71 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   75 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   76 |     | <span class='neutral'>    }</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   79 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   80 |     | <span class='neutral'>    }</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   83 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   84 |     | <span class='neutral'>    }</span>
   85 |     | <span class='neutral'></span>
   86 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   87 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   88 |     | <span class='neutral'>    }</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   91 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   92 |     | <span class='neutral'>    }</span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   95 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   99 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  100 |     | <span class='neutral'>    }</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
  103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  104 |     | <span class='neutral'>    }</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  108 |     | <span class='neutral'>    }</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  112 |     | <span class='neutral'>    }</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  116 |     | <span class='neutral'>    }</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  120 |     | <span class='neutral'>    }</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  124 |     | <span class='neutral'>    }</span>
  125 |     | <span class='neutral'></span>
  126 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  128 |     | <span class='neutral'>    }</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  132 |     | <span class='neutral'>    }</span>
  133 |     | <span class='neutral'></span>
  134 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  140 |     | <span class='neutral'>    }</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  144 |     | <span class='neutral'>    }</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  148 |     | <span class='neutral'>    }</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  160 |     | <span class='neutral'>    }</span>
  161 |     | <span class='neutral'></span>
  162 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  164 |     | <span class='neutral'>    }</span>
  165 |     | <span class='neutral'></span>
  166 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  172 |     | <span class='neutral'>    }</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  176 |     | <span class='neutral'>    }</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>    function log(uint256 p0) internal view {</span>
  179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  180 |     | <span class='neutral'>    }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  184 |     | <span class='neutral'>    }</span>
  185 |     | <span class='neutral'></span>
  186 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  188 |     | <span class='neutral'>    }</span>
  189 |     | <span class='neutral'></span>
  190 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  192 |     | <span class='neutral'>    }</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal view {</span>
  195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  196 |     | <span class='neutral'>    }</span>
  197 |     | <span class='neutral'></span>
  198 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal view {</span>
  199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  200 |     | <span class='neutral'>    }</span>
  201 |     | <span class='neutral'></span>
  202 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal view {</span>
  203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  204 |     | <span class='neutral'>    }</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal view {</span>
  207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  208 |     | <span class='neutral'>    }</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='neutral'>    function log(string memory p0, uint256 p1) internal view {</span>
  211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  212 |     | <span class='neutral'>    }</span>
  213 |     | <span class='neutral'></span>
  214 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  216 |     | <span class='neutral'>    }</span>
  217 |     | <span class='neutral'></span>
  218 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  220 |     | <span class='neutral'>    }</span>
  221 |     | <span class='neutral'></span>
  222 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal view {</span>
  227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  228 |     | <span class='neutral'>    }</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  232 |     | <span class='neutral'>    }</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  236 |     | <span class='neutral'>    }</span>
  237 |     | <span class='neutral'></span>
  238 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  240 |     | <span class='neutral'>    }</span>
  241 |     | <span class='neutral'></span>
  242 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal view {</span>
  243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  244 |     | <span class='neutral'>    }</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  248 |     | <span class='neutral'>    }</span>
  249 |     | <span class='neutral'></span>
  250 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  252 |     | <span class='neutral'>    }</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  256 |     | <span class='neutral'>    }</span>
  257 |     | <span class='neutral'></span>
  258 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal view {</span>
  259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  260 |     | <span class='neutral'>    }</span>
  261 |     | <span class='neutral'></span>
  262 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal view {</span>
  263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  264 |     | <span class='neutral'>    }</span>
  265 |     | <span class='neutral'></span>
  266 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal view {</span>
  267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  268 |     | <span class='neutral'>    }</span>
  269 |     | <span class='neutral'></span>
  270 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal view {</span>
  271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  272 |     | <span class='neutral'>    }</span>
  273 |     | <span class='neutral'></span>
  274 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal view {</span>
  275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  276 |     | <span class='neutral'>    }</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal view {</span>
  279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  280 |     | <span class='neutral'>    }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal view {</span>
  283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  284 |     | <span class='neutral'>    }</span>
  285 |     | <span class='neutral'></span>
  286 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal view {</span>
  287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  288 |     | <span class='neutral'>    }</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal view {</span>
  291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  292 |     | <span class='neutral'>    }</span>
  293 |     | <span class='neutral'></span>
  294 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal view {</span>
  295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'></span>
  298 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal view {</span>
  299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  300 |     | <span class='neutral'>    }</span>
  301 |     | <span class='neutral'></span>
  302 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal view {</span>
  303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  304 |     | <span class='neutral'>    }</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal view {</span>
  307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  308 |     | <span class='neutral'>    }</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal view {</span>
  311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  312 |     | <span class='neutral'>    }</span>
  313 |     | <span class='neutral'></span>
  314 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal view {</span>
  315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  316 |     | <span class='neutral'>    }</span>
  317 |     | <span class='neutral'></span>
  318 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal view {</span>
  319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  320 |     | <span class='neutral'>    }</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal view {</span>
  323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  324 |     | <span class='neutral'>    }</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal view {</span>
  327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  328 |     | <span class='neutral'>    }</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal view {</span>
  331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  332 |     | <span class='neutral'>    }</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal view {</span>
  335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  336 |     | <span class='neutral'>    }</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal view {</span>
  339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  340 |     | <span class='neutral'>    }</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  344 |     | <span class='neutral'>    }</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  348 |     | <span class='neutral'>    }</span>
  349 |     | <span class='neutral'></span>
  350 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  352 |     | <span class='neutral'>    }</span>
  353 |     | <span class='neutral'></span>
  354 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal view {</span>
  355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  356 |     | <span class='neutral'>    }</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  360 |     | <span class='neutral'>    }</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  364 |     | <span class='neutral'>    }</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  368 |     | <span class='neutral'>    }</span>
  369 |     | <span class='neutral'></span>
  370 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal view {</span>
  371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  372 |     | <span class='neutral'>    }</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  376 |     | <span class='neutral'>    }</span>
  377 |     | <span class='neutral'></span>
  378 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  380 |     | <span class='neutral'>    }</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal view {</span>
  387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  388 |     | <span class='neutral'>    }</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal view {</span>
  391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  392 |     | <span class='neutral'>    }</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal view {</span>
  395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  396 |     | <span class='neutral'>    }</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal view {</span>
  399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  400 |     | <span class='neutral'>    }</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal view {</span>
  403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  404 |     | <span class='neutral'>    }</span>
  405 |     | <span class='neutral'></span>
  406 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  408 |     | <span class='neutral'>    }</span>
  409 |     | <span class='neutral'></span>
  410 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  416 |     | <span class='neutral'>    }</span>
  417 |     | <span class='neutral'></span>
  418 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal view {</span>
  419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  420 |     | <span class='neutral'>    }</span>
  421 |     | <span class='neutral'></span>
  422 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  424 |     | <span class='neutral'>    }</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  428 |     | <span class='neutral'>    }</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  432 |     | <span class='neutral'>    }</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal view {</span>
  435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  436 |     | <span class='neutral'>    }</span>
  437 |     | <span class='neutral'></span>
  438 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  440 |     | <span class='neutral'>    }</span>
  441 |     | <span class='neutral'></span>
  442 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  444 |     | <span class='neutral'>    }</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  448 |     | <span class='neutral'>    }</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal view {</span>
  451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  452 |     | <span class='neutral'>    }</span>
  453 |     | <span class='neutral'></span>
  454 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal view {</span>
  455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  456 |     | <span class='neutral'>    }</span>
  457 |     | <span class='neutral'></span>
  458 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal view {</span>
  459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal view {</span>
  463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  464 |     | <span class='neutral'>    }</span>
  465 |     | <span class='neutral'></span>
  466 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal view {</span>
  467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  468 |     | <span class='neutral'>    }</span>
  469 |     | <span class='neutral'></span>
  470 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  472 |     | <span class='neutral'>    }</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  476 |     | <span class='neutral'>    }</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  480 |     | <span class='neutral'>    }</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal view {</span>
  483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  484 |     | <span class='neutral'>    }</span>
  485 |     | <span class='neutral'></span>
  486 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  488 |     | <span class='neutral'>    }</span>
  489 |     | <span class='neutral'></span>
  490 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  492 |     | <span class='neutral'>    }</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  496 |     | <span class='neutral'>    }</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal view {</span>
  499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  500 |     | <span class='neutral'>    }</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  504 |     | <span class='neutral'>    }</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  508 |     | <span class='neutral'>    }</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  512 |     | <span class='neutral'>    }</span>
  513 |     | <span class='neutral'></span>
  514 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  516 |     | <span class='neutral'>    }</span>
  517 |     | <span class='neutral'></span>
  518 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  520 |     | <span class='neutral'>    }</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  524 |     | <span class='neutral'>    }</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  528 |     | <span class='neutral'>    }</span>
  529 |     | <span class='neutral'></span>
  530 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  532 |     | <span class='neutral'>    }</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  536 |     | <span class='neutral'>    }</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  540 |     | <span class='neutral'>    }</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {</span>
  543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  544 |     | <span class='neutral'>    }</span>
  545 |     | <span class='neutral'></span>
  546 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  547 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  551 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  552 |     | <span class='neutral'>    }</span>
  553 |     | <span class='neutral'></span>
  554 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {</span>
  555 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  556 |     | <span class='neutral'>    }</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {</span>
  559 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  560 |     | <span class='neutral'>    }</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  563 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  564 |     | <span class='neutral'>    }</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {</span>
  567 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  568 |     | <span class='neutral'>    }</span>
  569 |     | <span class='neutral'></span>
  570 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {</span>
  571 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  572 |     | <span class='neutral'>    }</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {</span>
  575 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  576 |     | <span class='neutral'>    }</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  579 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  583 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  584 |     | <span class='neutral'>    }</span>
  585 |     | <span class='neutral'></span>
  586 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  587 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  588 |     | <span class='neutral'>    }</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {</span>
  591 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  592 |     | <span class='neutral'>    }</span>
  593 |     | <span class='neutral'></span>
  594 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  595 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  596 |     | <span class='neutral'>    }</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  599 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  600 |     | <span class='neutral'>    }</span>
  601 |     | <span class='neutral'></span>
  602 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {</span>
  603 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  604 |     | <span class='neutral'>    }</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {</span>
  607 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  608 |     | <span class='neutral'>    }</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  611 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  612 |     | <span class='neutral'>    }</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {</span>
  615 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  616 |     | <span class='neutral'>    }</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {</span>
  619 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  620 |     | <span class='neutral'>    }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {</span>
  623 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  624 |     | <span class='neutral'>    }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {</span>
  627 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {</span>
  631 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  632 |     | <span class='neutral'>    }</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {</span>
  635 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  636 |     | <span class='neutral'>    }</span>
  637 |     | <span class='neutral'></span>
  638 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal view {</span>
  639 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  640 |     | <span class='neutral'>    }</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  643 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  644 |     | <span class='neutral'>    }</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  647 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  648 |     | <span class='neutral'>    }</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {</span>
  651 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  652 |     | <span class='neutral'>    }</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {</span>
  655 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  656 |     | <span class='neutral'>    }</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  659 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  660 |     | <span class='neutral'>    }</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {</span>
  663 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  664 |     | <span class='neutral'>    }</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {</span>
  667 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  668 |     | <span class='neutral'>    }</span>
  669 |     | <span class='neutral'></span>
  670 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {</span>
  671 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  672 |     | <span class='neutral'>    }</span>
  673 |     | <span class='neutral'></span>
  674 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {</span>
  675 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  676 |     | <span class='neutral'>    }</span>
  677 |     | <span class='neutral'></span>
  678 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {</span>
  679 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  680 |     | <span class='neutral'>    }</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {</span>
  683 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  684 |     | <span class='neutral'>    }</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal view {</span>
  687 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  688 |     | <span class='neutral'>    }</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {</span>
  691 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  692 |     | <span class='neutral'>    }</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {</span>
  695 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  696 |     | <span class='neutral'>    }</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal view {</span>
  699 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  700 |     | <span class='neutral'>    }</span>
  701 |     | <span class='neutral'></span>
  702 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal view {</span>
  703 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  704 |     | <span class='neutral'>    }</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  707 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  708 |     | <span class='neutral'>    }</span>
  709 |     | <span class='neutral'></span>
  710 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {</span>
  711 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  712 |     | <span class='neutral'>    }</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {</span>
  715 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  716 |     | <span class='neutral'>    }</span>
  717 |     | <span class='neutral'></span>
  718 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {</span>
  719 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  720 |     | <span class='neutral'>    }</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {</span>
  723 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {</span>
  727 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  728 |     | <span class='neutral'>    }</span>
  729 |     | <span class='neutral'></span>
  730 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {</span>
  731 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  732 |     | <span class='neutral'>    }</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal view {</span>
  735 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  736 |     | <span class='neutral'>    }</span>
  737 |     | <span class='neutral'></span>
  738 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {</span>
  739 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  740 |     | <span class='neutral'>    }</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {</span>
  743 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  744 |     | <span class='neutral'>    }</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal view {</span>
  747 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  748 |     | <span class='neutral'>    }</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal view {</span>
  751 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  752 |     | <span class='neutral'>    }</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {</span>
  755 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  756 |     | <span class='neutral'>    }</span>
  757 |     | <span class='neutral'></span>
  758 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal view {</span>
  759 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  760 |     | <span class='neutral'>    }</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal view {</span>
  763 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  764 |     | <span class='neutral'>    }</span>
  765 |     | <span class='neutral'></span>
  766 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal view {</span>
  767 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  768 |     | <span class='neutral'>    }</span>
  769 |     | <span class='neutral'></span>
  770 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  771 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  772 |     | <span class='neutral'>    }</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  775 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  776 |     | <span class='neutral'>    }</span>
  777 |     | <span class='neutral'></span>
  778 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  779 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  780 |     | <span class='neutral'>    }</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  783 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  784 |     | <span class='neutral'>    }</span>
  785 |     | <span class='neutral'></span>
  786 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  787 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  788 |     | <span class='neutral'>    }</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  791 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  792 |     | <span class='neutral'>    }</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  795 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {</span>
  799 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  800 |     | <span class='neutral'>    }</span>
  801 |     | <span class='neutral'></span>
  802 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  803 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  804 |     | <span class='neutral'>    }</span>
  805 |     | <span class='neutral'></span>
  806 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  807 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  808 |     | <span class='neutral'>    }</span>
  809 |     | <span class='neutral'></span>
  810 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {</span>
  811 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  812 |     | <span class='neutral'>    }</span>
  813 |     | <span class='neutral'></span>
  814 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {</span>
  815 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  816 |     | <span class='neutral'>    }</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  819 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  820 |     | <span class='neutral'>    }</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {</span>
  823 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  824 |     | <span class='neutral'>    }</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {</span>
  827 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  828 |     | <span class='neutral'>    }</span>
  829 |     | <span class='neutral'></span>
  830 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal view {</span>
  831 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  832 |     | <span class='neutral'>    }</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  835 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  836 |     | <span class='neutral'>    }</span>
  837 |     | <span class='neutral'></span>
  838 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  839 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  840 |     | <span class='neutral'>    }</span>
  841 |     | <span class='neutral'></span>
  842 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  843 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  844 |     | <span class='neutral'>    }</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {</span>
  847 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  848 |     | <span class='neutral'>    }</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  851 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  852 |     | <span class='neutral'>    }</span>
  853 |     | <span class='neutral'></span>
  854 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  855 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  856 |     | <span class='neutral'>    }</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  859 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'></span>
  862 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  863 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  864 |     | <span class='neutral'>    }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  867 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  868 |     | <span class='neutral'>    }</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  871 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  872 |     | <span class='neutral'>    }</span>
  873 |     | <span class='neutral'></span>
  874 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  875 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  876 |     | <span class='neutral'>    }</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  879 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  880 |     | <span class='neutral'>    }</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {</span>
  883 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  887 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  888 |     | <span class='neutral'>    }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  891 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  892 |     | <span class='neutral'>    }</span>
  893 |     | <span class='neutral'></span>
  894 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  895 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  896 |     | <span class='neutral'>    }</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  899 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  900 |     | <span class='neutral'>    }</span>
  901 |     | <span class='neutral'></span>
  902 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  903 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  904 |     | <span class='neutral'>    }</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {</span>
  907 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  908 |     | <span class='neutral'>    }</span>
  909 |     | <span class='neutral'></span>
  910 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {</span>
  911 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  912 |     | <span class='neutral'>    }</span>
  913 |     | <span class='neutral'></span>
  914 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  915 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  916 |     | <span class='neutral'>    }</span>
  917 |     | <span class='neutral'></span>
  918 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  919 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  920 |     | <span class='neutral'>    }</span>
  921 |     | <span class='neutral'></span>
  922 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  923 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  924 |     | <span class='neutral'>    }</span>
  925 |     | <span class='neutral'></span>
  926 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  927 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  928 |     | <span class='neutral'>    }</span>
  929 |     | <span class='neutral'></span>
  930 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {</span>
  931 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  932 |     | <span class='neutral'>    }</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  935 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  936 |     | <span class='neutral'>    }</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  939 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  940 |     | <span class='neutral'>    }</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  943 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  944 |     | <span class='neutral'>    }</span>
  945 |     | <span class='neutral'></span>
  946 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {</span>
  947 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  948 |     | <span class='neutral'>    }</span>
  949 |     | <span class='neutral'></span>
  950 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  951 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  952 |     | <span class='neutral'>    }</span>
  953 |     | <span class='neutral'></span>
  954 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  955 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  956 |     | <span class='neutral'>    }</span>
  957 |     | <span class='neutral'></span>
  958 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  959 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  960 |     | <span class='neutral'>    }</span>
  961 |     | <span class='neutral'></span>
  962 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  963 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  964 |     | <span class='neutral'>    }</span>
  965 |     | <span class='neutral'></span>
  966 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {</span>
  967 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  968 |     | <span class='neutral'>    }</span>
  969 |     | <span class='neutral'></span>
  970 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {</span>
  971 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  972 |     | <span class='neutral'>    }</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal view {</span>
  975 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  976 |     | <span class='neutral'>    }</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {</span>
  979 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  983 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  984 |     | <span class='neutral'>    }</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  987 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  988 |     | <span class='neutral'>    }</span>
  989 |     | <span class='neutral'></span>
  990 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  991 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  992 |     | <span class='neutral'>    }</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {</span>
  995 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  996 |     | <span class='neutral'>    }</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  999 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1000 |     | <span class='neutral'>    }</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
 1003 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1004 |     | <span class='neutral'>    }</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1007 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1008 |     | <span class='neutral'>    }</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal view {</span>
 1011 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1015 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1016 |     | <span class='neutral'>    }</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1019 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1020 |     | <span class='neutral'>    }</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1023 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1024 |     | <span class='neutral'>    }</span>
 1025 |     | <span class='neutral'></span>
 1026 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1027 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1028 |     | <span class='neutral'>    }</span>
 1029 |     | <span class='neutral'></span>
 1030 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1031 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1032 |     | <span class='neutral'>    }</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1035 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1036 |     | <span class='neutral'>    }</span>
 1037 |     | <span class='neutral'></span>
 1038 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1039 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1040 |     | <span class='neutral'>    }</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1043 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1044 |     | <span class='neutral'>    }</span>
 1045 |     | <span class='neutral'></span>
 1046 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1047 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1048 |     | <span class='neutral'>    }</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1051 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1052 |     | <span class='neutral'>    }</span>
 1053 |     | <span class='neutral'></span>
 1054 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1055 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1056 |     | <span class='neutral'>    }</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1059 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1060 |     | <span class='neutral'>    }</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1063 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1064 |     | <span class='neutral'>    }</span>
 1065 |     | <span class='neutral'></span>
 1066 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1067 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1068 |     | <span class='neutral'>    }</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal view {</span>
 1071 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1072 |     | <span class='neutral'>    }</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1075 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1076 |     | <span class='neutral'>    }</span>
 1077 |     | <span class='neutral'></span>
 1078 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1079 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1080 |     | <span class='neutral'>    }</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal view {</span>
 1083 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1084 |     | <span class='neutral'>    }</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal view {</span>
 1087 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1088 |     | <span class='neutral'>    }</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1091 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1092 |     | <span class='neutral'>    }</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1095 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1096 |     | <span class='neutral'>    }</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1099 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1100 |     | <span class='neutral'>    }</span>
 1101 |     | <span class='neutral'></span>
 1102 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1104 |     | <span class='neutral'>    }</span>
 1105 |     | <span class='neutral'></span>
 1106 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1108 |     | <span class='neutral'>    }</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1112 |     | <span class='neutral'>    }</span>
 1113 |     | <span class='neutral'></span>
 1114 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1116 |     | <span class='neutral'>    }</span>
 1117 |     | <span class='neutral'></span>
 1118 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1120 |     | <span class='neutral'>    }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1124 |     | <span class='neutral'>    }</span>
 1125 |     | <span class='neutral'></span>
 1126 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1128 |     | <span class='neutral'>    }</span>
 1129 |     | <span class='neutral'></span>
 1130 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1132 |     | <span class='neutral'>    }</span>
 1133 |     | <span class='neutral'></span>
 1134 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1136 |     | <span class='neutral'>    }</span>
 1137 |     | <span class='neutral'></span>
 1138 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1140 |     | <span class='neutral'>    }</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1144 |     | <span class='neutral'>    }</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1148 |     | <span class='neutral'>    }</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1152 |     | <span class='neutral'>    }</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1156 |     | <span class='neutral'>    }</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1160 |     | <span class='neutral'>    }</span>
 1161 |     | <span class='neutral'></span>
 1162 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1164 |     | <span class='neutral'>    }</span>
 1165 |     | <span class='neutral'></span>
 1166 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal view {</span>
 1167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1168 |     | <span class='neutral'>    }</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1172 |     | <span class='neutral'>    }</span>
 1173 |     | <span class='neutral'></span>
 1174 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1176 |     | <span class='neutral'>    }</span>
 1177 |     | <span class='neutral'></span>
 1178 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1180 |     | <span class='neutral'>    }</span>
 1181 |     | <span class='neutral'></span>
 1182 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1184 |     | <span class='neutral'>    }</span>
 1185 |     | <span class='neutral'></span>
 1186 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1188 |     | <span class='neutral'>    }</span>
 1189 |     | <span class='neutral'></span>
 1190 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1192 |     | <span class='neutral'>    }</span>
 1193 |     | <span class='neutral'></span>
 1194 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1196 |     | <span class='neutral'>    }</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1200 |     | <span class='neutral'>    }</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal view {</span>
 1203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1204 |     | <span class='neutral'>    }</span>
 1205 |     | <span class='neutral'></span>
 1206 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1208 |     | <span class='neutral'>    }</span>
 1209 |     | <span class='neutral'></span>
 1210 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1212 |     | <span class='neutral'>    }</span>
 1213 |     | <span class='neutral'></span>
 1214 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1216 |     | <span class='neutral'>    }</span>
 1217 |     | <span class='neutral'></span>
 1218 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1220 |     | <span class='neutral'>    }</span>
 1221 |     | <span class='neutral'></span>
 1222 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1224 |     | <span class='neutral'>    }</span>
 1225 |     | <span class='neutral'></span>
 1226 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal view {</span>
 1227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1228 |     | <span class='neutral'>    }</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal view {</span>
 1231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1232 |     | <span class='neutral'>    }</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1236 |     | <span class='neutral'>    }</span>
 1237 |     | <span class='neutral'></span>
 1238 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1240 |     | <span class='neutral'>    }</span>
 1241 |     | <span class='neutral'></span>
 1242 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1244 |     | <span class='neutral'>    }</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1248 |     | <span class='neutral'>    }</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal view {</span>
 1251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1252 |     | <span class='neutral'>    }</span>
 1253 |     | <span class='neutral'></span>
 1254 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1256 |     | <span class='neutral'>    }</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1260 |     | <span class='neutral'>    }</span>
 1261 |     | <span class='neutral'></span>
 1262 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1264 |     | <span class='neutral'>    }</span>
 1265 |     | <span class='neutral'></span>
 1266 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal view {</span>
 1267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1268 |     | <span class='neutral'>    }</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1272 |     | <span class='neutral'>    }</span>
 1273 |     | <span class='neutral'></span>
 1274 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1276 |     | <span class='neutral'>    }</span>
 1277 |     | <span class='neutral'></span>
 1278 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1280 |     | <span class='neutral'>    }</span>
 1281 |     | <span class='neutral'></span>
 1282 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1284 |     | <span class='neutral'>    }</span>
 1285 |     | <span class='neutral'></span>
 1286 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1288 |     | <span class='neutral'>    }</span>
 1289 |     | <span class='neutral'></span>
 1290 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1292 |     | <span class='neutral'>    }</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1296 |     | <span class='neutral'>    }</span>
 1297 |     | <span class='neutral'></span>
 1298 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1300 |     | <span class='neutral'>    }</span>
 1301 |     | <span class='neutral'></span>
 1302 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1304 |     | <span class='neutral'>    }</span>
 1305 |     | <span class='neutral'></span>
 1306 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1308 |     | <span class='neutral'>    }</span>
 1309 |     | <span class='neutral'></span>
 1310 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1312 |     | <span class='neutral'>    }</span>
 1313 |     | <span class='neutral'></span>
 1314 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1316 |     | <span class='neutral'>    }</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1320 |     | <span class='neutral'>    }</span>
 1321 |     | <span class='neutral'></span>
 1322 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1324 |     | <span class='neutral'>    }</span>
 1325 |     | <span class='neutral'></span>
 1326 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal view {</span>
 1327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1328 |     | <span class='neutral'>    }</span>
 1329 |     | <span class='neutral'></span>
 1330 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1332 |     | <span class='neutral'>    }</span>
 1333 |     | <span class='neutral'></span>
 1334 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1336 |     | <span class='neutral'>    }</span>
 1337 |     | <span class='neutral'></span>
 1338 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal view {</span>
 1339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1340 |     | <span class='neutral'>    }</span>
 1341 |     | <span class='neutral'></span>
 1342 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal view {</span>
 1343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1344 |     | <span class='neutral'>    }</span>
 1345 |     | <span class='neutral'></span>
 1346 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1348 |     | <span class='neutral'>    }</span>
 1349 |     | <span class='neutral'></span>
 1350 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1352 |     | <span class='neutral'>    }</span>
 1353 |     | <span class='neutral'></span>
 1354 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1356 |     | <span class='neutral'>    }</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1360 |     | <span class='neutral'>    }</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1364 |     | <span class='neutral'>    }</span>
 1365 |     | <span class='neutral'></span>
 1366 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1368 |     | <span class='neutral'>    }</span>
 1369 |     | <span class='neutral'></span>
 1370 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1372 |     | <span class='neutral'>    }</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1376 |     | <span class='neutral'>    }</span>
 1377 |     | <span class='neutral'></span>
 1378 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1380 |     | <span class='neutral'>    }</span>
 1381 |     | <span class='neutral'></span>
 1382 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1384 |     | <span class='neutral'>    }</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1388 |     | <span class='neutral'>    }</span>
 1389 |     | <span class='neutral'></span>
 1390 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1392 |     | <span class='neutral'>    }</span>
 1393 |     | <span class='neutral'></span>
 1394 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1396 |     | <span class='neutral'>    }</span>
 1397 |     | <span class='neutral'></span>
 1398 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1400 |     | <span class='neutral'>    }</span>
 1401 |     | <span class='neutral'></span>
 1402 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1404 |     | <span class='neutral'>    }</span>
 1405 |     | <span class='neutral'></span>
 1406 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1408 |     | <span class='neutral'>    }</span>
 1409 |     | <span class='neutral'></span>
 1410 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1412 |     | <span class='neutral'>    }</span>
 1413 |     | <span class='neutral'></span>
 1414 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1416 |     | <span class='neutral'>    }</span>
 1417 |     | <span class='neutral'></span>
 1418 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1420 |     | <span class='neutral'>    }</span>
 1421 |     | <span class='neutral'></span>
 1422 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal view {</span>
 1423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1424 |     | <span class='neutral'>    }</span>
 1425 |     | <span class='neutral'></span>
 1426 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1428 |     | <span class='neutral'>    }</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1432 |     | <span class='neutral'>    }</span>
 1433 |     | <span class='neutral'></span>
 1434 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1436 |     | <span class='neutral'>    }</span>
 1437 |     | <span class='neutral'></span>
 1438 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1440 |     | <span class='neutral'>    }</span>
 1441 |     | <span class='neutral'></span>
 1442 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1444 |     | <span class='neutral'>    }</span>
 1445 |     | <span class='neutral'></span>
 1446 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1448 |     | <span class='neutral'>    }</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1452 |     | <span class='neutral'>    }</span>
 1453 |     | <span class='neutral'></span>
 1454 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1456 |     | <span class='neutral'>    }</span>
 1457 |     | <span class='neutral'></span>
 1458 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal view {</span>
 1459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1460 |     | <span class='neutral'>    }</span>
 1461 |     | <span class='neutral'></span>
 1462 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1464 |     | <span class='neutral'>    }</span>
 1465 |     | <span class='neutral'></span>
 1466 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1468 |     | <span class='neutral'>    }</span>
 1469 |     | <span class='neutral'></span>
 1470 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1472 |     | <span class='neutral'>    }</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1476 |     | <span class='neutral'>    }</span>
 1477 |     | <span class='neutral'></span>
 1478 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1480 |     | <span class='neutral'>    }</span>
 1481 |     | <span class='neutral'></span>
 1482 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal view {</span>
 1483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1484 |     | <span class='neutral'>    }</span>
 1485 |     | <span class='neutral'></span>
 1486 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal view {</span>
 1487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1488 |     | <span class='neutral'>    }</span>
 1489 |     | <span class='neutral'></span>
 1490 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1492 |     | <span class='neutral'>    }</span>
 1493 |     | <span class='neutral'></span>
 1494 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1496 |     | <span class='neutral'>    }</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1500 |     | <span class='neutral'>    }</span>
 1501 |     | <span class='neutral'></span>
 1502 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1504 |     | <span class='neutral'>    }</span>
 1505 |     | <span class='neutral'></span>
 1506 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal view {</span>
 1507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1508 |     | <span class='neutral'>    }</span>
 1509 |     | <span class='neutral'></span>
 1510 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1512 |     | <span class='neutral'>    }</span>
 1513 |     | <span class='neutral'></span>
 1514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1516 |     | <span class='neutral'>    }</span>
 1517 |     | <span class='neutral'></span>
 1518 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1520 |     | <span class='neutral'>    }</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal view {</span>
 1523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1524 |     | <span class='neutral'>    }</span>
 1525 |     | <span class='neutral'></span>
 1526 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1528 |     | <span class='neutral'>    }</span>
 1529 |     | <span class='neutral'></span>
 1530 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1532 |     | <span class='neutral'>    }</span>
 1533 |     | <span class='neutral'></span>
 1534 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1536 |     | <span class='neutral'>    }</span>
 1537 |     | <span class='neutral'></span>
 1538 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/test/crytic/CustomActor.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
 3 |     | <span class='unexecuted'>contract CustomActor {</span>
 4 |     | <span class='unexecuted'>    function proxy(address target, bytes memory data) public returns (bool success, bytes memory retData) {</span>
 5 |     | <span class='unexecuted'>        return target.call(data);</span>
 6 |     | <span class='neutral'>    }</span>
 7 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/test/crytic/Hevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IHevm {</span>
  5 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  6 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // Set block.number to newNumber</span>
  9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Add the condition b to the assumption base for the current branch</span>
 12 |     | <span class='neutral'>    // This function is almost identical to require</span>
 13 |     | <span class='neutral'>    function assume(bool b) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    // Sets the eth balance of usr to amt</span>
 16 |     | <span class='neutral'>    function deal(address usr, uint256 amt) external;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 19 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 22 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (v, r, s)</span>
 25 |     | <span class='neutral'>    function sign(</span>
 26 |     | <span class='neutral'>        uint256 privateKey,</span>
 27 |     | <span class='neutral'>        bytes32 digest</span>
 28 |     | <span class='neutral'>    ) external returns (uint8 v, bytes32 r, bytes32 s);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    // Gets address for a given private key</span>
 31 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address addr);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 34 |     | <span class='neutral'>    function ffi(</span>
 35 |     | <span class='neutral'>        string[] calldata inputs</span>
 36 |     | <span class='neutral'>    ) external returns (bytes memory result);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 39 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 42 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    // Takes a fork identifier created by createFork and sets the corresponding forked state as active</span>
 45 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    // Returns the identifier of the current fork</span>
 48 |     | <span class='neutral'>    function activeFork() external returns (uint256);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    // Labels the address in traces</span>
 51 |     | <span class='neutral'>    function label(address addr, string calldata label) external;</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/mohamedmohamed/Desktop/hacking/smart-contracts/contests/beefyCowcentrated/code/CLM/cowcentrated-contracts/test/crytic/VeldromeLiquidityProvider.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// Interface for Velodrome router</span>
  7 |     | <span class='neutral'>interface IVelodromeRouter {</span>
  8 |     | <span class='neutral'>    function addLiquidity(</span>
  9 |     | <span class='neutral'>        address tokenA,</span>
 10 |     | <span class='neutral'>        address tokenB,</span>
 11 |     | <span class='neutral'>        bool stable,</span>
 12 |     | <span class='neutral'>        uint256 amountADesired,</span>
 13 |     | <span class='neutral'>        uint256 amountBDesired,</span>
 14 |     | <span class='neutral'>        uint256 amountAMin,</span>
 15 |     | <span class='neutral'>        uint256 amountBMin,</span>
 16 |     | <span class='neutral'>        address to,</span>
 17 |     | <span class='neutral'>        uint256 deadline</span>
 18 |     | <span class='neutral'>    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>contract VelodromeLiquidityProvider{</span>
 22 |     | <span class='unexecuted'>    IVelodromeRouter public velodromeRouter;</span>
 23 |     | <span class='unexecuted'>    IERC20 public tokenA;</span>
 24 |     | <span class='unexecuted'>    IERC20 public tokenB;</span>
 25 |     | <span class='unexecuted'>    bool public stable;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    constructor(</span>
 28 |     | <span class='neutral'>        address _velodromeRouter,</span>
 29 |     | <span class='neutral'>        address _tokenA,</span>
 30 |     | <span class='neutral'>        address _tokenB,</span>
 31 |     | <span class='neutral'>        bool _stable</span>
 32 |     | <span class='neutral'>    ) {</span>
 33 |     | <span class='unexecuted'>        velodromeRouter = IVelodromeRouter(_velodromeRouter);</span>
 34 |     | <span class='unexecuted'>        tokenA = IERC20(_tokenA);</span>
 35 |     | <span class='unexecuted'>        tokenB = IERC20(_tokenB);</span>
 36 |     | <span class='unexecuted'>        stable = _stable;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function deposit(</span>
 40 |     | <span class='neutral'>        uint256 amountADesired,</span>
 41 |     | <span class='neutral'>        uint256 amountBDesired,</span>
 42 |     | <span class='neutral'>        uint256 amountAMin,</span>
 43 |     | <span class='neutral'>        uint256 amountBMin,</span>
 44 |     | <span class='neutral'>        address to,</span>
 45 |     | <span class='neutral'>        uint256 deadline</span>
 46 |     | <span class='neutral'>    ) external {</span>
 47 |     | <span class='neutral'>        // Transfer tokens from the owner to this contract</span>
 48 |     | <span class='unexecuted'>        tokenA.transferFrom(msg.sender, address(this), amountADesired);</span>
 49 |     | <span class='unexecuted'>        tokenB.transferFrom(msg.sender, address(this), amountBDesired);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>        // Approve the Velodrome router to spend the tokens</span>
 52 |     | <span class='unexecuted'>        tokenA.approve(address(velodromeRouter), amountADesired);</span>
 53 |     | <span class='unexecuted'>        tokenB.approve(address(velodromeRouter), amountBDesired);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>        // Add liquidity</span>
 56 |     | <span class='unexecuted'>        velodromeRouter.addLiquidity(</span>
 57 |     | <span class='unexecuted'>            address(tokenA),</span>
 58 |     | <span class='unexecuted'>            address(tokenB),</span>
 59 |     | <span class='unexecuted'>            stable,</span>
 60 |     | <span class='neutral'>            amountADesired,</span>
 61 |     | <span class='neutral'>            amountBDesired,</span>
 62 |     | <span class='neutral'>            amountAMin,</span>
 63 |     | <span class='neutral'>            amountBMin,</span>
 64 |     | <span class='neutral'>            to,</span>
 65 |     | <span class='neutral'>            deadline</span>
 66 |     | <span class='neutral'>        );</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'>}</span>

</code>
<br />

